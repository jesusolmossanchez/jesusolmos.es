var THREE = { REVISION: "71" }; "object" == typeof module && (module.exports = THREE), void 0 === Math.sign && (Math.sign = function (t) { return t < 0 ? -1 : t > 0 ? 1 : +t }), THREE.log = function () { console.log.apply(console, arguments) }, THREE.warn = function () { }, THREE.error = function () { console.error.apply(console, arguments) }, THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, THREE.DoubleSide = 2, THREE.NoShading = 0, THREE.FlatShading = 1, THREE.SmoothShading = 2, THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, THREE.ReverseSubtractEquation = 102, THREE.MinEquation = 103, THREE.MaxEquation = 104, THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, THREE.SrcAlphaSaturateFactor = 210, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, THREE.AddOperation = 2, THREE.UVMapping = 300, THREE.CubeReflectionMapping = 301, THREE.CubeRefractionMapping = 302, THREE.EquirectangularReflectionMapping = 303, THREE.EquirectangularRefractionMapping = 304, THREE.SphericalReflectionMapping = 305, THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.HalfFloatType = 1025, THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023, THREE.RGBEFormat = THREE.RGBAFormat, THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, THREE.RGB_PVRTC_4BPPV1_Format = 2100, THREE.RGB_PVRTC_2BPPV1_Format = 2101, THREE.RGBA_PVRTC_4BPPV1_Format = 2102, THREE.RGBA_PVRTC_2BPPV1_Format = 2103, THREE.Projector = function () { THREE.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (t, e) { THREE.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e) }, this.unprojectVector = function (t, e) { THREE.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e) }, this.pickingRay = function (t, e) { THREE.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().") } }, THREE.CanvasRenderer = function () { THREE.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElement("canvas"), this.clear = function () { }, this.render = function () { }, this.setClearColor = function () { }, this.setSize = function () { } }, THREE.Color = function (t) { return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(t) }, THREE.Color.prototype = { constructor: THREE.Color, r: 1, g: 1, b: 1, set: function (t) { return t instanceof THREE.Color ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }, setHex: function (t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }, setRGB: function (t, e, r) { return this.r = t, this.g = e, this.b = r, this }, setHSL: function (t, e, r) { if (0 === e) this.r = this.g = this.b = r; else { var i = function (t, e, r) { return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + 6 * (e - t) * r : r < .5 ? e : r < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - r) : t }, n = r <= .5 ? r * (1 + e) : r + e - r * e, a = 2 * r - n; this.r = i(a, n, t + 1 / 3), this.g = i(a, n, t), this.b = i(a, n, t - 1 / 3) } return this }, setStyle: function (t) { if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(t)) { var e = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(t); return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, this } if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(t)) { e = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(t); return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, this } if (/^\#([0-9a-f]{6})$/i.test(t)) { e = /^\#([0-9a-f]{6})$/i.exec(t); return this.setHex(parseInt(e[1], 16)), this } if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(t)) { e = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(t); return this.setHex(parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3], 16)), this } if (/^(\w+)$/i.test(t)) return this.setHex(THREE.ColorKeywords[t]), this }, copy: function (t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }, copyGammaToLinear: function (t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, copyLinearToGamma: function (t, e) { void 0 === e && (e = 2); var r = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, r), this.g = Math.pow(t.g, r), this.b = Math.pow(t.b, r), this }, convertGammaToLinear: function () { var t = this.r, e = this.g, r = this.b; return this.r = t * t, this.g = e * e, this.b = r * r, this }, convertLinearToGamma: function () { return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (t) { var e, r, i = t || { h: 0, s: 0, l: 0 }, n = this.r, a = this.g, o = this.b, s = Math.max(n, a, o), h = Math.min(n, a, o), l = (h + s) / 2; if (h === s) e = 0, r = 0; else { var c = s - h; switch (r = l <= .5 ? c / (s + h) : c / (2 - s - h), s) { case n: e = (a - o) / c + (a < o ? 6 : 0); break; case a: e = (o - n) / c + 2; break; case o: e = (n - a) / c + 4 }e /= 6 } return i.h = e, i.s = r, i.l = l, i }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: function (t, e, r) { var i = this.getHSL(); return i.h += t, i.s += e, i.l += r, this.setHSL(i.h, i.s, i.l), this }, add: function (t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }, addColors: function (t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }, addScalar: function (t) { return this.r += t, this.g += t, this.b += t, this }, multiply: function (t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }, multiplyScalar: function (t) { return this.r *= t, this.g *= t, this.b *= t, this }, lerp: function (t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }, equals: function (t) { return t.r === this.r && t.g === this.g && t.b === this.b }, fromArray: function (t) { return this.r = t[0], this.g = t[1], this.b = t[2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }, clone: function () { return (new THREE.Color).setRGB(this.r, this.g, this.b) } }, THREE.ColorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, THREE.Quaternion = function (t, e, r, i) { this._x = t || 0, this._y = e || 0, this._z = r || 0, this._w = void 0 !== i ? i : 1 }, THREE.Quaternion.prototype = { constructor: THREE.Quaternion, _x: 0, _y: 0, _z: 0, _w: 0, get x() { return this._x }, set x(t) { this._x = t, this.onChangeCallback() }, get y() { return this._y }, set y(t) { this._y = t, this.onChangeCallback() }, get z() { return this._z }, set z(t) { this._z = t, this.onChangeCallback() }, get w() { return this._w }, set w(t) { this._w = t, this.onChangeCallback() }, set: function (t, e, r, i) { return this._x = t, this._y = e, this._z = r, this._w = i, this.onChangeCallback(), this }, copy: function (t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this }, setFromEuler: function (t, e) { if (t instanceof THREE.Euler == !1) throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var r = Math.cos(t._x / 2), i = Math.cos(t._y / 2), n = Math.cos(t._z / 2), a = Math.sin(t._x / 2), o = Math.sin(t._y / 2), s = Math.sin(t._z / 2); return "XYZ" === t.order ? (this._x = a * i * n + r * o * s, this._y = r * o * n - a * i * s, this._z = r * i * s + a * o * n, this._w = r * i * n - a * o * s) : "YXZ" === t.order ? (this._x = a * i * n + r * o * s, this._y = r * o * n - a * i * s, this._z = r * i * s - a * o * n, this._w = r * i * n + a * o * s) : "ZXY" === t.order ? (this._x = a * i * n - r * o * s, this._y = r * o * n + a * i * s, this._z = r * i * s + a * o * n, this._w = r * i * n - a * o * s) : "ZYX" === t.order ? (this._x = a * i * n - r * o * s, this._y = r * o * n + a * i * s, this._z = r * i * s - a * o * n, this._w = r * i * n + a * o * s) : "YZX" === t.order ? (this._x = a * i * n + r * o * s, this._y = r * o * n + a * i * s, this._z = r * i * s - a * o * n, this._w = r * i * n - a * o * s) : "XZY" === t.order && (this._x = a * i * n - r * o * s, this._y = r * o * n - a * i * s, this._z = r * i * s + a * o * n, this._w = r * i * n + a * o * s), !1 !== e && this.onChangeCallback(), this }, setFromAxisAngle: function (t, e) { var r = e / 2, i = Math.sin(r); return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(r), this.onChangeCallback(), this }, setFromRotationMatrix: function (t) { var e, r = t.elements, i = r[0], n = r[4], a = r[8], o = r[1], s = r[5], h = r[9], l = r[2], c = r[6], u = r[10], E = i + s + u; return E > 0 ? (e = .5 / Math.sqrt(E + 1), this._w = .25 / e, this._x = (c - h) * e, this._y = (a - l) * e, this._z = (o - n) * e) : i > s && i > u ? (e = 2 * Math.sqrt(1 + i - s - u), this._w = (c - h) / e, this._x = .25 * e, this._y = (n + o) / e, this._z = (a + l) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - i - u), this._w = (a - l) / e, this._x = (n + o) / e, this._y = .25 * e, this._z = (h + c) / e) : (e = 2 * Math.sqrt(1 + u - i - s), this._w = (o - n) / e, this._x = (a + l) / e, this._y = (h + c) / e, this._z = .25 * e), this.onChangeCallback(), this }, setFromUnitVectors: function () { var t, e; return function (r, i) { return void 0 === t && (t = new THREE.Vector3), (e = r.dot(i) + 1) < 1e-6 ? (e = 0, Math.abs(r.x) > Math.abs(r.z) ? t.set(-r.y, r.x, 0) : t.set(0, -r.z, r.y)) : t.crossVectors(r, i), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize(), this } }(), inverse: function () { return this.conjugate().normalize(), this }, conjugate: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this }, dot: function (t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { var t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this }, multiply: function (t, e) { return void 0 !== e ? (THREE.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }, multiplyQuaternions: function (t, e) { var r = t._x, i = t._y, n = t._z, a = t._w, o = e._x, s = e._y, h = e._z, l = e._w; return this._x = r * l + a * o + i * h - n * s, this._y = i * l + a * s + n * o - r * h, this._z = n * l + a * h + r * s - i * o, this._w = a * l - r * o - i * s - n * h, this.onChangeCallback(), this }, multiplyVector3: function (t) { return THREE.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, slerp: function (t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); var r = this._x, i = this._y, n = this._z, a = this._w, o = a * t._w + r * t._x + i * t._y + n * t._z; if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = r, this._y = i, this._z = n, this; var s = Math.acos(o), h = Math.sqrt(1 - o * o); if (Math.abs(h) < .001) return this._w = .5 * (a + this._w), this._x = .5 * (r + this._x), this._y = .5 * (i + this._y), this._z = .5 * (n + this._z), this; var l = Math.sin((1 - e) * s) / h, c = Math.sin(e * s) / h; return this._w = a * l + this._w * c, this._x = r * l + this._x * c, this._y = i * l + this._y * c, this._z = n * l + this._z * c, this.onChangeCallback(), this }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () { }, clone: function () { return new THREE.Quaternion(this._x, this._y, this._z, this._w) } }, THREE.Quaternion.slerp = function (t, e, r, i) { return r.copy(t).slerp(e, i) }, THREE.Vector2 = function (t, e) { this.x = t || 0, this.y = e || 0 }, THREE.Vector2.prototype = { constructor: THREE.Vector2, set: function (t, e) { return this.x = t, this.y = e, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) } }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } }, copy: function (t) { return this.x = t.x, this.y = t.y, this }, add: function (t, e) { return void 0 !== e ? (THREE.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }, addScalar: function (t) { return this.x += t, this.y += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }, sub: function (t, e) { return void 0 !== e ? (THREE.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this }, divideScalar: function (t) { if (0 !== t) { var e = 1 / t; this.x *= e, this.y *= e } else this.x = 0, this.y = 0; return this }, min: function (t) { return this.x > t.x && (this.x = t.x), this.y > t.y && (this.y = t.y), this }, max: function (t) { return this.x < t.x && (this.x = t.x), this.y < t.y && (this.y = t.y), this }, clamp: function (t, e) { return this.x < t.x ? this.x = t.x : this.x > e.x && (this.x = e.x), this.y < t.y ? this.y = t.y : this.y > e.y && (this.y = e.y), this }, clampScalar: function () { var t, e; return function (r, i) { return void 0 === t && (t = new THREE.Vector2, e = new THREE.Vector2), t.set(r, r), e.set(i, i), this.clamp(t, e) } }(), floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, dot: function (t) { return this.x * t.x + this.y * t.y }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, normalize: function () { return this.divideScalar(this.length()) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, r = this.y - t.y; return e * e + r * r }, setLength: function (t) { var e = this.length(); return 0 !== e && t !== e && this.multiplyScalar(t / e), this }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }, lerpVectors: function (t, e, r) { return this.subVectors(e, t).multiplyScalar(r).add(t), this }, equals: function (t) { return t.x === this.x && t.y === this.y }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t }, fromAttribute: function (t, e, r) { return void 0 === r && (r = 0), e = e * t.itemSize + r, this.x = t.array[e], this.y = t.array[e + 1], this }, clone: function () { return new THREE.Vector2(this.x, this.y) } }, THREE.Vector3 = function (t, e, r) { this.x = t || 0, this.y = e || 0, this.z = r || 0 }, THREE.Vector3.prototype = { constructor: THREE.Vector3, set: function (t, e, r) { return this.x = t, this.y = e, this.z = r, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) } }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, add: function (t, e) { return void 0 !== e ? (THREE.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, sub: function (t, e) { return void 0 !== e ? (THREE.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, multiply: function (t, e) { return void 0 !== e ? (THREE.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this }, multiplyVectors: function (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, applyEuler: function () { var t; return function (e) { return e instanceof THREE.Euler == !1 && THREE.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order."), void 0 === t && (t = new THREE.Quaternion), this.applyQuaternion(t.setFromEuler(e)), this } }(), applyAxisAngle: function () { var t; return function (e, r) { return void 0 === t && (t = new THREE.Quaternion), this.applyQuaternion(t.setFromAxisAngle(e, r)), this } }(), applyMatrix3: function (t) { var e = this.x, r = this.y, i = this.z, n = t.elements; return this.x = n[0] * e + n[3] * r + n[6] * i, this.y = n[1] * e + n[4] * r + n[7] * i, this.z = n[2] * e + n[5] * r + n[8] * i, this }, applyMatrix4: function (t) { var e = this.x, r = this.y, i = this.z, n = t.elements; return this.x = n[0] * e + n[4] * r + n[8] * i + n[12], this.y = n[1] * e + n[5] * r + n[9] * i + n[13], this.z = n[2] * e + n[6] * r + n[10] * i + n[14], this }, applyProjection: function (t) { var e = this.x, r = this.y, i = this.z, n = t.elements, a = 1 / (n[3] * e + n[7] * r + n[11] * i + n[15]); return this.x = (n[0] * e + n[4] * r + n[8] * i + n[12]) * a, this.y = (n[1] * e + n[5] * r + n[9] * i + n[13]) * a, this.z = (n[2] * e + n[6] * r + n[10] * i + n[14]) * a, this }, applyQuaternion: function (t) { var e = this.x, r = this.y, i = this.z, n = t.x, a = t.y, o = t.z, s = t.w, h = s * e + a * i - o * r, l = s * r + o * e - n * i, c = s * i + n * r - a * e, u = -n * e - a * r - o * i; return this.x = h * s + u * -n + l * -o - c * -a, this.y = l * s + u * -a + c * -n - h * -o, this.z = c * s + u * -o + h * -a - l * -n, this }, project: function () { var t; return function (e) { return void 0 === t && (t = new THREE.Matrix4), t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyProjection(t) } }(), unproject: function () { var t; return function (e) { return void 0 === t && (t = new THREE.Matrix4), t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyProjection(t) } }(), transformDirection: function (t) { var e = this.x, r = this.y, i = this.z, n = t.elements; return this.x = n[0] * e + n[4] * r + n[8] * i, this.y = n[1] * e + n[5] * r + n[9] * i, this.z = n[2] * e + n[6] * r + n[10] * i, this.normalize(), this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, divideScalar: function (t) { if (0 !== t) { var e = 1 / t; this.x *= e, this.y *= e, this.z *= e } else this.x = 0, this.y = 0, this.z = 0; return this }, min: function (t) { return this.x > t.x && (this.x = t.x), this.y > t.y && (this.y = t.y), this.z > t.z && (this.z = t.z), this }, max: function (t) { return this.x < t.x && (this.x = t.x), this.y < t.y && (this.y = t.y), this.z < t.z && (this.z = t.z), this }, clamp: function (t, e) { return this.x < t.x ? this.x = t.x : this.x > e.x && (this.x = e.x), this.y < t.y ? this.y = t.y : this.y > e.y && (this.y = e.y), this.z < t.z ? this.z = t.z : this.z > e.z && (this.z = e.z), this }, clampScalar: function () { var t, e; return function (r, i) { return void 0 === t && (t = new THREE.Vector3, e = new THREE.Vector3), t.set(r, r, r), e.set(i, i, i), this.clamp(t, e) } }(), floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length()) }, setLength: function (t) { var e = this.length(); return 0 !== e && t !== e && this.multiplyScalar(t / e), this }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, lerpVectors: function (t, e, r) { return this.subVectors(e, t).multiplyScalar(r).add(t), this }, cross: function (t, e) { if (void 0 !== e) return THREE.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e); var r = this.x, i = this.y, n = this.z; return this.x = i * t.z - n * t.y, this.y = n * t.x - r * t.z, this.z = r * t.y - i * t.x, this }, crossVectors: function (t, e) { var r = t.x, i = t.y, n = t.z, a = e.x, o = e.y, s = e.z; return this.x = i * s - n * o, this.y = n * a - r * s, this.z = r * o - i * a, this }, projectOnVector: function () { var t, e; return function (r) { return void 0 === t && (t = new THREE.Vector3), t.copy(r).normalize(), e = this.dot(t), this.copy(t).multiplyScalar(e) } }(), projectOnPlane: function () { var t; return function (e) { return void 0 === t && (t = new THREE.Vector3), t.copy(this).projectOnVector(e), this.sub(t) } }(), reflect: function () { var t; return function (e) { return void 0 === t && (t = new THREE.Vector3), this.sub(t.copy(e).multiplyScalar(2 * this.dot(e))) } }(), angleTo: function (t) { var e = this.dot(t) / (this.length() * t.length()); return Math.acos(THREE.Math.clamp(e, -1, 1)) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, r = this.y - t.y, i = this.z - t.z; return e * e + r * r + i * i }, setEulerFromRotationMatrix: function (t, e) { THREE.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function (t, e) { THREE.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (t) { return THREE.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, getScaleFromMatrix: function (t) { return THREE.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, getColumnFromMatrix: function (t, e) { return THREE.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, setFromMatrixPosition: function (t) { return this.x = t.elements[12], this.y = t.elements[13], this.z = t.elements[14], this }, setFromMatrixScale: function (t) { var e = this.set(t.elements[0], t.elements[1], t.elements[2]).length(), r = this.set(t.elements[4], t.elements[5], t.elements[6]).length(), i = this.set(t.elements[8], t.elements[9], t.elements[10]).length(); return this.x = e, this.y = r, this.z = i, this }, setFromMatrixColumn: function (t, e) { var r = 4 * t, i = e.elements; return this.x = i[r], this.y = i[r + 1], this.z = i[r + 2], this }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }, fromAttribute: function (t, e, r) { return void 0 === r && (r = 0), e = e * t.itemSize + r, this.x = t.array[e], this.y = t.array[e + 1], this.z = t.array[e + 2], this }, clone: function () { return new THREE.Vector3(this.x, this.y, this.z) } }, THREE.Vector4 = function (t, e, r, i) { this.x = t || 0, this.y = e || 0, this.z = r || 0, this.w = void 0 !== i ? i : 1 }, THREE.Vector4.prototype = { constructor: THREE.Vector4, set: function (t, e, r, i) { return this.x = t, this.y = e, this.z = r, this.w = i, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setW: function (t) { return this.w = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) } }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }, add: function (t, e) { return void 0 !== e ? (THREE.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }, sub: function (t, e) { return void 0 !== e ? (THREE.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }, applyMatrix4: function (t) { var e = this.x, r = this.y, i = this.z, n = this.w, a = t.elements; return this.x = a[0] * e + a[4] * r + a[8] * i + a[12] * n, this.y = a[1] * e + a[5] * r + a[9] * i + a[13] * n, this.z = a[2] * e + a[6] * r + a[10] * i + a[14] * n, this.w = a[3] * e + a[7] * r + a[11] * i + a[15] * n, this }, divideScalar: function (t) { if (0 !== t) { var e = 1 / t; this.x *= e, this.y *= e, this.z *= e, this.w *= e } else this.x = 0, this.y = 0, this.z = 0, this.w = 1; return this }, setAxisAngleFromQuaternion: function (t) { this.w = 2 * Math.acos(t.w); var e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }, setAxisAngleFromRotationMatrix: function (t) { var e, r, i, n, a = t.elements, o = a[0], s = a[4], h = a[8], l = a[1], c = a[5], u = a[9], E = a[2], p = a[6], f = a[10]; if (Math.abs(s - l) < .01 && Math.abs(h - E) < .01 && Math.abs(u - p) < .01) { if (Math.abs(s + l) < .1 && Math.abs(h + E) < .1 && Math.abs(u + p) < .1 && Math.abs(o + c + f - 3) < .1) return this.set(1, 0, 0, 0), this; e = Math.PI; var d = (o + 1) / 2, m = (c + 1) / 2, T = (f + 1) / 2, g = (s + l) / 4, v = (h + E) / 4, R = (u + p) / 4; return d > m && d > T ? d < .01 ? (r = 0, i = .707106781, n = .707106781) : (i = g / (r = Math.sqrt(d)), n = v / r) : m > T ? m < .01 ? (r = .707106781, i = 0, n = .707106781) : (r = g / (i = Math.sqrt(m)), n = R / i) : T < .01 ? (r = .707106781, i = .707106781, n = 0) : (r = v / (n = Math.sqrt(T)), i = R / n), this.set(r, i, n, e), this } var y = Math.sqrt((p - u) * (p - u) + (h - E) * (h - E) + (l - s) * (l - s)); return Math.abs(y) < .001 && (y = 1), this.x = (p - u) / y, this.y = (h - E) / y, this.z = (l - s) / y, this.w = Math.acos((o + c + f - 1) / 2), this }, min: function (t) { return this.x > t.x && (this.x = t.x), this.y > t.y && (this.y = t.y), this.z > t.z && (this.z = t.z), this.w > t.w && (this.w = t.w), this }, max: function (t) { return this.x < t.x && (this.x = t.x), this.y < t.y && (this.y = t.y), this.z < t.z && (this.z = t.z), this.w < t.w && (this.w = t.w), this }, clamp: function (t, e) { return this.x < t.x ? this.x = t.x : this.x > e.x && (this.x = e.x), this.y < t.y ? this.y = t.y : this.y > e.y && (this.y = e.y), this.z < t.z ? this.z = t.z : this.z > e.z && (this.z = e.z), this.w < t.w ? this.w = t.w : this.w > e.w && (this.w = e.w), this }, clampScalar: function () { var t, e; return function (r, i) { return void 0 === t && (t = new THREE.Vector4, e = new THREE.Vector4), t.set(r, r, r, r), e.set(i, i, i, i), this.clamp(t, e) } }(), floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length()) }, setLength: function (t) { var e = this.length(); return 0 !== e && t !== e && this.multiplyScalar(t / e), this }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }, lerpVectors: function (t, e, r) { return this.subVectors(e, t).multiplyScalar(r).add(t), this }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }, fromAttribute: function (t, e, r) { return void 0 === r && (r = 0), e = e * t.itemSize + r, this.x = t.array[e], this.y = t.array[e + 1], this.z = t.array[e + 2], this.w = t.array[e + 3], this }, clone: function () { return new THREE.Vector4(this.x, this.y, this.z, this.w) } }, THREE.Euler = function (t, e, r, i) { this._x = t || 0, this._y = e || 0, this._z = r || 0, this._order = i || THREE.Euler.DefaultOrder }, THREE.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], THREE.Euler.DefaultOrder = "XYZ", THREE.Euler.prototype = { constructor: THREE.Euler, _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder, get x() { return this._x }, set x(t) { this._x = t, this.onChangeCallback() }, get y() { return this._y }, set y(t) { this._y = t, this.onChangeCallback() }, get z() { return this._z }, set z(t) { this._z = t, this.onChangeCallback() }, get order() { return this._order }, set order(t) { this._order = t, this.onChangeCallback() }, set: function (t, e, r, i) { return this._x = t, this._y = e, this._z = r, this._order = i || this._order, this.onChangeCallback(), this }, copy: function (t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this }, setFromRotationMatrix: function (t, e, r) { var i = THREE.Math.clamp, n = t.elements, a = n[0], o = n[4], s = n[8], h = n[1], l = n[5], c = n[9], u = n[2], E = n[6], p = n[10]; return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-c, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(E, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(c, -1, 1)), Math.abs(c) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-u, a), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(E, -1, 1)), Math.abs(E) < .99999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === e ? (this._y = Math.asin(-i(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(E, p), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === e ? (this._z = Math.asin(i(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, a)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === e ? (this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(E, l), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-c, p), this._y = 0)) : THREE.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== r && this.onChangeCallback(), this }, setFromQuaternion: function () { var t; return function (e, r, i) { return void 0 === t && (t = new THREE.Matrix4), t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, r, i), this } }(), setFromVector3: function (t, e) { return this.set(t.x, t.y, t.z, e || this._order) }, reorder: function () { var t = new THREE.Quaternion; return function (e) { t.setFromEuler(this), this.setFromQuaternion(t, e) } }(), equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, fromArray: function (t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }, toVector3: function (t) { return t ? t.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z) }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () { }, clone: function () { return new THREE.Euler(this._x, this._y, this._z, this._order) } }, THREE.Line3 = function (t, e) { this.start = void 0 !== t ? t : new THREE.Vector3, this.end = void 0 !== e ? e : new THREE.Vector3 }, THREE.Line3.prototype = { constructor: THREE.Line3, set: function (t, e) { return this.start.copy(t), this.end.copy(e), this }, copy: function (t) { return this.start.copy(t.start), this.end.copy(t.end), this }, center: function (t) { return (t || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (t) { return (t || new THREE.Vector3).subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (t, e) { var r = e || new THREE.Vector3; return this.delta(r).multiplyScalar(t).add(this.start) }, closestPointToPointParameter: function () { var t = new THREE.Vector3, e = new THREE.Vector3; return function (r, i) { t.subVectors(r, this.start), e.subVectors(this.end, this.start); var n = e.dot(e), a = e.dot(t) / n; return i && (a = THREE.Math.clamp(a, 0, 1)), a } }(), closestPointToPoint: function (t, e, r) { var i = this.closestPointToPointParameter(t, e), n = r || new THREE.Vector3; return this.delta(n).multiplyScalar(i).add(this.start) }, applyMatrix4: function (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }, equals: function (t) { return t.start.equals(this.start) && t.end.equals(this.end) }, clone: function () { return (new THREE.Line3).copy(this) } }, THREE.Box2 = function (t, e) { this.min = void 0 !== t ? t : new THREE.Vector2(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new THREE.Vector2(-1 / 0, -1 / 0) }, THREE.Box2.prototype = { constructor: THREE.Box2, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, r = t.length; e < r; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function () { var t = new THREE.Vector2; return function (e, r) { var i = t.copy(r).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } }(), copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, empty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, center: function (t) { return (t || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5) }, size: function (t) { return (t || new THREE.Vector2).subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }, getParameter: function (t, e) { return (e || new THREE.Vector2).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }, isIntersectionBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }, clampPoint: function (t, e) { return (e || new THREE.Vector2).copy(t).clamp(this.min, this.max) }, distanceToPoint: function () { var t = new THREE.Vector2; return function (e) { return t.copy(e).clamp(this.min, this.max).sub(e).length() } }(), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) }, clone: function () { return (new THREE.Box2).copy(this) } }, THREE.Box3 = function (t, e) { this.min = void 0 !== t ? t : new THREE.Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0) }, THREE.Box3.prototype = { constructor: THREE.Box3, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, r = t.length; e < r; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function () { var t = new THREE.Vector3; return function (e, r) { var i = t.copy(r).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } }(), setFromObject: function () { var t = new THREE.Vector3; return function (e) { var r = this; return e.updateMatrixWorld(!0), this.makeEmpty(), e.traverse(function (e) { var i = e.geometry; if (void 0 !== i) if (i instanceof THREE.Geometry) for (var n = i.vertices, a = 0, o = n.length; a < o; a++)t.copy(n[a]), t.applyMatrix4(e.matrixWorld), r.expandByPoint(t); else if (i instanceof THREE.BufferGeometry && void 0 !== i.attributes.position) { var s = i.attributes.position.array; for (a = 0, o = s.length; a < o; a += 3)t.set(s[a], s[a + 1], s[a + 2]), t.applyMatrix4(e.matrixWorld), r.expandByPoint(t) } }), this } }(), copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, empty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, center: function (t) { return (t || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5) }, size: function (t) { return (t || new THREE.Vector3).subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }, getParameter: function (t, e) { return (e || new THREE.Vector3).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }, isIntersectionBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }, clampPoint: function (t, e) { return (e || new THREE.Vector3).copy(t).clamp(this.min, this.max) }, distanceToPoint: function () { var t = new THREE.Vector3; return function (e) { return t.copy(e).clamp(this.min, this.max).sub(e).length() } }(), getBoundingSphere: function () { var t = new THREE.Vector3; return function (e) { var r = e || new THREE.Sphere; return r.center = this.center(), r.radius = .5 * this.size(t).length(), r } }(), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, applyMatrix4: function () { var t = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3]; return function (e) { return t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.makeEmpty(), this.setFromPoints(t), this } }(), translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) }, clone: function () { return (new THREE.Box3).copy(this) } }, THREE.Matrix3 = function () { this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), arguments.length > 0 && THREE.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") }, THREE.Matrix3.prototype = { constructor: THREE.Matrix3, set: function (t, e, r, i, n, a, o, s, h) { var l = this.elements; return l[0] = t, l[3] = e, l[6] = r, l[1] = i, l[4] = n, l[7] = a, l[2] = o, l[5] = s, l[8] = h, this }, identity: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, copy: function (t) { var e = t.elements; return this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]), this }, multiplyVector3: function (t) { return THREE.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, multiplyVector3Array: function (t) { return THREE.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t) }, applyToVector3Array: function () { var t = new THREE.Vector3; return function (e, r, i) { void 0 === r && (r = 0), void 0 === i && (i = e.length); for (var n = 0, a = r; n < i; n += 3, a += 3)t.x = e[a], t.y = e[a + 1], t.z = e[a + 2], t.applyMatrix3(this), e[a] = t.x, e[a + 1] = t.y, e[a + 2] = t.z; return e } }(), multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }, determinant: function () { var t = this.elements, e = t[0], r = t[1], i = t[2], n = t[3], a = t[4], o = t[5], s = t[6], h = t[7], l = t[8]; return e * a * l - e * o * h - r * n * l + r * o * s + i * n * h - i * a * s }, getInverse: function (t, e) { var r = t.elements, i = this.elements; i[0] = r[10] * r[5] - r[6] * r[9], i[1] = -r[10] * r[1] + r[2] * r[9], i[2] = r[6] * r[1] - r[2] * r[5], i[3] = -r[10] * r[4] + r[6] * r[8], i[4] = r[10] * r[0] - r[2] * r[8], i[5] = -r[6] * r[0] + r[2] * r[4], i[6] = r[9] * r[4] - r[5] * r[8], i[7] = -r[9] * r[0] + r[1] * r[8], i[8] = r[5] * r[0] - r[1] * r[4]; var n = r[0] * i[0] + r[1] * i[3] + r[2] * i[6]; if (0 === n) { var a = "Matrix3.getInverse(): can't invert matrix, determinant is 0"; if (e) throw new Error(a); return THREE.warn(a), this.identity(), this } return this.multiplyScalar(1 / n), this }, transpose: function () { var t, e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }, flattenToArrayOffset: function (t, e) { var r = this.elements; return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t }, getNormalMatrix: function (t) { return this.getInverse(t).transpose(), this }, transposeIntoArray: function (t) { var e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }, fromArray: function (t) { return this.elements.set(t), this }, toArray: function () { var t = this.elements; return [t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]] }, clone: function () { return (new THREE.Matrix3).fromArray(this.elements) } }, THREE.Matrix4 = function () { this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), arguments.length > 0 && THREE.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") }, THREE.Matrix4.prototype = { constructor: THREE.Matrix4, set: function (t, e, r, i, n, a, o, s, h, l, c, u, E, p, f, d) { var m = this.elements; return m[0] = t, m[4] = e, m[8] = r, m[12] = i, m[1] = n, m[5] = a, m[9] = o, m[13] = s, m[2] = h, m[6] = l, m[10] = c, m[14] = u, m[3] = E, m[7] = p, m[11] = f, m[15] = d, this }, identity: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, copy: function (t) { return this.elements.set(t.elements), this }, extractPosition: function (t) { return THREE.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, copyPosition: function (t) { var e = this.elements, r = t.elements; return e[12] = r[12], e[13] = r[13], e[14] = r[14], this }, extractBasis: function (t, e, r) { var i = this.elements; return t.set(i[0], i[1], i[2]), e.set(i[4], i[5], i[6]), r.set(i[8], i[9], i[10]), this }, makeBasis: function (t, e, r) { return this.set(t.x, e.x, r.x, 0, t.y, e.y, r.y, 0, t.z, e.z, r.z, 0, 0, 0, 0, 1), this }, extractRotation: function () { var t = new THREE.Vector3; return function (e) { var r = this.elements, i = e.elements, n = 1 / t.set(i[0], i[1], i[2]).length(), a = 1 / t.set(i[4], i[5], i[6]).length(), o = 1 / t.set(i[8], i[9], i[10]).length(); return r[0] = i[0] * n, r[1] = i[1] * n, r[2] = i[2] * n, r[4] = i[4] * a, r[5] = i[5] * a, r[6] = i[6] * a, r[8] = i[8] * o, r[9] = i[9] * o, r[10] = i[10] * o, this } }(), makeRotationFromEuler: function (t) { t instanceof THREE.Euler == !1 && THREE.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var e = this.elements, r = t.x, i = t.y, n = t.z, a = Math.cos(r), o = Math.sin(r), s = Math.cos(i), h = Math.sin(i), l = Math.cos(n), c = Math.sin(n); if ("XYZ" === t.order) { var u = a * l, E = a * c, p = o * l, f = o * c; e[0] = s * l, e[4] = -s * c, e[8] = h, e[1] = E + p * h, e[5] = u - f * h, e[9] = -o * s, e[2] = f - u * h, e[6] = p + E * h, e[10] = a * s } else if ("YXZ" === t.order) { var d = s * l, m = s * c, T = h * l, g = h * c; e[0] = d + g * o, e[4] = T * o - m, e[8] = a * h, e[1] = a * c, e[5] = a * l, e[9] = -o, e[2] = m * o - T, e[6] = g + d * o, e[10] = a * s } else if ("ZXY" === t.order) { d = s * l, m = s * c, T = h * l, g = h * c; e[0] = d - g * o, e[4] = -a * c, e[8] = T + m * o, e[1] = m + T * o, e[5] = a * l, e[9] = g - d * o, e[2] = -a * h, e[6] = o, e[10] = a * s } else if ("ZYX" === t.order) { u = a * l, E = a * c, p = o * l, f = o * c; e[0] = s * l, e[4] = p * h - E, e[8] = u * h + f, e[1] = s * c, e[5] = f * h + u, e[9] = E * h - p, e[2] = -h, e[6] = o * s, e[10] = a * s } else if ("YZX" === t.order) { var v = a * s, R = a * h, y = o * s, H = o * h; e[0] = s * l, e[4] = H - v * c, e[8] = y * c + R, e[1] = c, e[5] = a * l, e[9] = -o * l, e[2] = -h * l, e[6] = R * c + y, e[10] = v - H * c } else if ("XZY" === t.order) { v = a * s, R = a * h, y = o * s, H = o * h; e[0] = s * l, e[4] = -c, e[8] = h * l, e[1] = v * c + H, e[5] = a * l, e[9] = R * c - y, e[2] = y * c - R, e[6] = o * l, e[10] = H * c + v } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, setRotationFromQuaternion: function (t) { return THREE.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, makeRotationFromQuaternion: function (t) { var e = this.elements, r = t.x, i = t.y, n = t.z, a = t.w, o = r + r, s = i + i, h = n + n, l = r * o, c = r * s, u = r * h, E = i * s, p = i * h, f = n * h, d = a * o, m = a * s, T = a * h; return e[0] = 1 - (E + f), e[4] = c - T, e[8] = u + m, e[1] = c + T, e[5] = 1 - (l + f), e[9] = p - d, e[2] = u - m, e[6] = p + d, e[10] = 1 - (l + E), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, lookAt: function () { var t = new THREE.Vector3, e = new THREE.Vector3, r = new THREE.Vector3; return function (i, n, a) { var o = this.elements; return r.subVectors(i, n).normalize(), 0 === r.length() && (r.z = 1), t.crossVectors(a, r).normalize(), 0 === t.length() && (r.x += 1e-4, t.crossVectors(a, r).normalize()), e.crossVectors(r, t), o[0] = t.x, o[4] = e.x, o[8] = r.x, o[1] = t.y, o[5] = e.y, o[9] = r.y, o[2] = t.z, o[6] = e.z, o[10] = r.z, this } }(), multiply: function (t, e) { return void 0 !== e ? (THREE.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }, multiplyMatrices: function (t, e) { var r = t.elements, i = e.elements, n = this.elements, a = r[0], o = r[4], s = r[8], h = r[12], l = r[1], c = r[5], u = r[9], E = r[13], p = r[2], f = r[6], d = r[10], m = r[14], T = r[3], g = r[7], v = r[11], R = r[15], y = i[0], H = i[4], x = i[8], b = i[12], _ = i[1], w = i[5], M = i[9], S = i[13], A = i[2], C = i[6], L = i[10], P = i[14], F = i[3], U = i[7], B = i[11], D = i[15]; return n[0] = a * y + o * _ + s * A + h * F, n[4] = a * H + o * w + s * C + h * U, n[8] = a * x + o * M + s * L + h * B, n[12] = a * b + o * S + s * P + h * D, n[1] = l * y + c * _ + u * A + E * F, n[5] = l * H + c * w + u * C + E * U, n[9] = l * x + c * M + u * L + E * B, n[13] = l * b + c * S + u * P + E * D, n[2] = p * y + f * _ + d * A + m * F, n[6] = p * H + f * w + d * C + m * U, n[10] = p * x + f * M + d * L + m * B, n[14] = p * b + f * S + d * P + m * D, n[3] = T * y + g * _ + v * A + R * F, n[7] = T * H + g * w + v * C + R * U, n[11] = T * x + g * M + v * L + R * B, n[15] = T * b + g * S + v * P + R * D, this }, multiplyToArray: function (t, e, r) { var i = this.elements; return this.multiplyMatrices(t, e), r[0] = i[0], r[1] = i[1], r[2] = i[2], r[3] = i[3], r[4] = i[4], r[5] = i[5], r[6] = i[6], r[7] = i[7], r[8] = i[8], r[9] = i[9], r[10] = i[10], r[11] = i[11], r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15], this }, multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }, multiplyVector3: function (t) { return THREE.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), t.applyProjection(this) }, multiplyVector4: function (t) { return THREE.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector3Array: function (t) { return THREE.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t) }, applyToVector3Array: function () { var t = new THREE.Vector3; return function (e, r, i) { void 0 === r && (r = 0), void 0 === i && (i = e.length); for (var n = 0, a = r; n < i; n += 3, a += 3)t.x = e[a], t.y = e[a + 1], t.z = e[a + 2], t.applyMatrix4(this), e[a] = t.x, e[a + 1] = t.y, e[a + 2] = t.z; return e } }(), rotateAxis: function (t) { THREE.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, crossVector: function (t) { return THREE.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, determinant: function () { var t = this.elements, e = t[0], r = t[4], i = t[8], n = t[12], a = t[1], o = t[5], s = t[9], h = t[13], l = t[2], c = t[6], u = t[10], E = t[14]; return t[3] * (+n * s * c - i * h * c - n * o * u + r * h * u + i * o * E - r * s * E) + t[7] * (+e * s * E - e * h * u + n * a * u - i * a * E + i * h * l - n * s * l) + t[11] * (+e * h * c - e * o * E - n * a * c + r * a * E + n * o * l - r * h * l) + t[15] * (-i * o * l - e * s * c + e * o * u + i * a * c - r * a * u + r * s * l) }, transpose: function () { var t, e = this.elements; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this }, flattenToArrayOffset: function (t, e) { var r = this.elements; return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t[e + 9] = r[9], t[e + 10] = r[10], t[e + 11] = r[11], t[e + 12] = r[12], t[e + 13] = r[13], t[e + 14] = r[14], t[e + 15] = r[15], t }, getPosition: function () { var t = new THREE.Vector3; return function () { THREE.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."); var e = this.elements; return t.set(e[12], e[13], e[14]) } }(), setPosition: function (t) { var e = this.elements; return e[12] = t.x, e[13] = t.y, e[14] = t.z, this }, getInverse: function (t, e) { var r = this.elements, i = t.elements, n = i[0], a = i[4], o = i[8], s = i[12], h = i[1], l = i[5], c = i[9], u = i[13], E = i[2], p = i[6], f = i[10], d = i[14], m = i[3], T = i[7], g = i[11], v = i[15]; r[0] = c * d * T - u * f * T + u * p * g - l * d * g - c * p * v + l * f * v, r[4] = s * f * T - o * d * T - s * p * g + a * d * g + o * p * v - a * f * v, r[8] = o * u * T - s * c * T + s * l * g - a * u * g - o * l * v + a * c * v, r[12] = s * c * p - o * u * p - s * l * f + a * u * f + o * l * d - a * c * d, r[1] = u * f * m - c * d * m - u * E * g + h * d * g + c * E * v - h * f * v, r[5] = o * d * m - s * f * m + s * E * g - n * d * g - o * E * v + n * f * v, r[9] = s * c * m - o * u * m - s * h * g + n * u * g + o * h * v - n * c * v, r[13] = o * u * E - s * c * E + s * h * f - n * u * f - o * h * d + n * c * d, r[2] = l * d * m - u * p * m + u * E * T - h * d * T - l * E * v + h * p * v, r[6] = s * p * m - a * d * m - s * E * T + n * d * T + a * E * v - n * p * v, r[10] = a * u * m - s * l * m + s * h * T - n * u * T - a * h * v + n * l * v, r[14] = s * l * E - a * u * E - s * h * p + n * u * p + a * h * d - n * l * d, r[3] = c * p * m - l * f * m - c * E * T + h * f * T + l * E * g - h * p * g, r[7] = a * f * m - o * p * m + o * E * T - n * f * T - a * E * g + n * p * g, r[11] = o * l * m - a * c * m - o * h * T + n * c * T + a * h * g - n * l * g, r[15] = a * c * E - o * l * E + o * h * p - n * c * p - a * h * f + n * l * f; var R = n * r[0] + h * r[4] + E * r[8] + m * r[12]; if (0 == R) { var y = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"; if (e) throw new Error(y); return THREE.warn(y), this.identity(), this } return this.multiplyScalar(1 / R), this }, translate: function (t) { THREE.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function (t) { THREE.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function (t) { THREE.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function (t) { THREE.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function (t, e) { THREE.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, scale: function (t) { var e = this.elements, r = t.x, i = t.y, n = t.z; return e[0] *= r, e[4] *= i, e[8] *= n, e[1] *= r, e[5] *= i, e[9] *= n, e[2] *= r, e[6] *= i, e[10] *= n, e[3] *= r, e[7] *= i, e[11] *= n, this }, getMaxScaleOnAxis: function () { var t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], r = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, Math.max(r, i))) }, makeTranslation: function (t, e, r) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, r, 0, 0, 0, 1), this }, makeRotationX: function (t) { var e = Math.cos(t), r = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -r, 0, 0, r, e, 0, 0, 0, 0, 1), this }, makeRotationY: function (t) { var e = Math.cos(t), r = Math.sin(t); return this.set(e, 0, r, 0, 0, 1, 0, 0, -r, 0, e, 0, 0, 0, 0, 1), this }, makeRotationZ: function (t) { var e = Math.cos(t), r = Math.sin(t); return this.set(e, -r, 0, 0, r, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function (t, e) { var r = Math.cos(e), i = Math.sin(e), n = 1 - r, a = t.x, o = t.y, s = t.z, h = n * a, l = n * o; return this.set(h * a + r, h * o - i * s, h * s + i * o, 0, h * o + i * s, l * o + r, l * s - i * a, 0, h * s - i * o, l * s + i * a, n * s * s + r, 0, 0, 0, 0, 1), this }, makeScale: function (t, e, r) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this }, compose: function (t, e, r) { return this.makeRotationFromQuaternion(e), this.scale(r), this.setPosition(t), this }, decompose: function () { var t = new THREE.Vector3, e = new THREE.Matrix4; return function (r, i, n) { var a = this.elements, o = t.set(a[0], a[1], a[2]).length(), s = t.set(a[4], a[5], a[6]).length(), h = t.set(a[8], a[9], a[10]).length(); this.determinant() < 0 && (o = -o), r.x = a[12], r.y = a[13], r.z = a[14], e.elements.set(this.elements); var l = 1 / o, c = 1 / s, u = 1 / h; return e.elements[0] *= l, e.elements[1] *= l, e.elements[2] *= l, e.elements[4] *= c, e.elements[5] *= c, e.elements[6] *= c, e.elements[8] *= u, e.elements[9] *= u, e.elements[10] *= u, i.setFromRotationMatrix(e), n.x = o, n.y = s, n.z = h, this } }(), makeFrustum: function (t, e, r, i, n, a) { var o = this.elements, s = 2 * n / (e - t), h = 2 * n / (i - r), l = (e + t) / (e - t), c = (i + r) / (i - r), u = -(a + n) / (a - n), E = -2 * a * n / (a - n); return o[0] = s, o[4] = 0, o[8] = l, o[12] = 0, o[1] = 0, o[5] = h, o[9] = c, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = E, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this }, makePerspective: function (t, e, r, i) { var n = r * Math.tan(THREE.Math.degToRad(.5 * t)), a = -n, o = a * e, s = n * e; return this.makeFrustum(o, s, a, n, r, i) }, makeOrthographic: function (t, e, r, i, n, a) { var o = this.elements, s = e - t, h = r - i, l = a - n, c = (e + t) / s, u = (r + i) / h, E = (a + n) / l; return o[0] = 2 / s, o[4] = 0, o[8] = 0, o[12] = -c, o[1] = 0, o[5] = 2 / h, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 / l, o[14] = -E, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this }, fromArray: function (t) { return this.elements.set(t), this }, toArray: function () { var t = this.elements; return [t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]] }, clone: function () { return (new THREE.Matrix4).fromArray(this.elements) } }, THREE.Ray = function (t, e) { this.origin = void 0 !== t ? t : new THREE.Vector3, this.direction = void 0 !== e ? e : new THREE.Vector3 }, THREE.Ray.prototype = { constructor: THREE.Ray, set: function (t, e) { return this.origin.copy(t), this.direction.copy(e), this }, copy: function (t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }, at: function (t, e) { return (e || new THREE.Vector3).copy(this.direction).multiplyScalar(t).add(this.origin) }, recast: function () { var t = new THREE.Vector3; return function (e) { return this.origin.copy(this.at(e, t)), this } }(), closestPointToPoint: function (t, e) { var r = e || new THREE.Vector3; r.subVectors(t, this.origin); var i = r.dot(this.direction); return i < 0 ? r.copy(this.origin) : r.copy(this.direction).multiplyScalar(i).add(this.origin) }, distanceToPoint: function () { var t = new THREE.Vector3; return function (e) { var r = t.subVectors(e, this.origin).dot(this.direction); return r < 0 ? this.origin.distanceTo(e) : (t.copy(this.direction).multiplyScalar(r).add(this.origin), t.distanceTo(e)) } }(), distanceSqToSegment: function () { var t = new THREE.Vector3, e = new THREE.Vector3, r = new THREE.Vector3; return function (i, n, a, o) { t.copy(i).add(n).multiplyScalar(.5), e.copy(n).sub(i).normalize(), r.copy(this.origin).sub(t); var s, h, l, c, u = .5 * i.distanceTo(n), E = -this.direction.dot(e), p = r.dot(this.direction), f = -r.dot(e), d = r.lengthSq(), m = Math.abs(1 - E * E); if (m > 0) if (h = E * p - f, c = u * m, (s = E * f - p) >= 0) if (h >= -c) if (h <= c) { var T = 1 / m; l = (s *= T) * (s + E * (h *= T) + 2 * p) + h * (E * s + h + 2 * f) + d } else h = u, l = -(s = Math.max(0, -(E * h + p))) * s + h * (h + 2 * f) + d; else h = -u, l = -(s = Math.max(0, -(E * h + p))) * s + h * (h + 2 * f) + d; else h <= -c ? l = -(s = Math.max(0, -(-E * u + p))) * s + (h = s > 0 ? -u : Math.min(Math.max(-u, -f), u)) * (h + 2 * f) + d : h <= c ? (s = 0, l = (h = Math.min(Math.max(-u, -f), u)) * (h + 2 * f) + d) : l = -(s = Math.max(0, -(E * u + p))) * s + (h = s > 0 ? u : Math.min(Math.max(-u, -f), u)) * (h + 2 * f) + d; else h = E > 0 ? -u : u, l = -(s = Math.max(0, -(E * h + p))) * s + h * (h + 2 * f) + d; return a && a.copy(this.direction).multiplyScalar(s).add(this.origin), o && o.copy(e).multiplyScalar(h).add(t), l } }(), isIntersectionSphere: function (t) { return this.distanceToPoint(t.center) <= t.radius }, intersectSphere: function () { var t = new THREE.Vector3; return function (e, r) { t.subVectors(e.center, this.origin); var i = t.dot(this.direction), n = t.dot(t) - i * i, a = e.radius * e.radius; if (n > a) return null; var o = Math.sqrt(a - n), s = i - o, h = i + o; return s < 0 && h < 0 ? null : s < 0 ? this.at(h, r) : this.at(s, r) } }(), isIntersectionPlane: function (t) { var e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }, distanceToPlane: function (t) { var e = t.normal.dot(this.direction); if (0 == e) return 0 == t.distanceToPoint(this.origin) ? 0 : null; var r = -(this.origin.dot(t.normal) + t.constant) / e; return r >= 0 ? r : null }, intersectPlane: function (t, e) { var r = this.distanceToPlane(t); return null === r ? null : this.at(r, e) }, isIntersectionBox: function () { var t = new THREE.Vector3; return function (e) { return null !== this.intersectBox(e, t) } }(), intersectBox: function (t, e) { var r, i, n, a, o, s, h = 1 / this.direction.x, l = 1 / this.direction.y, c = 1 / this.direction.z, u = this.origin; return h >= 0 ? (r = (t.min.x - u.x) * h, i = (t.max.x - u.x) * h) : (r = (t.max.x - u.x) * h, i = (t.min.x - u.x) * h), l >= 0 ? (n = (t.min.y - u.y) * l, a = (t.max.y - u.y) * l) : (n = (t.max.y - u.y) * l, a = (t.min.y - u.y) * l), r > a || n > i ? null : ((n > r || r != r) && (r = n), (a < i || i != i) && (i = a), c >= 0 ? (o = (t.min.z - u.z) * c, s = (t.max.z - u.z) * c) : (o = (t.max.z - u.z) * c, s = (t.min.z - u.z) * c), r > s || o > i ? null : ((o > r || r != r) && (r = o), (s < i || i != i) && (i = s), i < 0 ? null : this.at(r >= 0 ? r : i, e))) }, intersectTriangle: function () { var t = new THREE.Vector3, e = new THREE.Vector3, r = new THREE.Vector3, i = new THREE.Vector3; return function (n, a, o, s, h) { e.subVectors(a, n), r.subVectors(o, n), i.crossVectors(e, r); var l, c = this.direction.dot(i); if (c > 0) { if (s) return null; l = 1 } else { if (!(c < 0)) return null; l = -1, c = -c } t.subVectors(this.origin, n); var u = l * this.direction.dot(r.crossVectors(t, r)); if (u < 0) return null; var E = l * this.direction.dot(e.cross(t)); if (E < 0) return null; if (u + E > c) return null; var p = -l * t.dot(i); return p < 0 ? null : this.at(p / c, h) } }(), applyMatrix4: function (t) { return this.direction.add(this.origin).applyMatrix4(t), this.origin.applyMatrix4(t), this.direction.sub(this.origin), this.direction.normalize(), this }, equals: function (t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) }, clone: function () { return (new THREE.Ray).copy(this) } }, THREE.Sphere = function (t, e) { this.center = void 0 !== t ? t : new THREE.Vector3, this.radius = void 0 !== e ? e : 0 }, THREE.Sphere.prototype = { constructor: THREE.Sphere, set: function (t, e) { return this.center.copy(t), this.radius = e, this }, setFromPoints: function () { var t = new THREE.Box3; return function (e, r) { var i = this.center; void 0 !== r ? i.copy(r) : t.setFromPoints(e).center(i); for (var n = 0, a = 0, o = e.length; a < o; a++)n = Math.max(n, i.distanceToSquared(e[a])); return this.radius = Math.sqrt(n), this } }(), copy: function (t) { return this.center.copy(t.center), this.radius = t.radius, this }, empty: function () { return this.radius <= 0 }, containsPoint: function (t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (t) { return t.distanceTo(this.center) - this.radius }, intersectsSphere: function (t) { var e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }, clampPoint: function (t, e) { var r = this.center.distanceToSquared(t), i = e || new THREE.Vector3; return i.copy(t), r > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i }, getBoundingBox: function (t) { var e = t || new THREE.Box3; return e.set(this.center, this.center), e.expandByScalar(this.radius), e }, applyMatrix4: function (t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }, translate: function (t) { return this.center.add(t), this }, equals: function (t) { return t.center.equals(this.center) && t.radius === this.radius }, clone: function () { return (new THREE.Sphere).copy(this) } }, THREE.Frustum = function (t, e, r, i, n, a) { this.planes = [void 0 !== t ? t : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== r ? r : new THREE.Plane, void 0 !== i ? i : new THREE.Plane, void 0 !== n ? n : new THREE.Plane, void 0 !== a ? a : new THREE.Plane] }, THREE.Frustum.prototype = { constructor: THREE.Frustum, set: function (t, e, r, i, n, a) { var o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(r), o[3].copy(i), o[4].copy(n), o[5].copy(a), this }, copy: function (t) { for (var e = this.planes, r = 0; r < 6; r++)e[r].copy(t.planes[r]); return this }, setFromMatrix: function (t) { var e = this.planes, r = t.elements, i = r[0], n = r[1], a = r[2], o = r[3], s = r[4], h = r[5], l = r[6], c = r[7], u = r[8], E = r[9], p = r[10], f = r[11], d = r[12], m = r[13], T = r[14], g = r[15]; return e[0].setComponents(o - i, c - s, f - u, g - d).normalize(), e[1].setComponents(o + i, c + s, f + u, g + d).normalize(), e[2].setComponents(o + n, c + h, f + E, g + m).normalize(), e[3].setComponents(o - n, c - h, f - E, g - m).normalize(), e[4].setComponents(o - a, c - l, f - p, g - T).normalize(), e[5].setComponents(o + a, c + l, f + p, g + T).normalize(), this }, intersectsObject: function () { var t = new THREE.Sphere; return function (e) { var r = e.geometry; return null === r.boundingSphere && r.computeBoundingSphere(), t.copy(r.boundingSphere), t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t) } }(), intersectsSphere: function (t) { for (var e = this.planes, r = t.center, i = -t.radius, n = 0; n < 6; n++) { if (e[n].distanceToPoint(r) < i) return !1 } return !0 }, intersectsBox: function () { var t = new THREE.Vector3, e = new THREE.Vector3; return function (r) { for (var i = this.planes, n = 0; n < 6; n++) { var a = i[n]; t.x = a.normal.x > 0 ? r.min.x : r.max.x, e.x = a.normal.x > 0 ? r.max.x : r.min.x, t.y = a.normal.y > 0 ? r.min.y : r.max.y, e.y = a.normal.y > 0 ? r.max.y : r.min.y, t.z = a.normal.z > 0 ? r.min.z : r.max.z, e.z = a.normal.z > 0 ? r.max.z : r.min.z; var o = a.distanceToPoint(t), s = a.distanceToPoint(e); if (o < 0 && s < 0) return !1 } return !0 } }(), containsPoint: function (t) { for (var e = this.planes, r = 0; r < 6; r++)if (e[r].distanceToPoint(t) < 0) return !1; return !0 }, clone: function () { return (new THREE.Frustum).copy(this) } }, THREE.Plane = function (t, e) { this.normal = void 0 !== t ? t : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== e ? e : 0 }, THREE.Plane.prototype = { constructor: THREE.Plane, set: function (t, e) { return this.normal.copy(t), this.constant = e, this }, setComponents: function (t, e, r, i) { return this.normal.set(t, e, r), this.constant = i, this }, setFromNormalAndCoplanarPoint: function (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, setFromCoplanarPoints: function () { var t = new THREE.Vector3, e = new THREE.Vector3; return function (r, i, n) { var a = t.subVectors(n, i).cross(e.subVectors(r, i)).normalize(); return this.setFromNormalAndCoplanarPoint(a, r), this } }(), copy: function (t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, normalize: function () { var t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (t) { return this.normal.dot(t) + this.constant }, distanceToSphere: function (t) { return this.distanceToPoint(t.center) - t.radius }, projectPoint: function (t, e) { return this.orthoPoint(t, e).sub(t).negate() }, orthoPoint: function (t, e) { var r = this.distanceToPoint(t); return (e || new THREE.Vector3).copy(this.normal).multiplyScalar(r) }, isIntersectionLine: function (t) { var e = this.distanceToPoint(t.start), r = this.distanceToPoint(t.end); return e < 0 && r > 0 || r < 0 && e > 0 }, intersectLine: function () { var t = new THREE.Vector3; return function (e, r) { var i = r || new THREE.Vector3, n = e.delta(t), a = this.normal.dot(n); if (0 == a) return 0 == this.distanceToPoint(e.start) ? i.copy(e.start) : void 0; var o = -(e.start.dot(this.normal) + this.constant) / a; return o < 0 || o > 1 ? void 0 : i.copy(n).multiplyScalar(o).add(e.start) } }(), coplanarPoint: function (t) { return (t || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function () { var t = new THREE.Vector3, e = new THREE.Vector3, r = new THREE.Matrix3; return function (i, n) { var a = n || r.getNormalMatrix(i), o = t.copy(this.normal).applyMatrix3(a), s = this.coplanarPoint(e); return s.applyMatrix4(i), this.setFromNormalAndCoplanarPoint(o, s), this } }(), translate: function (t) { return this.constant = this.constant - t.dot(this.normal), this }, equals: function (t) { return t.normal.equals(this.normal) && t.constant == this.constant }, clone: function () { return (new THREE.Plane).copy(this) } }, THREE.Math = { generateUUID: function () { var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), r = new Array(36), i = 0; return function () { for (var n = 0; n < 36; n++)8 == n || 13 == n || 18 == n || 23 == n ? r[n] = "-" : 14 == n ? r[n] = "4" : (i <= 2 && (i = 33554432 + 16777216 * Math.random() | 0), t = 15 & i, i >>= 4, r[n] = e[19 == n ? 3 & t | 8 : t]); return r.join("") } }(), clamp: function (t, e, r) { return t < e ? e : t > r ? r : t }, clampBottom: function (t, e) { return t < e ? e : t }, mapLinear: function (t, e, r, i, n) { return i + (t - e) * (n - i) / (r - e) }, smoothstep: function (t, e, r) { return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, r) { return t <= e ? 0 : t >= r ? 1 : (t = (t - e) / (r - e)) * t * t * (t * (6 * t - 15) + 10) }, random16: function () { return (65280 * Math.random() + 255 * Math.random()) / 65535 }, randInt: function (t, e) { return Math.floor(this.randFloat(t, e)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, degToRad: function () { var t = Math.PI / 180; return function (e) { return e * t } }(), radToDeg: function () { var t = 180 / Math.PI; return function (e) { return e * t } }(), isPowerOfTwo: function (t) { return 0 == (t & t - 1) && 0 !== t }, nextPowerOfTwo: function (t) { return t-- , t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t } }, THREE.Spline = function (t) { this.points = t; var e, r, i, n, a, o, s, h, l, c = [], u = { x: 0, y: 0, z: 0 }; function E(t, e, r, i, n, a, o) { var s = .5 * (r - t), h = .5 * (i - e); return (2 * (e - r) + s + h) * o + (-3 * (e - r) - 2 * s - h) * a + s * n + e } this.initFromArray = function (t) { this.points = []; for (var e = 0; e < t.length; e++)this.points[e] = { x: t[e][0], y: t[e][1], z: t[e][2] } }, this.getPoint = function (t) { return e = (this.points.length - 1) * t, r = Math.floor(e), i = e - r, c[0] = 0 === r ? r : r - 1, c[1] = r, c[2] = r > this.points.length - 2 ? this.points.length - 1 : r + 1, c[3] = r > this.points.length - 3 ? this.points.length - 1 : r + 2, o = this.points[c[0]], s = this.points[c[1]], h = this.points[c[2]], l = this.points[c[3]], a = i * (n = i * i), u.x = E(o.x, s.x, h.x, l.x, i, n, a), u.y = E(o.y, s.y, h.y, l.y, i, n, a), u.z = E(o.z, s.z, h.z, l.z, i, n, a), u }, this.getControlPointsArray = function () { var t, e, r = this.points.length, i = []; for (t = 0; t < r; t++)e = this.points[t], i[t] = [e.x, e.y, e.z]; return i }, this.getLength = function (t) { var e, r, i, n, a = 0, o = 0, s = 0, h = new THREE.Vector3, l = new THREE.Vector3, c = [], u = 0; for (c[0] = 0, t || (t = 100), i = this.points.length * t, h.copy(this.points[0]), e = 1; e < i; e++)r = e / i, n = this.getPoint(r), l.copy(n), u += l.distanceTo(h), h.copy(n), a = (this.points.length - 1) * r, (o = Math.floor(a)) != s && (c[o] = u, s = o); return c[c.length] = u, { chunks: c, total: u } }, this.reparametrizeByArcLength = function (t) { var e, r, i, n, a, o, s, h, l = [], c = new THREE.Vector3, u = this.getLength(); for (l.push(c.copy(this.points[0]).clone()), e = 1; e < this.points.length; e++) { for (o = u.chunks[e] - u.chunks[e - 1], s = Math.ceil(t * o / u.total), n = (e - 1) / (this.points.length - 1), a = e / (this.points.length - 1), r = 1; r < s - 1; r++)i = n + r * (1 / s) * (a - n), h = this.getPoint(i), l.push(c.copy(h).clone()); l.push(c.copy(this.points[e]).clone()) } this.points = l } }, THREE.Triangle = function (t, e, r) { this.a = void 0 !== t ? t : new THREE.Vector3, this.b = void 0 !== e ? e : new THREE.Vector3, this.c = void 0 !== r ? r : new THREE.Vector3 }, THREE.Triangle.normal = function () { var t = new THREE.Vector3; return function (e, r, i, n) { var a = n || new THREE.Vector3; a.subVectors(i, r), t.subVectors(e, r), a.cross(t); var o = a.lengthSq(); return o > 0 ? a.multiplyScalar(1 / Math.sqrt(o)) : a.set(0, 0, 0) } }(), THREE.Triangle.barycoordFromPoint = function () { var t = new THREE.Vector3, e = new THREE.Vector3, r = new THREE.Vector3; return function (i, n, a, o, s) { t.subVectors(o, n), e.subVectors(a, n), r.subVectors(i, n); var h = t.dot(t), l = t.dot(e), c = t.dot(r), u = e.dot(e), E = e.dot(r), p = h * u - l * l, f = s || new THREE.Vector3; if (0 == p) return f.set(-2, -1, -1); var d = 1 / p, m = (u * c - l * E) * d, T = (h * E - l * c) * d; return f.set(1 - m - T, T, m) } }(), THREE.Triangle.containsPoint = function () { var t = new THREE.Vector3; return function (e, r, i, n) { var a = THREE.Triangle.barycoordFromPoint(e, r, i, n, t); return a.x >= 0 && a.y >= 0 && a.x + a.y <= 1 } }(), THREE.Triangle.prototype = { constructor: THREE.Triangle, set: function (t, e, r) { return this.a.copy(t), this.b.copy(e), this.c.copy(r), this }, setFromPointsAndIndices: function (t, e, r, i) { return this.a.copy(t[e]), this.b.copy(t[r]), this.c.copy(t[i]), this }, copy: function (t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }, area: function () { var t = new THREE.Vector3, e = new THREE.Vector3; return function () { return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length() } }(), midpoint: function (t) { return (t || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, normal: function (t) { return THREE.Triangle.normal(this.a, this.b, this.c, t) }, plane: function (t) { return (t || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c) }, barycoordFromPoint: function (t, e) { return THREE.Triangle.barycoordFromPoint(t, this.a, this.b, this.c, e) }, containsPoint: function (t) { return THREE.Triangle.containsPoint(t, this.a, this.b, this.c) }, equals: function (t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) }, clone: function () { return (new THREE.Triangle).copy(this) } }, THREE.Clock = function (t) { this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 }, THREE.Clock.prototype = { constructor: THREE.Clock, start: function () { this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), this.oldTime = this.startTime, this.running = !0 }, stop: function () { this.getElapsedTime(), this.running = !1 }, getElapsedTime: function () { return this.getDelta(), this.elapsedTime }, getDelta: function () { var t = 0; if (this.autoStart && !this.running && this.start(), this.running) { var e = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(); t = .001 * (e - this.oldTime), this.oldTime = e, this.elapsedTime += t } return t } }, THREE.EventDispatcher = function () { }, THREE.EventDispatcher.prototype = { constructor: THREE.EventDispatcher, apply: function (t) { t.addEventListener = THREE.EventDispatcher.prototype.addEventListener, t.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, t.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, t.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent }, addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); var r = this._listeners; void 0 === r[t] && (r[t] = []), -1 === r[t].indexOf(e) && r[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; var r = this._listeners; return void 0 !== r[t] && -1 !== r[t].indexOf(e) }, removeEventListener: function (t, e) { if (void 0 !== this._listeners) { var r = this._listeners[t]; if (void 0 !== r) { var i = r.indexOf(e); -1 !== i && r.splice(i, 1) } } }, dispatchEvent: function (t) { if (void 0 !== this._listeners) { var e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; for (var r = [], i = e.length, n = 0; n < i; n++)r[n] = e[n]; for (n = 0; n < i; n++)r[n].call(this, t) } } } }, function (t) { t.Raycaster = function (e, r, i, n) { this.ray = new t.Ray(e, r), this.near = i || 0, this.far = n || 1 / 0, this.params = { Sprite: {}, Mesh: {}, PointCloud: { threshold: 1 }, LOD: {}, Line: {} } }; var e = function (t, e) { return t.distance - e.distance }, r = function (t, e, i, n) { if (t.raycast(e, i), !0 === n) for (var a = t.children, o = 0, s = a.length; o < s; o++)r(a[o], e, i, !0) }; t.Raycaster.prototype = { constructor: t.Raycaster, precision: 1e-4, linePrecision: 1, set: function (t, e) { this.ray.set(t, e) }, setFromCamera: function (e, r) { r instanceof t.PerspectiveCamera ? (this.ray.origin.copy(r.position), this.ray.direction.set(e.x, e.y, .5).unproject(r).sub(r.position).normalize()) : r instanceof t.OrthographicCamera ? (this.ray.origin.set(e.x, e.y, -1).unproject(r), this.ray.direction.set(0, 0, -1).transformDirection(r.matrixWorld)) : t.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (t, i) { var n = []; return r(t, this, n, i), n.sort(e), n }, intersectObjects: function (i, n) { var a = []; if (i instanceof Array == !1) return t.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), a; for (var o = 0, s = i.length; o < s; o++)r(i[o], this, a, n); return a.sort(e), a } } }(THREE), THREE.Object3D = function () { Object.defineProperty(this, "id", { value: THREE.Object3DIdCount++ }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = void 0, this.children = [], this.up = THREE.Object3D.DefaultUp.clone(); var t = new THREE.Vector3, e = new THREE.Euler, r = new THREE.Quaternion, i = new THREE.Vector3(1, 1, 1); e.onChange(function () { r.setFromEuler(e, !1) }), r.onChange(function () { e.setFromQuaternion(r, void 0, !1) }), Object.defineProperties(this, { position: { enumerable: !0, value: t }, rotation: { enumerable: !0, value: e }, quaternion: { enumerable: !0, value: r }, scale: { enumerable: !0, value: i } }), this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.matrixWorld = new THREE.Matrix4, this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !1, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} }, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.prototype = { constructor: THREE.Object3D, get eulerOrder() { return THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order }, set eulerOrder(t) { THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order = t }, get useQuaternion() { THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set useQuaternion(t) { THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, applyMatrix: function (t) { this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale) }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: function () { var t = new THREE.Quaternion; return function (e, r) { return t.setFromAxisAngle(e, r), this.quaternion.multiply(t), this } }(), rotateX: function () { var t = new THREE.Vector3(1, 0, 0); return function (e) { return this.rotateOnAxis(t, e) } }(), rotateY: function () { var t = new THREE.Vector3(0, 1, 0); return function (e) { return this.rotateOnAxis(t, e) } }(), rotateZ: function () { var t = new THREE.Vector3(0, 0, 1); return function (e) { return this.rotateOnAxis(t, e) } }(), translateOnAxis: function () { var t = new THREE.Vector3; return function (e, r) { return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(r)), this } }(), translate: function (t, e) { return THREE.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, translateX: function () { var t = new THREE.Vector3(1, 0, 0); return function (e) { return this.translateOnAxis(t, e) } }(), translateY: function () { var t = new THREE.Vector3(0, 1, 0); return function (e) { return this.translateOnAxis(t, e) } }(), translateZ: function () { var t = new THREE.Vector3(0, 0, 1); return function (e) { return this.translateOnAxis(t, e) } }(), localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: function () { var t = new THREE.Matrix4; return function (e) { return e.applyMatrix4(t.getInverse(this.matrixWorld)) } }(), lookAt: function () { var t = new THREE.Matrix4; return function (e) { t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t) } }(), add: function (t) { if (arguments.length > 1) { for (var e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return t === this ? (THREE.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t instanceof THREE.Object3D ? (void 0 !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({ type: "added" }), this.children.push(t)) : THREE.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }, remove: function (t) { if (arguments.length > 1) for (var e = 0; e < arguments.length; e++)this.remove(arguments[e]); var r = this.children.indexOf(t); -1 !== r && (t.parent = void 0, t.dispatchEvent({ type: "removed" }), this.children.splice(r, 1)) }, getChildByName: function (t) { return THREE.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, getObjectById: function (t) { return this.getObjectByProperty("id", t) }, getObjectByName: function (t) { return this.getObjectByProperty("name", t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (var r = 0, i = this.children.length; r < i; r++) { var n = this.children[r].getObjectByProperty(t, e); if (void 0 !== n) return n } }, getWorldPosition: function (t) { var e = t || new THREE.Vector3; return this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function () { var t = new THREE.Vector3, e = new THREE.Vector3; return function (r) { var i = r || new THREE.Quaternion; return this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i } }(), getWorldRotation: function () { var t = new THREE.Quaternion; return function (e) { var r = e || new THREE.Euler; return this.getWorldQuaternion(t), r.setFromQuaternion(t, this.rotation.order, !1) } }(), getWorldScale: function () { var t = new THREE.Vector3, e = new THREE.Quaternion; return function (r) { var i = r || new THREE.Vector3; return this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i } }(), getWorldDirection: function () { var t = new THREE.Quaternion; return function (e) { var r = e || new THREE.Vector3; return this.getWorldQuaternion(t), r.set(0, 0, 1).applyQuaternion(t) } }(), raycast: function () { }, traverse: function (t) { t(this); for (var e = 0, r = this.children.length; e < r; e++)this.children[e].traverse(t) }, traverseVisible: function (t) { if (!1 !== this.visible) { t(this); for (var e = 0, r = this.children.length; e < r; e++)this.children[e].traverseVisible(t) } }, traverseAncestors: function (t) { this.parent && (t(this.parent), this.parent.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { !0 === this.matrixAutoUpdate && this.updateMatrix(), !0 !== this.matrixWorldNeedsUpdate && !0 !== t || (void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); for (var e = 0, r = this.children.length; e < r; e++)this.children[e].updateMatrixWorld(t) }, toJSON: function () { var t = { metadata: { version: 4.3, type: "Object", generator: "ObjectExporter" } }, e = {}, r = {}, i = function (e) { if (void 0 === t.materials && (t.materials = []), void 0 === r[e.uuid]) { var i = e.toJSON(); delete i.metadata, r[e.uuid] = i, t.materials.push(i) } return e.uuid }, n = function (r) { var a = {}; if (a.uuid = r.uuid, a.type = r.type, "" !== r.name && (a.name = r.name), "{}" !== JSON.stringify(r.userData) && (a.userData = r.userData), !0 !== r.visible && (a.visible = r.visible), r instanceof THREE.PerspectiveCamera ? (a.fov = r.fov, a.aspect = r.aspect, a.near = r.near, a.far = r.far) : r instanceof THREE.OrthographicCamera ? (a.left = r.left, a.right = r.right, a.top = r.top, a.bottom = r.bottom, a.near = r.near, a.far = r.far) : r instanceof THREE.AmbientLight ? a.color = r.color.getHex() : r instanceof THREE.DirectionalLight ? (a.color = r.color.getHex(), a.intensity = r.intensity) : r instanceof THREE.PointLight ? (a.color = r.color.getHex(), a.intensity = r.intensity, a.distance = r.distance, a.decay = r.decay) : r instanceof THREE.SpotLight ? (a.color = r.color.getHex(), a.intensity = r.intensity, a.distance = r.distance, a.angle = r.angle, a.exponent = r.exponent, a.decay = r.decay) : r instanceof THREE.HemisphereLight ? (a.color = r.color.getHex(), a.groundColor = r.groundColor.getHex()) : r instanceof THREE.Mesh || r instanceof THREE.Line || r instanceof THREE.PointCloud ? (a.geometry = function (r) { if (void 0 === t.geometries && (t.geometries = []), void 0 === e[r.uuid]) { var i = r.toJSON(); delete i.metadata, e[r.uuid] = i, t.geometries.push(i) } return r.uuid }(r.geometry), a.material = i(r.material), r instanceof THREE.Line && (a.mode = r.mode)) : r instanceof THREE.Sprite && (a.material = i(r.material)), a.matrix = r.matrix.toArray(), r.children.length > 0) { a.children = []; for (var o = 0; o < r.children.length; o++)a.children.push(n(r.children[o])) } return a }; return t.object = n(this), t }, clone: function (t, e) { if (void 0 === t && (t = new THREE.Object3D), void 0 === e && (e = !0), t.name = this.name, t.up.copy(this.up), t.position.copy(this.position), t.quaternion.copy(this.quaternion), t.scale.copy(this.scale), t.rotationAutoUpdate = this.rotationAutoUpdate, t.matrix.copy(this.matrix), t.matrixWorld.copy(this.matrixWorld), t.matrixAutoUpdate = this.matrixAutoUpdate, t.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, t.visible = this.visible, t.castShadow = this.castShadow, t.receiveShadow = this.receiveShadow, t.frustumCulled = this.frustumCulled, t.userData = JSON.parse(JSON.stringify(this.userData)), !0 === e) for (var r = 0; r < this.children.length; r++) { var i = this.children[r]; t.add(i.clone()) } return t } }, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, THREE.Face3 = function (t, e, r, i, n, a) { this.a = t, this.b = e, this.c = r, this.normal = i instanceof THREE.Vector3 ? i : new THREE.Vector3, this.vertexNormals = i instanceof Array ? i : [], this.color = n instanceof THREE.Color ? n : new THREE.Color, this.vertexColors = n instanceof Array ? n : [], this.vertexTangents = [], this.materialIndex = void 0 !== a ? a : 0 }, THREE.Face3.prototype = { constructor: THREE.Face3, clone: function () { var t = new THREE.Face3(this.a, this.b, this.c); t.normal.copy(this.normal), t.color.copy(this.color), t.materialIndex = this.materialIndex; for (var e = 0, r = this.vertexNormals.length; e < r; e++)t.vertexNormals[e] = this.vertexNormals[e].clone(); for (e = 0, r = this.vertexColors.length; e < r; e++)t.vertexColors[e] = this.vertexColors[e].clone(); for (e = 0, r = this.vertexTangents.length; e < r; e++)t.vertexTangents[e] = this.vertexTangents[e].clone(); return t } }, THREE.Face4 = function (t, e, r, i, n, a, o) { return THREE.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(t, e, r, n, a, o) }, THREE.BufferAttribute = function (t, e) { this.array = t, this.itemSize = e, this.needsUpdate = !1 }, THREE.BufferAttribute.prototype = { constructor: THREE.BufferAttribute, get length() { return this.array.length }, copyAt: function (t, e, r) { t *= this.itemSize, r *= e.itemSize; for (var i = 0, n = this.itemSize; i < n; i++)this.array[t + i] = e.array[r + i]; return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, setXY: function (t, e, r) { return t *= this.itemSize, this.array[t] = e, this.array[t + 1] = r, this }, setXYZ: function (t, e, r, i) { return t *= this.itemSize, this.array[t] = e, this.array[t + 1] = r, this.array[t + 2] = i, this }, setXYZW: function (t, e, r, i, n) { return t *= this.itemSize, this.array[t] = e, this.array[t + 1] = r, this.array[t + 2] = i, this.array[t + 3] = n, this }, clone: function () { return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize) } }, THREE.Int8Attribute = function (t, e) { return THREE.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e) }, THREE.Uint8Attribute = function (t, e) { return THREE.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e) }, THREE.Uint8ClampedAttribute = function (t, e) { return THREE.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e) }, THREE.Int16Attribute = function (t, e) { return THREE.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e) }, THREE.Uint16Attribute = function (t, e) { return THREE.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e) }, THREE.Int32Attribute = function (t, e) { return THREE.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e) }, THREE.Uint32Attribute = function (t, e) { return THREE.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e) }, THREE.Float32Attribute = function (t, e) { return THREE.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e) }, THREE.Float64Attribute = function (t, e) { return THREE.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(t, e) }, THREE.DynamicBufferAttribute = function (t, e) { THREE.BufferAttribute.call(this, t, e), this.updateRange = { offset: 0, count: -1 } }, THREE.DynamicBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype), THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute, THREE.DynamicBufferAttribute.prototype.clone = function () { return new THREE.DynamicBufferAttribute(new this.array.constructor(this.array), this.itemSize) }, THREE.BufferGeometry = function () { Object.defineProperty(this, "id", { value: THREE.GeometryIdCount++ }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", this.attributes = {}, this.attributesKeys = [], this.drawcalls = [], this.offsets = this.drawcalls, this.boundingBox = null, this.boundingSphere = null }, THREE.BufferGeometry.prototype = { constructor: THREE.BufferGeometry, addAttribute: function (t, e) { if (e instanceof THREE.BufferAttribute == !1) return THREE.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void (this.attributes[t] = { array: arguments[1], itemSize: arguments[2] }); this.attributes[t] = e, this.attributesKeys = Object.keys(this.attributes) }, getAttribute: function (t) { return this.attributes[t] }, addDrawCall: function (t, e, r) { this.drawcalls.push({ start: t, count: e, index: void 0 !== r ? r : 0 }) }, applyMatrix: function (t) { var e = this.attributes.position; void 0 !== e && (t.applyToVector3Array(e.array), e.needsUpdate = !0); var r = this.attributes.normal; void 0 !== r && ((new THREE.Matrix3).getNormalMatrix(t).applyToVector3Array(r.array), r.needsUpdate = !0); null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere() }, center: function () { this.computeBoundingBox(); var t = this.boundingBox.center().negate(); return this.applyMatrix((new THREE.Matrix4).setPosition(t)), t }, fromGeometry: function (t, e) { e = e || { vertexColors: THREE.NoColors }; var r = t.vertices, i = t.faces, n = t.faceVertexUvs, a = e.vertexColors, o = n[0].length > 0, s = 3 == i[0].vertexNormals.length, h = new Float32Array(3 * i.length * 3); this.addAttribute("position", new THREE.BufferAttribute(h, 3)); var l = new Float32Array(3 * i.length * 3); if (this.addAttribute("normal", new THREE.BufferAttribute(l, 3)), a !== THREE.NoColors) { var c = new Float32Array(3 * i.length * 3); this.addAttribute("color", new THREE.BufferAttribute(c, 3)) } if (!0 === o) { var u = new Float32Array(3 * i.length * 2); this.addAttribute("uv", new THREE.BufferAttribute(u, 2)) } for (var E = 0, p = 0, f = 0; E < i.length; E++ , p += 6, f += 9) { var d = i[E], m = r[d.a], T = r[d.b], g = r[d.c]; if (h[f] = m.x, h[f + 1] = m.y, h[f + 2] = m.z, h[f + 3] = T.x, h[f + 4] = T.y, h[f + 5] = T.z, h[f + 6] = g.x, h[f + 7] = g.y, h[f + 8] = g.z, !0 === s) { var v = d.vertexNormals[0], R = d.vertexNormals[1], y = d.vertexNormals[2]; l[f] = v.x, l[f + 1] = v.y, l[f + 2] = v.z, l[f + 3] = R.x, l[f + 4] = R.y, l[f + 5] = R.z, l[f + 6] = y.x, l[f + 7] = y.y, l[f + 8] = y.z } else { var H = d.normal; l[f] = H.x, l[f + 1] = H.y, l[f + 2] = H.z, l[f + 3] = H.x, l[f + 4] = H.y, l[f + 5] = H.z, l[f + 6] = H.x, l[f + 7] = H.y, l[f + 8] = H.z } if (a === THREE.FaceColors) { var x = d.color; c[f] = x.r, c[f + 1] = x.g, c[f + 2] = x.b, c[f + 3] = x.r, c[f + 4] = x.g, c[f + 5] = x.b, c[f + 6] = x.r, c[f + 7] = x.g, c[f + 8] = x.b } else if (a === THREE.VertexColors) { var b = d.vertexColors[0], _ = d.vertexColors[1], w = d.vertexColors[2]; c[f] = b.r, c[f + 1] = b.g, c[f + 2] = b.b, c[f + 3] = _.r, c[f + 4] = _.g, c[f + 5] = _.b, c[f + 6] = w.r, c[f + 7] = w.g, c[f + 8] = w.b } if (!0 === o) { var M = n[0][E][0], S = n[0][E][1], A = n[0][E][2]; u[p] = M.x, u[p + 1] = M.y, u[p + 2] = S.x, u[p + 3] = S.y, u[p + 4] = A.x, u[p + 5] = A.y } } return this.computeBoundingSphere(), this }, computeBoundingBox: function () { var t = new THREE.Vector3; return function () { null === this.boundingBox && (this.boundingBox = new THREE.Box3); var e = this.attributes.position.array; if (e) { var r = this.boundingBox; r.makeEmpty(); for (var i = 0, n = e.length; i < n; i += 3)t.set(e[i], e[i + 1], e[i + 2]), r.expandByPoint(t) } void 0 !== e && 0 !== e.length || (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && THREE.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.') } }(), computeBoundingSphere: function () { var t = new THREE.Box3, e = new THREE.Vector3; return function () { null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere); var r = this.attributes.position.array; if (r) { t.makeEmpty(); for (var i = this.boundingSphere.center, n = 0, a = r.length; n < a; n += 3)e.set(r[n], r[n + 1], r[n + 2]), t.expandByPoint(e); t.center(i); var o = 0; for (n = 0, a = r.length; n < a; n += 3)e.set(r[n], r[n + 1], r[n + 2]), o = Math.max(o, i.distanceToSquared(e)); this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.') } } }(), computeFaceNormals: function () { }, computeVertexNormals: function () { var t = this.attributes; if (t.position) { var e = t.position.array; if (void 0 === t.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(e.length), 3)); else for (var r = 0, i = (s = t.normal.array).length; r < i; r++)s[r] = 0; var n, a, o, s = t.normal.array, h = new THREE.Vector3, l = new THREE.Vector3, c = new THREE.Vector3, u = new THREE.Vector3, E = new THREE.Vector3; if (t.index) for (var p = t.index.array, f = this.offsets.length > 0 ? this.offsets : [{ start: 0, count: p.length, index: 0 }], d = 0, m = f.length; d < m; ++d) { var T = f[d].start, g = f[d].count, v = f[d].index; for (r = T, i = T + g; r < i; r += 3)n = 3 * (v + p[r]), a = 3 * (v + p[r + 1]), o = 3 * (v + p[r + 2]), h.fromArray(e, n), l.fromArray(e, a), c.fromArray(e, o), u.subVectors(c, l), E.subVectors(h, l), u.cross(E), s[n] += u.x, s[n + 1] += u.y, s[n + 2] += u.z, s[a] += u.x, s[a + 1] += u.y, s[a + 2] += u.z, s[o] += u.x, s[o + 1] += u.y, s[o + 2] += u.z } else for (r = 0, i = e.length; r < i; r += 9)h.fromArray(e, r), l.fromArray(e, r + 3), c.fromArray(e, r + 6), u.subVectors(c, l), E.subVectors(h, l), u.cross(E), s[r] = u.x, s[r + 1] = u.y, s[r + 2] = u.z, s[r + 3] = u.x, s[r + 4] = u.y, s[r + 5] = u.z, s[r + 6] = u.x, s[r + 7] = u.y, s[r + 8] = u.z; this.normalizeNormals(), t.normal.needsUpdate = !0 } }, computeTangents: function () { if (void 0 !== this.attributes.index && void 0 !== this.attributes.position && void 0 !== this.attributes.normal && void 0 !== this.attributes.uv) { var t = this.attributes.index.array, e = this.attributes.position.array, r = this.attributes.normal.array, i = this.attributes.uv.array, n = e.length / 3; void 0 === this.attributes.tangent && this.addAttribute("tangent", new THREE.BufferAttribute(new Float32Array(4 * n), 4)); for (var a = this.attributes.tangent.array, o = [], s = [], h = 0; h < n; h++)o[h] = new THREE.Vector3, s[h] = new THREE.Vector3; var l, c, u, E, p, f, d, m, T, g, v, R, y, H, x, b, _, w, M = new THREE.Vector3, S = new THREE.Vector3, A = new THREE.Vector3, C = new THREE.Vector2, L = new THREE.Vector2, P = new THREE.Vector2, F = new THREE.Vector3, U = new THREE.Vector3; 0 === this.drawcalls.length && this.addDrawCall(0, t.length, 0); var B, D, V, z = this.drawcalls; for (H = 0, x = z.length; H < x; ++H) { var k = z[H].start, N = z[H].count, O = z[H].index; for (R = k, y = k + N; R < y; R += 3)b = O + t[R], _ = O + t[R + 1], w = O + t[R + 2], B = b, D = _, V = w, M.fromArray(e, 3 * B), S.fromArray(e, 3 * D), A.fromArray(e, 3 * V), C.fromArray(i, 2 * B), L.fromArray(i, 2 * D), P.fromArray(i, 2 * V), l = S.x - M.x, c = A.x - M.x, u = S.y - M.y, E = A.y - M.y, p = S.z - M.z, f = A.z - M.z, d = L.x - C.x, m = P.x - C.x, T = L.y - C.y, g = P.y - C.y, v = 1 / (d * g - m * T), F.set((g * l - T * c) * v, (g * u - T * E) * v, (g * p - T * f) * v), U.set((d * c - m * l) * v, (d * E - m * u) * v, (d * f - m * p) * v), o[B].add(F), o[D].add(F), o[V].add(F), s[B].add(U), s[D].add(U), s[V].add(U) } var G, I, W, j = new THREE.Vector3, X = new THREE.Vector3, q = new THREE.Vector3, Y = new THREE.Vector3; for (H = 0, x = z.length; H < x; ++H) { k = z[H].start, N = z[H].count, O = z[H].index; for (R = k, y = k + N; R < y; R += 3)b = O + t[R], _ = O + t[R + 1], w = O + t[R + 2], K(b), K(_), K(w) } } else THREE.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()"); function K(t) { q.fromArray(r, 3 * t), Y.copy(q), I = o[t], j.copy(I), j.sub(q.multiplyScalar(q.dot(I))).normalize(), X.crossVectors(Y, I), W = X.dot(s[t]), G = W < 0 ? -1 : 1, a[4 * t] = j.x, a[4 * t + 1] = j.y, a[4 * t + 2] = j.z, a[4 * t + 3] = G } }, computeOffsets: function (t) { void 0 === t && (t = 65535); for (var e = this.attributes.index.array, r = this.attributes.position.array, i = e.length / 3, n = new Uint16Array(e.length), a = 0, o = 0, s = [{ start: 0, count: 0, index: 0 }], h = s[0], l = 0, c = new Int32Array(6), u = new Int32Array(r.length), E = new Int32Array(r.length), p = 0; p < r.length; p++)u[p] = -1, E[p] = -1; for (var f = 0; f < i; f++) { l = 0; for (var d = 0; d < 3; d++) { -1 == u[v = e[3 * f + d]] ? (c[2 * d] = v, c[2 * d + 1] = -1, l++) : u[v] < h.index ? (c[2 * d] = v, c[2 * d + 1] = -1, 0) : (c[2 * d] = v, c[2 * d + 1] = u[v]) } if (o + l > h.index + t) { var m = { start: a, count: 0, index: o }; s.push(m), h = m; for (var T = 0; T < 6; T += 2) { (g = c[T + 1]) > -1 && g < h.index && (c[T + 1] = -1) } } for (T = 0; T < 6; T += 2) { var g, v = c[T]; -1 === (g = c[T + 1]) && (g = o++), u[v] = g, E[g] = v, n[a++] = g - h.index, h.count++ } } return this.reorderBuffers(n, E, o), this.offsets = s, this.drawcalls = s, s }, merge: function (t, e) { if (t instanceof THREE.BufferGeometry != !1) { void 0 === e && (e = 0); var r = this.attributes; for (var i in r) if (void 0 !== t.attributes[i]) for (var n = r[i].array, a = t.attributes[i], o = a.array, s = 0, h = a.itemSize * e; s < o.length; s++ , h++)n[h] = o[s]; return this } THREE.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t) }, normalizeNormals: function () { for (var t, e, r, i, n = this.attributes.normal.array, a = 0, o = n.length; a < o; a += 3)t = n[a], e = n[a + 1], r = n[a + 2], i = 1 / Math.sqrt(t * t + e * e + r * r), n[a] *= i, n[a + 1] *= i, n[a + 2] *= i }, reorderBuffers: function (t, e, r) { var i = {}; for (var n in this.attributes) if ("index" != n) { var a = this.attributes[n].array; i[n] = new a.constructor(this.attributes[n].itemSize * r) } for (var o = 0; o < r; o++) { var s = e[o]; for (var n in this.attributes) if ("index" != n) for (var h = this.attributes[n].array, l = this.attributes[n].itemSize, c = i[n], u = 0; u < l; u++)c[o * l + u] = h[s * l + u] } for (var n in this.attributes.index.array = t, this.attributes) "index" != n && (this.attributes[n].array = i[n], this.attributes[n].numItems = this.attributes[n].itemSize * r) }, toJSON: function () { var t = { metadata: { version: 4, type: "BufferGeometry", generator: "BufferGeometryExporter" }, uuid: this.uuid, type: this.type, data: { attributes: {} } }, e = this.attributes, r = this.offsets, i = this.boundingSphere; for (var n in e) { var a = e[n], o = Array.prototype.slice.call(a.array); t.data.attributes[n] = { itemSize: a.itemSize, type: a.array.constructor.name, array: o } } return r.length > 0 && (t.data.offsets = JSON.parse(JSON.stringify(r))), null !== i && (t.data.boundingSphere = { center: i.center.toArray(), radius: i.radius }), t }, clone: function () { var t = new THREE.BufferGeometry; for (var e in this.attributes) { var r = this.attributes[e]; t.addAttribute(e, r.clone()) } for (var i = 0, n = this.offsets.length; i < n; i++) { var a = this.offsets[i]; t.offsets.push({ start: a.start, index: a.index, count: a.count }) } return t }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.Geometry = function () { Object.defineProperty(this, "id", { value: THREE.GeometryIdCount++ }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.hasTangents = !1, this.dynamic = !0, this.verticesNeedUpdate = !1, this.elementsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.tangentsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 }, THREE.Geometry.prototype = { constructor: THREE.Geometry, applyMatrix: function (t) { for (var e = (new THREE.Matrix3).getNormalMatrix(t), r = 0, i = this.vertices.length; r < i; r++) { this.vertices[r].applyMatrix4(t) } for (r = 0, i = this.faces.length; r < i; r++) { var n = this.faces[r]; n.normal.applyMatrix3(e).normalize(); for (var a = 0, o = n.vertexNormals.length; a < o; a++)n.vertexNormals[a].applyMatrix3(e).normalize() } null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0 }, fromBufferGeometry: function (t) { for (var e = this, r = t.attributes, i = r.position.array, n = void 0 !== r.index ? r.index.array : void 0, a = void 0 !== r.normal ? r.normal.array : void 0, o = void 0 !== r.color ? r.color.array : void 0, s = void 0 !== r.uv ? r.uv.array : void 0, h = [], l = [], c = 0, u = 0; c < i.length; c += 3, u += 2)e.vertices.push(new THREE.Vector3(i[c], i[c + 1], i[c + 2])), void 0 !== a && h.push(new THREE.Vector3(a[c], a[c + 1], a[c + 2])), void 0 !== o && e.colors.push(new THREE.Color(o[c], o[c + 1], o[c + 2])), void 0 !== s && l.push(new THREE.Vector2(s[u], s[u + 1])); var E = function (t, r, i) { var n = void 0 !== a ? [h[t].clone(), h[r].clone(), h[i].clone()] : [], c = void 0 !== o ? [e.colors[t].clone(), e.colors[r].clone(), e.colors[i].clone()] : []; e.faces.push(new THREE.Face3(t, r, i, n, c)), void 0 !== s && e.faceVertexUvs[0].push([l[t].clone(), l[r].clone(), l[i].clone()]) }; if (void 0 !== n) { var p = t.drawcalls; if (p.length > 0) for (c = 0; c < p.length; c++)for (var f = p[c], d = f.start, m = f.count, T = f.index, g = (u = d, d + m); u < g; u += 3)E(T + n[u], T + n[u + 1], T + n[u + 2]); else for (c = 0; c < n.length; c += 3)E(n[c], n[c + 1], n[c + 2]) } else for (c = 0; c < i.length / 3; c += 3)E(c, c + 1, c + 2); return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this }, center: function () { this.computeBoundingBox(); var t = this.boundingBox.center().negate(); return this.applyMatrix((new THREE.Matrix4).setPosition(t)), t }, computeFaceNormals: function () { for (var t = new THREE.Vector3, e = new THREE.Vector3, r = 0, i = this.faces.length; r < i; r++) { var n = this.faces[r], a = this.vertices[n.a], o = this.vertices[n.b], s = this.vertices[n.c]; t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), n.normal.copy(t) } }, computeVertexNormals: function (t) { var e, r, i, n, a, o; for (o = new Array(this.vertices.length), e = 0, r = this.vertices.length; e < r; e++)o[e] = new THREE.Vector3; if (t) { var s, h, l, c = new THREE.Vector3, u = new THREE.Vector3; for (i = 0, n = this.faces.length; i < n; i++)a = this.faces[i], s = this.vertices[a.a], h = this.vertices[a.b], l = this.vertices[a.c], c.subVectors(l, h), u.subVectors(s, h), c.cross(u), o[a.a].add(c), o[a.b].add(c), o[a.c].add(c) } else for (i = 0, n = this.faces.length; i < n; i++)o[(a = this.faces[i]).a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal); for (e = 0, r = this.vertices.length; e < r; e++)o[e].normalize(); for (i = 0, n = this.faces.length; i < n; i++)(a = this.faces[i]).vertexNormals[0] = o[a.a].clone(), a.vertexNormals[1] = o[a.b].clone(), a.vertexNormals[2] = o[a.c].clone() }, computeMorphNormals: function () { var t, e, r, i, n; for (r = 0, i = this.faces.length; r < i; r++)for ((n = this.faces[r]).__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []), t = 0, e = n.vertexNormals.length; t < e; t++)n.__originalVertexNormals[t] ? n.__originalVertexNormals[t].copy(n.vertexNormals[t]) : n.__originalVertexNormals[t] = n.vertexNormals[t].clone(); var a = new THREE.Geometry; for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) { if (!this.morphNormals[t]) { this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = []; var o = this.morphNormals[t].faceNormals, s = this.morphNormals[t].vertexNormals; for (r = 0, i = this.faces.length; r < i; r++)h = new THREE.Vector3, l = { a: new THREE.Vector3, b: new THREE.Vector3, c: new THREE.Vector3 }, o.push(h), s.push(l) } var h, l, c = this.morphNormals[t]; for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals(), r = 0, i = this.faces.length; r < i; r++)n = this.faces[r], h = c.faceNormals[r], l = c.vertexNormals[r], h.copy(n.normal), l.a.copy(n.vertexNormals[0]), l.b.copy(n.vertexNormals[1]), l.c.copy(n.vertexNormals[2]) } for (r = 0, i = this.faces.length; r < i; r++)(n = this.faces[r]).normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals }, computeTangents: function () { var t, e, r, i, n, a, o, s, h, l, c, u, E, p, f, d, m, T, g, v, R, y, H, x, b, _, w, M, S, A, C, L, P, F, U = [], B = [], D = new THREE.Vector3, V = new THREE.Vector3, z = new THREE.Vector3, k = new THREE.Vector3, N = new THREE.Vector3; for (r = 0, i = this.vertices.length; r < i; r++)U[r] = new THREE.Vector3, B[r] = new THREE.Vector3; for (t = 0, e = this.faces.length; t < e; t++)o = this.faces[t], s = this.faceVertexUvs[0][t], M = this, S = o.a, A = o.b, C = o.c, L = 0, P = 1, F = 2, h = M.vertices[S], l = M.vertices[A], c = M.vertices[C], u = s[L], E = s[P], p = s[F], f = l.x - h.x, d = c.x - h.x, m = l.y - h.y, T = c.y - h.y, g = l.z - h.z, v = c.z - h.z, R = E.x - u.x, y = p.x - u.x, H = E.y - u.y, x = p.y - u.y, b = 1 / (R * x - y * H), D.set((x * f - H * d) * b, (x * m - H * T) * b, (x * g - H * v) * b), V.set((R * d - y * f) * b, (R * T - y * m) * b, (R * v - y * g) * b), U[S].add(D), U[A].add(D), U[C].add(D), B[S].add(V), B[A].add(V), B[C].add(V); var O = ["a", "b", "c", "d"]; for (t = 0, e = this.faces.length; t < e; t++)for (o = this.faces[t], n = 0; n < Math.min(o.vertexNormals.length, 3); n++)N.copy(o.vertexNormals[n]), a = o[O[n]], _ = U[a], z.copy(_), z.sub(N.multiplyScalar(N.dot(_))).normalize(), k.crossVectors(o.vertexNormals[n], _), w = k.dot(B[a]) < 0 ? -1 : 1, o.vertexTangents[n] = new THREE.Vector4(z.x, z.y, z.z, w); this.hasTangents = !0 }, computeLineDistances: function () { for (var t = 0, e = this.vertices, r = 0, i = e.length; r < i; r++)r > 0 && (t += e[r].distanceTo(e[r - 1])), this.lineDistances[r] = t }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new THREE.Box3), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (t, e, r) { if (t instanceof THREE.Geometry != !1) { var i, n = this.vertices.length, a = this.vertices, o = t.vertices, s = this.faces, h = t.faces, l = this.faceVertexUvs[0], c = t.faceVertexUvs[0]; void 0 === r && (r = 0), void 0 !== e && (i = (new THREE.Matrix3).getNormalMatrix(e)); for (var u = 0, E = o.length; u < E; u++) { var p = o[u].clone(); void 0 !== e && p.applyMatrix4(e), a.push(p) } for (u = 0, E = h.length; u < E; u++) { var f, d, m, T = h[u], g = T.vertexNormals, v = T.vertexColors; (f = new THREE.Face3(T.a + n, T.b + n, T.c + n)).normal.copy(T.normal), void 0 !== i && f.normal.applyMatrix3(i).normalize(); for (var R = 0, y = g.length; R < y; R++)d = g[R].clone(), void 0 !== i && d.applyMatrix3(i).normalize(), f.vertexNormals.push(d); f.color.copy(T.color); for (R = 0, y = v.length; R < y; R++)m = v[R], f.vertexColors.push(m.clone()); f.materialIndex = T.materialIndex + r, s.push(f) } for (u = 0, E = c.length; u < E; u++) { var H = c[u], x = []; if (void 0 !== H) { for (R = 0, y = H.length; R < y; R++)x.push(H[R].clone()); l.push(x) } } } else THREE.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t) }, mergeMesh: function (t) { t instanceof THREE.Mesh != !1 ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : THREE.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) }, mergeVertices: function () { var t, e, r, i, n, a, o, s, h = {}, l = [], c = [], u = Math.pow(10, 4); for (r = 0, i = this.vertices.length; r < i; r++)t = this.vertices[r], void 0 === h[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (h[e] = r, l.push(this.vertices[r]), c[r] = l.length - 1) : c[r] = c[h[e]]; var E = []; for (r = 0, i = this.faces.length; r < i; r++) { (n = this.faces[r]).a = c[n.a], n.b = c[n.b], n.c = c[n.c], a = [n.a, n.b, n.c]; for (var p = 0; p < 3; p++)if (a[p] == a[(p + 1) % 3]) { p, E.push(r); break } } for (r = E.length - 1; r >= 0; r--) { var f = E[r]; for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++)this.faceVertexUvs[o].splice(f, 1) } var d = this.vertices.length - l.length; return this.vertices = l, d }, toJSON: function () { var t = { metadata: { version: 4, type: "BufferGeometry", generator: "BufferGeometryExporter" }, uuid: this.uuid, type: this.type }; if ("" !== this.name && (t.name = this.name), void 0 !== this.parameters) { var e = this.parameters; for (var r in e) void 0 !== e[r] && (t[r] = e[r]); return t } for (var i = [], n = 0; n < this.vertices.length; n++) { var a = this.vertices[n]; i.push(a.x, a.y, a.z) } var o = [], s = [], h = {}, l = [], c = {}, u = [], E = {}; for (n = 0; n < this.faces.length; n++) { var p = this.faces[n], f = void 0 !== this.faceVertexUvs[0][n], d = p.normal.length() > 0, m = p.vertexNormals.length > 0, T = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b, g = p.vertexColors.length > 0, v = 0; if (v = x(v = x(v = x(v = x(v = x(v = x(v = x(v = x(v, 0, 0), 1, !1), 2, !1), 3, f), 4, d), 5, m), 6, T), 7, g), o.push(v), o.push(p.a, p.b, p.c), f) { var R = this.faceVertexUvs[0][n]; o.push(w(R[0]), w(R[1]), w(R[2])) } if (d && o.push(b(p.normal)), m) { var y = p.vertexNormals; o.push(b(y[0]), b(y[1]), b(y[2])) } if (T && o.push(_(p.color)), g) { var H = p.vertexColors; o.push(_(H[0]), _(H[1]), _(H[2])) } } function x(t, e, r) { return r ? t | 1 << e : t & ~(1 << e) } function b(t) { var e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== h[e] ? h[e] : (h[e] = s.length / 3, s.push(t.x, t.y, t.z), h[e]) } function _(t) { var e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== c[e] ? c[e] : (c[e] = l.length, l.push(t.getHex()), c[e]) } function w(t) { var e = t.x.toString() + t.y.toString(); return void 0 !== E[e] ? E[e] : (E[e] = u.length / 2, u.push(t.x, t.y), E[e]) } return t.data = {}, t.data.vertices = i, t.data.normals = s, l.length > 0 && (t.data.colors = l), u.length > 0 && (t.data.uvs = [u]), t.data.faces = o, t }, clone: function () { for (var t = new THREE.Geometry, e = this.vertices, r = 0, i = e.length; r < i; r++)t.vertices.push(e[r].clone()); var n = this.faces; for (r = 0, i = n.length; r < i; r++)t.faces.push(n[r].clone()); for (r = 0, i = this.faceVertexUvs.length; r < i; r++) { var a = this.faceVertexUvs[r]; void 0 === t.faceVertexUvs[r] && (t.faceVertexUvs[r] = []); for (var o = 0, s = a.length; o < s; o++) { for (var h = a[o], l = [], c = 0, u = h.length; c < u; c++) { var E = h[c]; l.push(E.clone()) } t.faceVertexUvs[r].push(l) } } return t }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, THREE.Camera = function () { THREE.Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new THREE.Matrix4, this.projectionMatrix = new THREE.Matrix4 }, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.constructor = THREE.Camera, THREE.Camera.prototype.getWorldDirection = function () { var t = new THREE.Quaternion; return function (e) { var r = e || new THREE.Vector3; return this.getWorldQuaternion(t), r.set(0, 0, -1).applyQuaternion(t) } }(), THREE.Camera.prototype.lookAt = function () { var t = new THREE.Matrix4; return function (e) { t.lookAt(this.position, e, this.up), this.quaternion.setFromRotationMatrix(t) } }(), THREE.Camera.prototype.clone = function (t) { return void 0 === t && (t = new THREE.Camera), THREE.Object3D.prototype.clone.call(this, t), t.matrixWorldInverse.copy(this.matrixWorldInverse), t.projectionMatrix.copy(this.projectionMatrix), t }, THREE.CubeCamera = function (t, e, r) { THREE.Object3D.call(this), this.type = "CubeCamera"; var i = new THREE.PerspectiveCamera(90, 1, t, e); i.up.set(0, -1, 0), i.lookAt(new THREE.Vector3(1, 0, 0)), this.add(i); var n = new THREE.PerspectiveCamera(90, 1, t, e); n.up.set(0, -1, 0), n.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(n); var a = new THREE.PerspectiveCamera(90, 1, t, e); a.up.set(0, 0, 1), a.lookAt(new THREE.Vector3(0, 1, 0)), this.add(a); var o = new THREE.PerspectiveCamera(90, 1, t, e); o.up.set(0, 0, -1), o.lookAt(new THREE.Vector3(0, -1, 0)), this.add(o); var s = new THREE.PerspectiveCamera(90, 1, t, e); s.up.set(0, -1, 0), s.lookAt(new THREE.Vector3(0, 0, 1)), this.add(s); var h = new THREE.PerspectiveCamera(90, 1, t, e); h.up.set(0, -1, 0), h.lookAt(new THREE.Vector3(0, 0, -1)), this.add(h), this.renderTarget = new THREE.WebGLRenderTargetCube(r, r, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter }), this.updateCubeMap = function (t, e) { var r = this.renderTarget, l = r.generateMipmaps; r.generateMipmaps = !1, r.activeCubeFace = 0, t.render(e, i, r), r.activeCubeFace = 1, t.render(e, n, r), r.activeCubeFace = 2, t.render(e, a, r), r.activeCubeFace = 3, t.render(e, o, r), r.activeCubeFace = 4, t.render(e, s, r), r.generateMipmaps = l, r.activeCubeFace = 5, t.render(e, h, r) } }, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.CubeCamera.prototype.constructor = THREE.CubeCamera, THREE.OrthographicCamera = function (t, e, r, i, n, a) { THREE.Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.left = t, this.right = e, this.top = r, this.bottom = i, this.near = void 0 !== n ? n : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix() }, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera, THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () { var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; this.projectionMatrix.makeOrthographic(r - t, r + t, i + e, i - e, this.near, this.far) }, THREE.OrthographicCamera.prototype.clone = function () { var t = new THREE.OrthographicCamera; return THREE.Camera.prototype.clone.call(this, t), t.zoom = this.zoom, t.left = this.left, t.right = this.right, t.top = this.top, t.bottom = this.bottom, t.near = this.near, t.far = this.far, t.projectionMatrix.copy(this.projectionMatrix), t }, THREE.PerspectiveCamera = function (t, e, r, i) { THREE.Camera.call(this), this.type = "PerspectiveCamera", this.zoom = 1, this.fov = void 0 !== t ? t : 50, this.aspect = void 0 !== e ? e : 1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== i ? i : 2e3, this.updateProjectionMatrix() }, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera, THREE.PerspectiveCamera.prototype.setLens = function (t, e) { void 0 === e && (e = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(e / (2 * t))), this.updateProjectionMatrix() }, THREE.PerspectiveCamera.prototype.setViewOffset = function (t, e, r, i, n, a) { this.fullWidth = t, this.fullHeight = e, this.x = r, this.y = i, this.width = n, this.height = a, this.updateProjectionMatrix() }, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () { var t = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom)); if (this.fullWidth) { var e = this.fullWidth / this.fullHeight, r = Math.tan(THREE.Math.degToRad(.5 * t)) * this.near, i = -r, n = e * i, a = e * r, o = Math.abs(a - n), s = Math.abs(r - i); this.projectionMatrix.makeFrustum(n + this.x * o / this.fullWidth, n + (this.x + this.width) * o / this.fullWidth, r - (this.y + this.height) * s / this.fullHeight, r - this.y * s / this.fullHeight, this.near, this.far) } else this.projectionMatrix.makePerspective(t, this.aspect, this.near, this.far) }, THREE.PerspectiveCamera.prototype.clone = function () { var t = new THREE.PerspectiveCamera; return THREE.Camera.prototype.clone.call(this, t), t.zoom = this.zoom, t.fov = this.fov, t.aspect = this.aspect, t.near = this.near, t.far = this.far, t.projectionMatrix.copy(this.projectionMatrix), t }, THREE.Light = function (t) { THREE.Object3D.call(this), this.type = "Light", this.color = new THREE.Color(t) }, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.constructor = THREE.Light, THREE.Light.prototype.clone = function (t) { return void 0 === t && (t = new THREE.Light), THREE.Object3D.prototype.clone.call(this, t), t.color.copy(this.color), t }, THREE.AmbientLight = function (t) { THREE.Light.call(this, t), this.type = "AmbientLight" }, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.constructor = THREE.AmbientLight, THREE.AmbientLight.prototype.clone = function () { var t = new THREE.AmbientLight; return THREE.Light.prototype.clone.call(this, t), t }, THREE.AreaLight = function (t, e) { THREE.Light.call(this, t), this.type = "AreaLight", this.normal = new THREE.Vector3(0, -1, 0), this.right = new THREE.Vector3(1, 0, 0), this.intensity = void 0 !== e ? e : 1, this.width = 1, this.height = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, this.quadraticAttenuation = .1 }, THREE.AreaLight.prototype = Object.create(THREE.Light.prototype), THREE.AreaLight.prototype.constructor = THREE.AreaLight, THREE.DirectionalLight = function (t, e) { THREE.Light.call(this, t), this.type = "DirectionalLight", this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== e ? e : 1, this.castShadow = !1, this.onlyShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, this.shadowCameraRight = 500, this.shadowCameraTop = 500, this.shadowCameraBottom = -500, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapWidth = 512, this.shadowMapHeight = 512, this.shadowCascade = !1, this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3), this.shadowCascadeCount = 2, this.shadowCascadeBias = [0, 0, 0], this.shadowCascadeWidth = [512, 512, 512], this.shadowCascadeHeight = [512, 512, 512], this.shadowCascadeNearZ = [-1, .99, .998], this.shadowCascadeFarZ = [.99, .998, 1], this.shadowCascadeArray = [], this.shadowMap = null, this.shadowMapSize = null, this.shadowCamera = null, this.shadowMatrix = null }, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight, THREE.DirectionalLight.prototype.clone = function () { var t = new THREE.DirectionalLight; return THREE.Light.prototype.clone.call(this, t), t.target = this.target.clone(), t.intensity = this.intensity, t.castShadow = this.castShadow, t.onlyShadow = this.onlyShadow, t.shadowCameraNear = this.shadowCameraNear, t.shadowCameraFar = this.shadowCameraFar, t.shadowCameraLeft = this.shadowCameraLeft, t.shadowCameraRight = this.shadowCameraRight, t.shadowCameraTop = this.shadowCameraTop, t.shadowCameraBottom = this.shadowCameraBottom, t.shadowCameraVisible = this.shadowCameraVisible, t.shadowBias = this.shadowBias, t.shadowDarkness = this.shadowDarkness, t.shadowMapWidth = this.shadowMapWidth, t.shadowMapHeight = this.shadowMapHeight, t.shadowCascade = this.shadowCascade, t.shadowCascadeOffset.copy(this.shadowCascadeOffset), t.shadowCascadeCount = this.shadowCascadeCount, t.shadowCascadeBias = this.shadowCascadeBias.slice(0), t.shadowCascadeWidth = this.shadowCascadeWidth.slice(0), t.shadowCascadeHeight = this.shadowCascadeHeight.slice(0), t.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0), t.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0), t }, THREE.HemisphereLight = function (t, e, r) { THREE.Light.call(this, t), this.type = "HemisphereLight", this.position.set(0, 100, 0), this.groundColor = new THREE.Color(e), this.intensity = void 0 !== r ? r : 1 }, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight, THREE.HemisphereLight.prototype.clone = function () { var t = new THREE.HemisphereLight; return THREE.Light.prototype.clone.call(this, t), t.groundColor.copy(this.groundColor), t.intensity = this.intensity, t }, THREE.PointLight = function (t, e, r, i) { THREE.Light.call(this, t), this.type = "PointLight", this.intensity = void 0 !== e ? e : 1, this.distance = void 0 !== r ? r : 0, this.decay = void 0 !== i ? i : 1 }, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.constructor = THREE.PointLight, THREE.PointLight.prototype.clone = function () { var t = new THREE.PointLight; return THREE.Light.prototype.clone.call(this, t), t.intensity = this.intensity, t.distance = this.distance, t.decay = this.decay, t }, THREE.SpotLight = function (t, e, r, i, n, a) { THREE.Light.call(this, t), this.type = "SpotLight", this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== e ? e : 1, this.distance = void 0 !== r ? r : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.exponent = void 0 !== n ? n : 10, this.decay = void 0 !== a ? a : 1, this.castShadow = !1, this.onlyShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraFov = 50, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapWidth = 512, this.shadowMapHeight = 512, this.shadowMap = null, this.shadowMapSize = null, this.shadowCamera = null, this.shadowMatrix = null }, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.constructor = THREE.SpotLight, THREE.SpotLight.prototype.clone = function () { var t = new THREE.SpotLight; return THREE.Light.prototype.clone.call(this, t), t.target = this.target.clone(), t.intensity = this.intensity, t.distance = this.distance, t.angle = this.angle, t.exponent = this.exponent, t.decay = this.decay, t.castShadow = this.castShadow, t.onlyShadow = this.onlyShadow, t.shadowCameraNear = this.shadowCameraNear, t.shadowCameraFar = this.shadowCameraFar, t.shadowCameraFov = this.shadowCameraFov, t.shadowCameraVisible = this.shadowCameraVisible, t.shadowBias = this.shadowBias, t.shadowDarkness = this.shadowDarkness, t.shadowMapWidth = this.shadowMapWidth, t.shadowMapHeight = this.shadowMapHeight, t }, THREE.Cache = { files: {}, add: function (t, e) { this.files[t] = e }, get: function (t) { return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }, THREE.Loader = function (t) { this.showStatus = t, this.statusDomElement = t ? THREE.Loader.prototype.addStatusElement() : null, this.imageLoader = new THREE.ImageLoader, this.onLoadStart = function () { }, this.onLoadProgress = function () { }, this.onLoadComplete = function () { } }, THREE.Loader.prototype = { constructor: THREE.Loader, crossOrigin: void 0, addStatusElement: function () { var t = document.createElement("div"); return t.style.position = "absolute", t.style.right = "0px", t.style.top = "0px", t.style.fontSize = "0.8em", t.style.textAlign = "left", t.style.background = "rgba(0,0,0,0.25)", t.style.color = "#fff", t.style.width = "120px", t.style.padding = "0.5em 0.5em 0.5em 0.5em", t.style.zIndex = 1e3, t.innerHTML = "Loading ...", t }, updateProgress: function (t) { var e = "Loaded "; t.total ? e += (100 * t.loaded / t.total).toFixed(0) + "%" : e += (t.loaded / 1024).toFixed(2) + " KB", this.statusDomElement.innerHTML = e }, extractUrlBase: function (t) { var e = t.split("/"); return 1 === e.length ? "./" : (e.pop(), e.join("/") + "/") }, initMaterials: function (t, e) { for (var r = [], i = 0; i < t.length; ++i)r[i] = this.createMaterial(t[i], e); return r }, needsTangents: function (t) { for (var e = 0, r = t.length; e < r; e++) { if (t[e] instanceof THREE.ShaderMaterial) return !0 } return !1 }, createMaterial: function (t, e) { var r = this; function i(t) { var e = Math.log(t) / Math.LN2; return Math.pow(2, Math.round(e)) } function n(t, n, a, o, s, h, l) { var c, u = e + a, E = THREE.Loader.Handlers.get(u); if (null !== E ? c = E.load(u) : (c = new THREE.Texture, (E = r.imageLoader).crossOrigin = r.crossOrigin, E.load(u, function (t) { if (!1 === THREE.Math.isPowerOfTwo(t.width) || !1 === THREE.Math.isPowerOfTwo(t.height)) { var e = i(t.width), r = i(t.height), n = document.createElement("canvas"); n.width = e, n.height = r, n.getContext("2d").drawImage(t, 0, 0, e, r), c.image = n } else c.image = t; c.needsUpdate = !0 })), c.sourceFile = a, o && (c.repeat.set(o[0], o[1]), 1 !== o[0] && (c.wrapS = THREE.RepeatWrapping), 1 !== o[1] && (c.wrapT = THREE.RepeatWrapping)), s && c.offset.set(s[0], s[1]), h) { var p = { repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping }; void 0 !== p[h[0]] && (c.wrapS = p[h[0]]), void 0 !== p[h[1]] && (c.wrapT = p[h[1]]) } l && (c.anisotropy = l), t[n] = c } function a(t) { return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2] } var o = "MeshLambertMaterial", s = { color: 15658734, opacity: 1, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: !1 }; if (t.shading) { var h = t.shading.toLowerCase(); "phong" === h ? o = "MeshPhongMaterial" : "basic" === h && (o = "MeshBasicMaterial") } void 0 !== t.blending && void 0 !== THREE[t.blending] && (s.blending = THREE[t.blending]), void 0 !== t.transparent && (s.transparent = t.transparent), void 0 !== t.opacity && t.opacity < 1 && (s.transparent = !0), void 0 !== t.depthTest && (s.depthTest = t.depthTest), void 0 !== t.depthWrite && (s.depthWrite = t.depthWrite), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.flipSided && (s.side = THREE.BackSide), void 0 !== t.doubleSided && (s.side = THREE.DoubleSide), void 0 !== t.wireframe && (s.wireframe = t.wireframe), void 0 !== t.vertexColors && ("face" === t.vertexColors ? s.vertexColors = THREE.FaceColors : t.vertexColors && (s.vertexColors = THREE.VertexColors)), t.colorDiffuse ? s.color = a(t.colorDiffuse) : t.DbgColor && (s.color = t.DbgColor), t.colorSpecular && (s.specular = a(t.colorSpecular)), t.colorEmissive && (s.emissive = a(t.colorEmissive)), void 0 !== t.transparency && (t.opacity = t.transparency), void 0 !== t.opacity && (s.opacity = t.opacity), t.specularCoef && (s.shininess = t.specularCoef), t.mapDiffuse && e && n(s, "map", t.mapDiffuse, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy), t.mapLight && e && n(s, "lightMap", t.mapLight, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy), t.mapBump && e && n(s, "bumpMap", t.mapBump, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy), t.mapNormal && e && n(s, "normalMap", t.mapNormal, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy), t.mapSpecular && e && n(s, "specularMap", t.mapSpecular, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy), t.mapAlpha && e && n(s, "alphaMap", t.mapAlpha, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy), t.mapBumpScale && (s.bumpScale = t.mapBumpScale), t.mapNormalFactor && (s.normalScale = new THREE.Vector2(t.mapNormalFactor, t.mapNormalFactor)); var l = new THREE[o](s); return void 0 !== t.DbgName && (l.name = t.DbgName), l } }, THREE.Loader.Handlers = { handlers: [], add: function (t, e) { this.handlers.push(t, e) }, get: function (t) { for (var e = 0, r = this.handlers.length; e < r; e += 2) { var i = this.handlers[e], n = this.handlers[e + 1]; if (i.test(t)) return n } return null } }, THREE.XHRLoader = function (t) { this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager }, THREE.XHRLoader.prototype = { constructor: THREE.XHRLoader, load: function (t, e, r, i) { var n = this, a = THREE.Cache.get(t); if (void 0 === a) { var o = new XMLHttpRequest; o.open("GET", t, !0), o.addEventListener("load", function (r) { THREE.Cache.add(t, this.response), e && e(this.response), n.manager.itemEnd(t) }, !1), void 0 !== r && o.addEventListener("progress", function (t) { r(t) }, !1), void 0 !== i && o.addEventListener("error", function (t) { i(t) }, !1), void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (o.responseType = this.responseType), o.send(null), n.manager.itemStart(t) } else e && e(a) }, setResponseType: function (t) { this.responseType = t }, setCrossOrigin: function (t) { this.crossOrigin = t } }, THREE.ImageLoader = function (t) { this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager }, THREE.ImageLoader.prototype = { constructor: THREE.ImageLoader, load: function (t, e, r, i) { var n = this, a = THREE.Cache.get(t); if (void 0 === a) { var o = document.createElement("img"); return o.addEventListener("load", function (r) { THREE.Cache.add(t, this), e && e(this), n.manager.itemEnd(t) }, !1), void 0 !== r && o.addEventListener("progress", function (t) { r(t) }, !1), void 0 !== i && o.addEventListener("error", function (t) { i(t) }, !1), void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), o.src = t, n.manager.itemStart(t), o } e(a) }, setCrossOrigin: function (t) { this.crossOrigin = t } }, THREE.JSONLoader = function (t) { THREE.Loader.call(this, t), this.withCredentials = !1 }, THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype), THREE.JSONLoader.prototype.constructor = THREE.JSONLoader, THREE.JSONLoader.prototype.load = function (t, e, r) { r = r && "string" == typeof r ? r : this.extractUrlBase(t), this.onLoadStart(), this.loadAjaxJSON(this, t, e, r) }, THREE.JSONLoader.prototype.loadAjaxJSON = function (t, e, r, i, n) { var a = new XMLHttpRequest, o = 0; a.onreadystatechange = function () { if (a.readyState === a.DONE) if (200 === a.status || 0 === a.status) { if (a.responseText) { var s = JSON.parse(a.responseText), h = s.metadata; if (void 0 !== h) { if ("object" === h.type) return void THREE.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead."); if ("scene" === h.type) return void THREE.error("THREE.JSONLoader: " + e + " seems to be a Scene. Use THREE.SceneLoader instead.") } var l = t.parse(s, i); r(l.geometry, l.materials) } else THREE.error("THREE.JSONLoader: " + e + " seems to be unreachable or the file is empty."); t.onLoadComplete() } else THREE.error("THREE.JSONLoader: Couldn't load " + e + " (" + a.status + ")"); else a.readyState === a.LOADING ? n && (0 === o && (o = a.getResponseHeader("Content-Length")), n({ total: o, loaded: a.responseText.length })) : a.readyState === a.HEADERS_RECEIVED && void 0 !== n && (o = a.getResponseHeader("Content-Length")) }, a.open("GET", e, !0), a.withCredentials = this.withCredentials, a.send(null) }, THREE.JSONLoader.prototype.parse = function (t, e) { var r = new THREE.Geometry, i = void 0 !== t.scale ? 1 / t.scale : 1; if (function (e) { function i(t, e) { return t & 1 << e } var n, a, o, s, h, l, c, u, E, p, f, d, m, T, g, v, R, y, H, x, b, _, w, M, S, A, C, L = t.faces, P = t.vertices, F = t.normals, U = t.colors, B = 0; if (void 0 !== t.uvs) { for (n = 0; n < t.uvs.length; n++)t.uvs[n].length && B++; for (n = 0; n < B; n++)r.faceVertexUvs[n] = [] } s = 0, h = P.length; for (; s < h;)(y = new THREE.Vector3).x = P[s++] * e, y.y = P[s++] * e, y.z = P[s++] * e, r.vertices.push(y); s = 0, h = L.length; for (; s < h;)if (p = L[s++], f = i(p, 0), d = i(p, 1), m = i(p, 3), T = i(p, 4), g = i(p, 5), v = i(p, 6), R = i(p, 7), f) { if ((x = new THREE.Face3).a = L[s], x.b = L[s + 1], x.c = L[s + 3], (b = new THREE.Face3).a = L[s + 1], b.b = L[s + 2], b.c = L[s + 3], s += 4, d && (E = L[s++], x.materialIndex = E, b.materialIndex = E), o = r.faces.length, m) for (n = 0; n < B; n++)for (M = t.uvs[n], r.faceVertexUvs[n][o] = [], r.faceVertexUvs[n][o + 1] = [], a = 0; a < 4; a++)u = L[s++], A = M[2 * u], C = M[2 * u + 1], S = new THREE.Vector2(A, C), 2 !== a && r.faceVertexUvs[n][o].push(S), 0 !== a && r.faceVertexUvs[n][o + 1].push(S); if (T && (c = 3 * L[s++], x.normal.set(F[c++], F[c++], F[c]), b.normal.copy(x.normal)), g) for (n = 0; n < 4; n++)c = 3 * L[s++], w = new THREE.Vector3(F[c++], F[c++], F[c]), 2 !== n && x.vertexNormals.push(w), 0 !== n && b.vertexNormals.push(w); if (v && (l = L[s++], _ = U[l], x.color.setHex(_), b.color.setHex(_)), R) for (n = 0; n < 4; n++)l = L[s++], _ = U[l], 2 !== n && x.vertexColors.push(new THREE.Color(_)), 0 !== n && b.vertexColors.push(new THREE.Color(_)); r.faces.push(x), r.faces.push(b) } else { if ((H = new THREE.Face3).a = L[s++], H.b = L[s++], H.c = L[s++], d && (E = L[s++], H.materialIndex = E), o = r.faces.length, m) for (n = 0; n < B; n++)for (M = t.uvs[n], r.faceVertexUvs[n][o] = [], a = 0; a < 3; a++)u = L[s++], A = M[2 * u], C = M[2 * u + 1], S = new THREE.Vector2(A, C), r.faceVertexUvs[n][o].push(S); if (T && (c = 3 * L[s++], H.normal.set(F[c++], F[c++], F[c])), g) for (n = 0; n < 3; n++)c = 3 * L[s++], w = new THREE.Vector3(F[c++], F[c++], F[c]), H.vertexNormals.push(w); if (v && (l = L[s++], H.color.setHex(U[l])), R) for (n = 0; n < 3; n++)l = L[s++], H.vertexColors.push(new THREE.Color(U[l])); r.faces.push(H) } }(i), function () { var e = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2; if (t.skinWeights) for (var i = 0, n = t.skinWeights.length; i < n; i += e) { var a = t.skinWeights[i], o = e > 1 ? t.skinWeights[i + 1] : 0, s = e > 2 ? t.skinWeights[i + 2] : 0, h = e > 3 ? t.skinWeights[i + 3] : 0; r.skinWeights.push(new THREE.Vector4(a, o, s, h)) } if (t.skinIndices) for (var i = 0, n = t.skinIndices.length; i < n; i += e) { var l = t.skinIndices[i], c = e > 1 ? t.skinIndices[i + 1] : 0, u = e > 2 ? t.skinIndices[i + 2] : 0, E = e > 3 ? t.skinIndices[i + 3] : 0; r.skinIndices.push(new THREE.Vector4(l, c, u, E)) } r.bones = t.bones, r.bones && r.bones.length > 0 && (r.skinWeights.length !== r.skinIndices.length || r.skinIndices.length !== r.vertices.length) && THREE.warn("THREE.JSONLoader: When skinning, number of vertices (" + r.vertices.length + "), skinIndices (" + r.skinIndices.length + "), and skinWeights (" + r.skinWeights.length + ") should match."); r.animation = t.animation, r.animations = t.animations }(), function (e) { var i, n, a, o, s, h, l, c, u, E, p; if (void 0 !== t.morphTargets) for (s = 0, h = t.morphTargets.length; s < h; s++)for (r.morphTargets[s] = {}, r.morphTargets[s].name = t.morphTargets[s].name, r.morphTargets[s].vertices = [], a = r.morphTargets[s].vertices, o = t.morphTargets[s].vertices, i = 0, n = o.length; i < n; i += 3) { var f = new THREE.Vector3; f.x = o[i] * e, f.y = o[i + 1] * e, f.z = o[i + 2] * e, a.push(f) } if (void 0 !== t.morphColors) for (s = 0, h = t.morphColors.length; s < h; s++)for (r.morphColors[s] = {}, r.morphColors[s].name = t.morphColors[s].name, r.morphColors[s].colors = [], u = r.morphColors[s].colors, E = t.morphColors[s].colors, l = 0, c = E.length; l < c; l += 3)(p = new THREE.Color(16755200)).setRGB(E[l], E[l + 1], E[l + 2]), u.push(p) }(i), r.computeFaceNormals(), r.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length) return { geometry: r }; var n = this.initMaterials(t.materials, e); return this.needsTangents(n) && r.computeTangents(), { geometry: r, materials: n } }, THREE.LoadingManager = function (t, e, r) { var i = this, n = 0, a = 0; this.onLoad = t, this.onProgress = e, this.onError = r, this.itemStart = function (t) { a++ }, this.itemEnd = function (t) { n++ , void 0 !== i.onProgress && i.onProgress(t, n, a), n === a && void 0 !== i.onLoad && i.onLoad() } }, THREE.DefaultLoadingManager = new THREE.LoadingManager, THREE.BufferGeometryLoader = function (t) { this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager }, THREE.BufferGeometryLoader.prototype = { constructor: THREE.BufferGeometryLoader, load: function (t, e, r, i) { var n = this, a = new THREE.XHRLoader(n.manager); a.setCrossOrigin(this.crossOrigin), a.load(t, function (t) { e(n.parse(JSON.parse(t))) }, r, i) }, setCrossOrigin: function (t) { this.crossOrigin = t }, parse: function (t) { var e = new THREE.BufferGeometry, r = t.data.attributes; for (var i in r) { var n = r[i], a = new self[n.type](n.array); e.addAttribute(i, new THREE.BufferAttribute(a, n.itemSize)) } var o = t.data.offsets; void 0 !== o && (e.offsets = JSON.parse(JSON.stringify(o))); var s = t.data.boundingSphere; if (void 0 !== s) { var h = new THREE.Vector3; void 0 !== s.center && h.fromArray(s.center), e.boundingSphere = new THREE.Sphere(h, s.radius) } return e } }, THREE.MaterialLoader = function (t) { this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager }, THREE.MaterialLoader.prototype = { constructor: THREE.MaterialLoader, load: function (t, e, r, i) { var n = this, a = new THREE.XHRLoader(n.manager); a.setCrossOrigin(this.crossOrigin), a.load(t, function (t) { e(n.parse(JSON.parse(t))) }, r, i) }, setCrossOrigin: function (t) { this.crossOrigin = t }, parse: function (t) { var e = new THREE[t.type]; if (void 0 !== t.color && e.color.setHex(t.color), void 0 !== t.emissive && e.emissive.setHex(t.emissive), void 0 !== t.specular && e.specular.setHex(t.specular), void 0 !== t.shininess && (e.shininess = t.shininess), void 0 !== t.uniforms && (e.uniforms = t.uniforms), void 0 !== t.vertexShader && (e.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (e.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (e.vertexColors = t.vertexColors), void 0 !== t.shading && (e.shading = t.shading), void 0 !== t.blending && (e.blending = t.blending), void 0 !== t.side && (e.side = t.side), void 0 !== t.opacity && (e.opacity = t.opacity), void 0 !== t.transparent && (e.transparent = t.transparent), void 0 !== t.wireframe && (e.wireframe = t.wireframe), void 0 !== t.size && (e.size = t.size), void 0 !== t.sizeAttenuation && (e.sizeAttenuation = t.sizeAttenuation), void 0 !== t.materials) for (var r = 0, i = t.materials.length; r < i; r++)e.materials.push(this.parse(t.materials[r])); return e } }, THREE.ObjectLoader = function (t) { this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager, this.texturePath = "" }, THREE.ObjectLoader.prototype = { constructor: THREE.ObjectLoader, load: function (t, e, r, i) { "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1)); var n = this, a = new THREE.XHRLoader(n.manager); a.setCrossOrigin(this.crossOrigin), a.load(t, function (t) { n.parse(JSON.parse(t), e) }, r, i) }, setTexturePath: function (t) { this.texturePath = t }, setCrossOrigin: function (t) { this.crossOrigin = t }, parse: function (t, e) { var r = this.parseGeometries(t.geometries), i = this.parseImages(t.images, function () { void 0 !== e && e(o) }), n = this.parseTextures(t.textures, i), a = this.parseMaterials(t.materials, n), o = this.parseObject(t.object, r, a); return void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(o), o }, parseGeometries: function (t) { var e = {}; if (void 0 !== t) for (var r = new THREE.JSONLoader, i = new THREE.BufferGeometryLoader, n = 0, a = t.length; n < a; n++) { var o, s = t[n]; switch (s.type) { case "PlaneGeometry": case "PlaneBufferGeometry": o = new THREE[s.type](s.width, s.height, s.widthSegments, s.heightSegments); break; case "BoxGeometry": case "CubeGeometry": o = new THREE.BoxGeometry(s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments); break; case "CircleGeometry": o = new THREE.CircleGeometry(s.radius, s.segments); break; case "CylinderGeometry": o = new THREE.CylinderGeometry(s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded); break; case "SphereGeometry": o = new THREE.SphereGeometry(s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength); break; case "IcosahedronGeometry": o = new THREE.IcosahedronGeometry(s.radius, s.detail); break; case "TorusGeometry": o = new THREE.TorusGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc); break; case "TorusKnotGeometry": o = new THREE.TorusKnotGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.p, s.q, s.heightScale); break; case "BufferGeometry": o = i.parse(s); break; case "Geometry": o = r.parse(s.data).geometry }o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), e[s.uuid] = o } return e }, parseMaterials: function (t, e) { var r = {}; if (void 0 !== t) for (var i = function (t) { return void 0 === e[t] && THREE.warn("THREE.ObjectLoader: Undefined texture", t), e[t] }, n = new THREE.MaterialLoader, a = 0, o = t.length; a < o; a++) { var s = t[a], h = n.parse(s); h.uuid = s.uuid, void 0 !== s.name && (h.name = s.name), void 0 !== s.map && (h.map = i(s.map)), void 0 !== s.bumpMap && (h.bumpMap = i(s.bumpMap), s.bumpScale && (h.bumpScale = new THREE.Vector2(s.bumpScale, s.bumpScale))), void 0 !== s.alphaMap && (h.alphaMap = i(s.alphaMap)), void 0 !== s.envMap && (h.envMap = i(s.envMap)), void 0 !== s.normalMap && (h.normalMap = i(s.normalMap), s.normalScale && (h.normalScale = new THREE.Vector2(s.normalScale, s.normalScale))), void 0 !== s.lightMap && (h.lightMap = i(s.lightMap)), void 0 !== s.specularMap && (h.specularMap = i(s.specularMap)), r[s.uuid] = h } return r }, parseImages: function (t, e) { var r = this, i = {}; if (void 0 !== t && t.length > 0) { var n = new THREE.LoadingManager(e), a = new THREE.ImageLoader(n); a.setCrossOrigin(this.crossOrigin); for (var o = function (t) { return r.manager.itemStart(t), a.load(t, function () { r.manager.itemEnd(t) }) }, s = 0, h = t.length; s < h; s++) { var l = t[s], c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : r.texturePath + l.url; i[l.uuid] = o(c) } } return i }, parseTextures: function (t, e) { var r = {}; if (void 0 !== t) for (var i = 0, n = t.length; i < n; i++) { var a = t[i]; void 0 === a.image && THREE.warn('THREE.ObjectLoader: No "image" speficied for', a.uuid), void 0 === e[a.image] && THREE.warn("THREE.ObjectLoader: Undefined image", a.image); var o = new THREE.Texture(e[a.image]); o.needsUpdate = !0, o.uuid = a.uuid, void 0 !== a.name && (o.name = a.name), void 0 !== a.repeat && (o.repeat = new THREE.Vector2(a.repeat[0], a.repeat[1])), void 0 !== a.minFilter && (o.minFilter = THREE[a.minFilter]), void 0 !== a.magFilter && (o.magFilter = THREE[a.magFilter]), void 0 !== a.anisotropy && (o.anisotropy = a.anisotropy), a.wrap instanceof Array && (o.wrapS = THREE[a.wrap[0]], o.wrapT = THREE[a.wrap[1]]), r[a.uuid] = o } return r }, parseObject: function () { var t = new THREE.Matrix4; return function (e, r, i) { var n, a = function (t) { return void 0 === r[t] && THREE.warn("THREE.ObjectLoader: Undefined geometry", t), r[t] }, o = function (t) { return void 0 === i[t] && THREE.warn("THREE.ObjectLoader: Undefined material", t), i[t] }; switch (e.type) { case "Scene": n = new THREE.Scene; break; case "PerspectiveCamera": n = new THREE.PerspectiveCamera(e.fov, e.aspect, e.near, e.far); break; case "OrthographicCamera": n = new THREE.OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far); break; case "AmbientLight": n = new THREE.AmbientLight(e.color); break; case "DirectionalLight": n = new THREE.DirectionalLight(e.color, e.intensity); break; case "PointLight": n = new THREE.PointLight(e.color, e.intensity, e.distance, e.decay); break; case "SpotLight": n = new THREE.SpotLight(e.color, e.intensity, e.distance, e.angle, e.exponent, e.decay); break; case "HemisphereLight": n = new THREE.HemisphereLight(e.color, e.groundColor, e.intensity); break; case "Mesh": n = new THREE.Mesh(a(e.geometry), o(e.material)); break; case "Line": n = new THREE.Line(a(e.geometry), o(e.material), e.mode); break; case "PointCloud": n = new THREE.PointCloud(a(e.geometry), o(e.material)); break; case "Sprite": n = new THREE.Sprite(o(e.material)); break; case "Group": n = new THREE.Group; break; default: n = new THREE.Object3D }if (n.uuid = e.uuid, void 0 !== e.name && (n.name = e.name), void 0 !== e.matrix ? (t.fromArray(e.matrix), t.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position), void 0 !== e.rotation && n.rotation.fromArray(e.rotation), void 0 !== e.scale && n.scale.fromArray(e.scale)), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.children) for (var s in e.children) n.add(this.parseObject(e.children[s], r, i)); return n } }() }, THREE.TextureLoader = function (t) { this.manager = void 0 !== t ? t : THREE.DefaultLoadingManager }, THREE.TextureLoader.prototype = { constructor: THREE.TextureLoader, load: function (t, e, r, i) { var n = new THREE.ImageLoader(this.manager); n.setCrossOrigin(this.crossOrigin), n.load(t, function (t) { var r = new THREE.Texture(t); r.needsUpdate = !0, void 0 !== e && e(r) }, r, i) }, setCrossOrigin: function (t) { this.crossOrigin = t } }, THREE.DataTextureLoader = THREE.BinaryTextureLoader = function () { this._parser = null }, THREE.BinaryTextureLoader.prototype = { constructor: THREE.BinaryTextureLoader, load: function (t, e, r, i) { var n = this, a = new THREE.DataTexture, o = new THREE.XHRLoader; return o.setResponseType("arraybuffer"), o.load(t, function (t) { var r = n._parser(t); r && (void 0 !== r.image ? a.image = r.image : void 0 !== r.data && (a.image.width = r.width, a.image.height = r.height, a.image.data = r.data), a.wrapS = void 0 !== r.wrapS ? r.wrapS : THREE.ClampToEdgeWrapping, a.wrapT = void 0 !== r.wrapT ? r.wrapT : THREE.ClampToEdgeWrapping, a.magFilter = void 0 !== r.magFilter ? r.magFilter : THREE.LinearFilter, a.minFilter = void 0 !== r.minFilter ? r.minFilter : THREE.LinearMipMapLinearFilter, a.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1, void 0 !== r.format && (a.format = r.format), void 0 !== r.type && (a.type = r.type), void 0 !== r.mipmaps && (a.mipmaps = r.mipmaps), 1 === r.mipmapCount && (a.minFilter = THREE.LinearFilter), a.needsUpdate = !0, e && e(a, r)) }, r, i), a } }, THREE.CompressedTextureLoader = function () { this._parser = null }, THREE.CompressedTextureLoader.prototype = { constructor: THREE.CompressedTextureLoader, load: function (t, e, r) { var i = this, n = [], a = new THREE.CompressedTexture; a.image = n; var o = new THREE.XHRLoader; if (o.setResponseType("arraybuffer"), t instanceof Array) for (var s = 0, h = function (r) { o.load(t[r], function (t) { var o = i._parser(t, !0); n[r] = { width: o.width, height: o.height, format: o.format, mipmaps: o.mipmaps }, 6 === (s += 1) && (1 == o.mipmapCount && (a.minFilter = THREE.LinearFilter), a.format = o.format, a.needsUpdate = !0, e && e(a)) }) }, l = 0, c = t.length; l < c; ++l)h(l); else o.load(t, function (t) { var r = i._parser(t, !0); if (r.isCubemap) for (var o = r.mipmaps.length / r.mipmapCount, s = 0; s < o; s++) { n[s] = { mipmaps: [] }; for (var h = 0; h < r.mipmapCount; h++)n[s].mipmaps.push(r.mipmaps[s * r.mipmapCount + h]), n[s].format = r.format, n[s].width = r.width, n[s].height = r.height } else a.image.width = r.width, a.image.height = r.height, a.mipmaps = r.mipmaps; 1 === r.mipmapCount && (a.minFilter = THREE.LinearFilter), a.format = r.format, a.needsUpdate = !0, e && e(a) }); return a } }, THREE.Material = function () { Object.defineProperty(this, "id", { value: THREE.MaterialIdCount++ }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Material", this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, this.blendEquation = THREE.AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthTest = !0, this.depthWrite = !0, this.colorWrite = !0, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.overdraw = 0, this.visible = !0, this._needsUpdate = !0 }, THREE.Material.prototype = { constructor: THREE.Material, get needsUpdate() { return this._needsUpdate }, set needsUpdate(t) { !0 === t && this.update(), this._needsUpdate = t }, setValues: function (t) { if (void 0 !== t) for (var e in t) { var r = t[e]; if (void 0 !== r) { if (e in this) { var i = this[e]; i instanceof THREE.Color ? i.set(r) : i instanceof THREE.Vector3 && r instanceof THREE.Vector3 ? i.copy(r) : this[e] = "overdraw" == e ? Number(r) : r } } else THREE.warn("THREE.Material: '" + e + "' parameter is undefined.") } }, toJSON: function () { var t = { metadata: { version: 4.2, type: "material", generator: "MaterialExporter" }, uuid: this.uuid, type: this.type }; return "" !== this.name && (t.name = this.name), this instanceof THREE.MeshBasicMaterial ? (t.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (t.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (t.blending = this.blending), this.side !== THREE.FrontSide && (t.side = this.side)) : this instanceof THREE.MeshLambertMaterial ? (t.color = this.color.getHex(), t.emissive = this.emissive.getHex(), this.vertexColors !== THREE.NoColors && (t.vertexColors = this.vertexColors), this.shading !== THREE.SmoothShading && (t.shading = this.shading), this.blending !== THREE.NormalBlending && (t.blending = this.blending), this.side !== THREE.FrontSide && (t.side = this.side)) : this instanceof THREE.MeshPhongMaterial ? (t.color = this.color.getHex(), t.emissive = this.emissive.getHex(), t.specular = this.specular.getHex(), t.shininess = this.shininess, this.vertexColors !== THREE.NoColors && (t.vertexColors = this.vertexColors), this.shading !== THREE.SmoothShading && (t.shading = this.shading), this.blending !== THREE.NormalBlending && (t.blending = this.blending), this.side !== THREE.FrontSide && (t.side = this.side)) : this instanceof THREE.MeshNormalMaterial ? (this.blending !== THREE.NormalBlending && (t.blending = this.blending), this.side !== THREE.FrontSide && (t.side = this.side)) : this instanceof THREE.MeshDepthMaterial ? (this.blending !== THREE.NormalBlending && (t.blending = this.blending), this.side !== THREE.FrontSide && (t.side = this.side)) : this instanceof THREE.PointCloudMaterial ? (t.size = this.size, t.sizeAttenuation = this.sizeAttenuation, t.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (t.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (t.blending = this.blending)) : this instanceof THREE.ShaderMaterial ? (t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader) : this instanceof THREE.SpriteMaterial && (t.color = this.color.getHex()), this.opacity < 1 && (t.opacity = this.opacity), !1 !== this.transparent && (t.transparent = this.transparent), !1 !== this.wireframe && (t.wireframe = this.wireframe), t }, clone: function (t) { return void 0 === t && (t = new THREE.Material), t.name = this.name, t.side = this.side, t.opacity = this.opacity, t.transparent = this.transparent, t.blending = this.blending, t.blendSrc = this.blendSrc, t.blendDst = this.blendDst, t.blendEquation = this.blendEquation, t.blendSrcAlpha = this.blendSrcAlpha, t.blendDstAlpha = this.blendDstAlpha, t.blendEquationAlpha = this.blendEquationAlpha, t.depthTest = this.depthTest, t.depthWrite = this.depthWrite, t.polygonOffset = this.polygonOffset, t.polygonOffsetFactor = this.polygonOffsetFactor, t.polygonOffsetUnits = this.polygonOffsetUnits, t.alphaTest = this.alphaTest, t.overdraw = this.overdraw, t.visible = this.visible, t }, update: function () { this.dispatchEvent({ type: "update" }) }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, THREE.LineBasicMaterial = function (t) { THREE.Material.call(this), this.type = "LineBasicMaterial", this.color = new THREE.Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(t) }, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial, THREE.LineBasicMaterial.prototype.clone = function () { var t = new THREE.LineBasicMaterial; return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.linewidth = this.linewidth, t.linecap = this.linecap, t.linejoin = this.linejoin, t.vertexColors = this.vertexColors, t.fog = this.fog, t }, THREE.LineDashedMaterial = function (t) { THREE.Material.call(this), this.type = "LineDashedMaterial", this.color = new THREE.Color(16777215), this.linewidth = 1, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, this.fog = !0, this.setValues(t) }, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial, THREE.LineDashedMaterial.prototype.clone = function () { var t = new THREE.LineDashedMaterial; return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.linewidth = this.linewidth, t.scale = this.scale, t.dashSize = this.dashSize, t.gapSize = this.gapSize, t.vertexColors = this.vertexColors, t.fog = this.fog, t }, THREE.MeshBasicMaterial = function (t) { THREE.Material.call(this), this.type = "MeshBasicMaterial", this.color = new THREE.Color(16777215), this.map = null, this.lightMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.setValues(t) }, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial, THREE.MeshBasicMaterial.prototype.clone = function () { var t = new THREE.MeshBasicMaterial; return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.map = this.map, t.lightMap = this.lightMap, t.specularMap = this.specularMap, t.alphaMap = this.alphaMap, t.envMap = this.envMap, t.combine = this.combine, t.reflectivity = this.reflectivity, t.refractionRatio = this.refractionRatio, t.fog = this.fog, t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t.wireframeLinecap = this.wireframeLinecap, t.wireframeLinejoin = this.wireframeLinejoin, t.vertexColors = this.vertexColors, t.skinning = this.skinning, t.morphTargets = this.morphTargets, t }, THREE.MeshLambertMaterial = function (t) { THREE.Material.call(this), this.type = "MeshLambertMaterial", this.color = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.map = null, this.lightMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial, THREE.MeshLambertMaterial.prototype.clone = function () { var t = new THREE.MeshLambertMaterial; return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.emissive.copy(this.emissive), t.wrapAround = this.wrapAround, t.wrapRGB.copy(this.wrapRGB), t.map = this.map, t.lightMap = this.lightMap, t.specularMap = this.specularMap, t.alphaMap = this.alphaMap, t.envMap = this.envMap, t.combine = this.combine, t.reflectivity = this.reflectivity, t.refractionRatio = this.refractionRatio, t.fog = this.fog, t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t.wireframeLinecap = this.wireframeLinecap, t.wireframeLinejoin = this.wireframeLinejoin, t.vertexColors = this.vertexColors, t.skinning = this.skinning, t.morphTargets = this.morphTargets, t.morphNormals = this.morphNormals, t }, THREE.MeshPhongMaterial = function (t) { THREE.Material.call(this), this.type = "MeshPhongMaterial", this.color = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), this.shininess = 30, this.metal = !1, this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.map = null, this.lightMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) }, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial, THREE.MeshPhongMaterial.prototype.clone = function () { var t = new THREE.MeshPhongMaterial; return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.emissive.copy(this.emissive), t.specular.copy(this.specular), t.shininess = this.shininess, t.metal = this.metal, t.wrapAround = this.wrapAround, t.wrapRGB.copy(this.wrapRGB), t.map = this.map, t.lightMap = this.lightMap, t.bumpMap = this.bumpMap, t.bumpScale = this.bumpScale, t.normalMap = this.normalMap, t.normalScale.copy(this.normalScale), t.specularMap = this.specularMap, t.alphaMap = this.alphaMap, t.envMap = this.envMap, t.combine = this.combine, t.reflectivity = this.reflectivity, t.refractionRatio = this.refractionRatio, t.fog = this.fog, t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t.wireframeLinecap = this.wireframeLinecap, t.wireframeLinejoin = this.wireframeLinejoin, t.vertexColors = this.vertexColors, t.skinning = this.skinning, t.morphTargets = this.morphTargets, t.morphNormals = this.morphNormals, t }, THREE.MeshDepthMaterial = function (t) { THREE.Material.call(this), this.type = "MeshDepthMaterial", this.morphTargets = !1, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t) }, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial, THREE.MeshDepthMaterial.prototype.clone = function () { var t = new THREE.MeshDepthMaterial; return THREE.Material.prototype.clone.call(this, t), t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t }, THREE.MeshNormalMaterial = function (t) { THREE.Material.call(this, t), this.type = "MeshNormalMaterial", this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(t) }, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial, THREE.MeshNormalMaterial.prototype.clone = function () { var t = new THREE.MeshNormalMaterial; return THREE.Material.prototype.clone.call(this, t), t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t }, THREE.MeshFaceMaterial = function (t) { this.uuid = THREE.Math.generateUUID(), this.type = "MeshFaceMaterial", this.materials = t instanceof Array ? t : [] }, THREE.MeshFaceMaterial.prototype = { constructor: THREE.MeshFaceMaterial, toJSON: function () { for (var t = { metadata: { version: 4.2, type: "material", generator: "MaterialExporter" }, uuid: this.uuid, type: this.type, materials: [] }, e = 0, r = this.materials.length; e < r; e++)t.materials.push(this.materials[e].toJSON()); return t }, clone: function () { for (var t = new THREE.MeshFaceMaterial, e = 0; e < this.materials.length; e++)t.materials.push(this.materials[e].clone()); return t } }, THREE.PointCloudMaterial = function (t) { THREE.Material.call(this), this.type = "PointCloudMaterial", this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(t) }, THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype), THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial, THREE.PointCloudMaterial.prototype.clone = function () { var t = new THREE.PointCloudMaterial; return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.map = this.map, t.size = this.size, t.sizeAttenuation = this.sizeAttenuation, t.vertexColors = this.vertexColors, t.fog = this.fog, t }, THREE.ParticleBasicMaterial = function (t) { return THREE.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(t) }, THREE.ParticleSystemMaterial = function (t) { return THREE.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(t) }, THREE.ShaderMaterial = function (t) { THREE.Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.attributes = null, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.vertexColors = THREE.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.setValues(t) }, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial, THREE.ShaderMaterial.prototype.clone = function () { var t = new THREE.ShaderMaterial; return THREE.Material.prototype.clone.call(this, t), t.fragmentShader = this.fragmentShader, t.vertexShader = this.vertexShader, t.uniforms = THREE.UniformsUtils.clone(this.uniforms), t.attributes = this.attributes, t.defines = this.defines, t.shading = this.shading, t.wireframe = this.wireframe, t.wireframeLinewidth = this.wireframeLinewidth, t.fog = this.fog, t.lights = this.lights, t.vertexColors = this.vertexColors, t.skinning = this.skinning, t.morphTargets = this.morphTargets, t.morphNormals = this.morphNormals, t }, THREE.RawShaderMaterial = function (t) { THREE.ShaderMaterial.call(this, t), this.type = "RawShaderMaterial" }, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial, THREE.RawShaderMaterial.prototype.clone = function () { var t = new THREE.RawShaderMaterial; return THREE.ShaderMaterial.prototype.clone.call(this, t), t }, THREE.SpriteMaterial = function (t) { THREE.Material.call(this), this.type = "SpriteMaterial", this.color = new THREE.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(t) }, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial, THREE.SpriteMaterial.prototype.clone = function () { var t = new THREE.SpriteMaterial; return THREE.Material.prototype.clone.call(this, t), t.color.copy(this.color), t.map = this.map, t.rotation = this.rotation, t.fog = this.fog, t }, THREE.Texture = function (t, e, r, i, n, a, o, s, h) { Object.defineProperty(this, "id", { value: THREE.TextureIdCount++ }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.sourceFile = "", this.image = void 0 !== t ? t : THREE.Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : THREE.Texture.DEFAULT_MAPPING, this.wrapS = void 0 !== r ? r : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== i ? i : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== n ? n : THREE.LinearFilter, this.minFilter = void 0 !== a ? a : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== o ? o : THREE.RGBAFormat, this.type = void 0 !== s ? s : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null }, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping, THREE.Texture.prototype = { constructor: THREE.Texture, get needsUpdate() { return this._needsUpdate }, set needsUpdate(t) { !0 === t && this.update(), this._needsUpdate = t }, clone: function (t) { return void 0 === t && (t = new THREE.Texture), t.image = this.image, t.mipmaps = this.mipmaps.slice(0), t.mapping = this.mapping, t.wrapS = this.wrapS, t.wrapT = this.wrapT, t.magFilter = this.magFilter, t.minFilter = this.minFilter, t.anisotropy = this.anisotropy, t.format = this.format, t.type = this.type, t.offset.copy(this.offset), t.repeat.copy(this.repeat), t.generateMipmaps = this.generateMipmaps, t.premultiplyAlpha = this.premultiplyAlpha, t.flipY = this.flipY, t.unpackAlignment = this.unpackAlignment, t }, update: function () { this.dispatchEvent({ type: "update" }) }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, THREE.CubeTexture = function (t, e, r, i, n, a, o, s, h) { e = void 0 !== e ? e : THREE.CubeReflectionMapping, THREE.Texture.call(this, t, e, r, i, n, a, o, s, h), this.images = t }, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.prototype.constructor = THREE.CubeTexture, THREE.CubeTexture.clone = function (t) { return void 0 === t && (t = new THREE.CubeTexture), THREE.Texture.prototype.clone.call(this, t), t.images = this.images, t }, THREE.CompressedTexture = function (t, e, r, i, n, a, o, s, h, l, c) { THREE.Texture.call(this, null, a, o, s, h, l, i, n, c), this.image = { width: e, height: r }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 }, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture, THREE.CompressedTexture.prototype.clone = function () { var t = new THREE.CompressedTexture; return THREE.Texture.prototype.clone.call(this, t), t }, THREE.DataTexture = function (t, e, r, i, n, a, o, s, h, l, c) { THREE.Texture.call(this, null, a, o, s, h, l, i, n, c), this.image = { data: t, width: e, height: r } }, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.constructor = THREE.DataTexture, THREE.DataTexture.prototype.clone = function () { var t = new THREE.DataTexture; return THREE.Texture.prototype.clone.call(this, t), t }, THREE.VideoTexture = function (t, e, r, i, n, a, o, s, h) { THREE.Texture.call(this, t, e, r, i, n, a, o, s, h), this.generateMipmaps = !1; var l = this, c = function () { requestAnimationFrame(c), t.readyState === t.HAVE_ENOUGH_DATA && (l.needsUpdate = !0) }; c() }, THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype), THREE.VideoTexture.prototype.constructor = THREE.VideoTexture, THREE.Group = function () { THREE.Object3D.call(this), this.type = "Group" }, THREE.Group.prototype = Object.create(THREE.Object3D.prototype), THREE.Group.prototype.constructor = THREE.Group, THREE.PointCloud = function (t, e) { THREE.Object3D.call(this), this.type = "PointCloud", this.geometry = void 0 !== t ? t : new THREE.Geometry, this.material = void 0 !== e ? e : new THREE.PointCloudMaterial({ color: 16777215 * Math.random() }) }, THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype), THREE.PointCloud.prototype.constructor = THREE.PointCloud, THREE.PointCloud.prototype.raycast = function () { var t = new THREE.Matrix4, e = new THREE.Ray; return function (r, i) { var n = this, a = n.geometry, o = r.params.PointCloud.threshold; if (t.getInverse(this.matrixWorld), e.copy(r.ray).applyMatrix4(t), null === a.boundingBox || !1 !== e.isIntersectionBox(a.boundingBox)) { var s = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = new THREE.Vector3, l = function (t, a) { var o = e.distanceToPoint(t); if (o < s) { var h = e.closestPointToPoint(t); h.applyMatrix4(n.matrixWorld); var l = r.ray.origin.distanceTo(h); i.push({ distance: l, distanceToRay: o, point: h.clone(), index: a, face: null, object: n }) } }; if (a instanceof THREE.BufferGeometry) { var c = a.attributes, u = c.position.array; if (void 0 !== c.index) { var E = c.index.array, p = a.offsets; if (0 === p.length) p = [{ start: 0, count: E.length, index: 0 }]; for (var f = 0, d = p.length; f < d; ++f)for (var m = p[f].start, T = p[f].count, g = p[f].index, v = m, R = m + T; v < R; v++) { var y = g + E[v]; h.fromArray(u, 3 * y), l(h, y) } } else { var H = u.length / 3; for (v = 0; v < H; v++)h.set(u[3 * v], u[3 * v + 1], u[3 * v + 2]), l(h, v) } } else { var x = this.geometry.vertices; for (v = 0; v < x.length; v++)l(x[v], v) } } } }(), THREE.PointCloud.prototype.clone = function (t) { return void 0 === t && (t = new THREE.PointCloud(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, t), t }, THREE.ParticleSystem = function (t, e) { return THREE.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud."), new THREE.PointCloud(t, e) }, THREE.Line = function (t, e, r) { THREE.Object3D.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new THREE.Geometry, this.material = void 0 !== e ? e : new THREE.LineBasicMaterial({ color: 16777215 * Math.random() }), this.mode = void 0 !== r ? r : THREE.LineStrip }, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), THREE.Line.prototype.constructor = THREE.Line, THREE.Line.prototype.raycast = function () { var t = new THREE.Matrix4, e = new THREE.Ray, r = new THREE.Sphere; return function (i, n) { var a = i.linePrecision, o = a * a, s = this.geometry; if (null === s.boundingSphere && s.computeBoundingSphere(), r.copy(s.boundingSphere), r.applyMatrix4(this.matrixWorld), !1 !== i.ray.isIntersectionSphere(r)) { t.getInverse(this.matrixWorld), e.copy(i.ray).applyMatrix4(t); var h = new THREE.Vector3, l = new THREE.Vector3, c = new THREE.Vector3, u = new THREE.Vector3, E = this.mode === THREE.LineStrip ? 1 : 2; if (s instanceof THREE.BufferGeometry) { var p = s.attributes; if (void 0 !== p.index) { var f = p.index.array, d = p.position.array, m = s.offsets; 0 === m.length && (m = [{ start: 0, count: f.length, index: 0 }]); for (var T = 0; T < m.length; T++)for (var g = m[T].start, v = m[T].count, R = m[T].index, y = g; y < g + v - 1; y += E) { var H = R + f[y], x = R + f[y + 1]; if (h.fromArray(d, 3 * H), l.fromArray(d, 3 * x), !(e.distanceSqToSegment(h, l, u, c) > o)) (w = e.origin.distanceTo(u)) < i.near || w > i.far || n.push({ distance: w, point: c.clone().applyMatrix4(this.matrixWorld), index: y, offsetIndex: T, face: null, faceIndex: null, object: this }) } } else for (d = p.position.array, y = 0; y < d.length / 3 - 1; y += E) { if (h.fromArray(d, 3 * y), l.fromArray(d, 3 * y + 3), !(e.distanceSqToSegment(h, l, u, c) > o)) (w = e.origin.distanceTo(u)) < i.near || w > i.far || n.push({ distance: w, point: c.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this }) } } else if (s instanceof THREE.Geometry) { var b = s.vertices, _ = b.length; for (y = 0; y < _ - 1; y += E) { var w; if (!(e.distanceSqToSegment(b[y], b[y + 1], u, c) > o)) (w = e.origin.distanceTo(u)) < i.near || w > i.far || n.push({ distance: w, point: c.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this }) } } } } }(), THREE.Line.prototype.clone = function (t) { return void 0 === t && (t = new THREE.Line(this.geometry, this.material, this.mode)), THREE.Object3D.prototype.clone.call(this, t), t }, THREE.Mesh = function (t, e) { THREE.Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new THREE.Geometry, this.material = void 0 !== e ? e : new THREE.MeshBasicMaterial({ color: 16777215 * Math.random() }), this.updateMorphTargets() }, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.constructor = THREE.Mesh, THREE.Mesh.prototype.updateMorphTargets = function () { if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) { this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (var t = 0, e = this.geometry.morphTargets.length; t < e; t++)this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[t].name] = t } }, THREE.Mesh.prototype.getMorphTargetIndexByName = function (t) { return void 0 !== this.morphTargetDictionary[t] ? this.morphTargetDictionary[t] : (THREE.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + t + " does not exist. Returning 0."), 0) }, THREE.Mesh.prototype.raycast = function () { var t = new THREE.Matrix4, e = new THREE.Ray, r = new THREE.Sphere, i = new THREE.Vector3, n = new THREE.Vector3, a = new THREE.Vector3; return function (o, s) { var h = this.geometry; if (null === h.boundingSphere && h.computeBoundingSphere(), r.copy(h.boundingSphere), r.applyMatrix4(this.matrixWorld), !1 !== o.ray.isIntersectionSphere(r) && (t.getInverse(this.matrixWorld), e.copy(o.ray).applyMatrix4(t), null === h.boundingBox || !1 !== e.isIntersectionBox(h.boundingBox))) if (h instanceof THREE.BufferGeometry) { if (void 0 === (L = this.material)) return; var l = h.attributes, c = o.precision; if (void 0 !== l.index) { var u = l.index.array, E = l.position.array, p = h.offsets; 0 === p.length && (p = [{ start: 0, count: u.length, index: 0 }]); for (var f = 0, d = p.length; f < d; ++f)for (var m = p[f].start, T = p[f].count, g = p[f].index, v = m, R = m + T; v < R; v += 3) { if (x = g + u[v], b = g + u[v + 1], _ = g + u[v + 2], i.fromArray(E, 3 * x), n.fromArray(E, 3 * b), a.fromArray(E, 3 * _), L.side === THREE.BackSide) var y = e.intersectTriangle(a, n, i, !0); else y = e.intersectTriangle(i, n, a, L.side !== THREE.DoubleSide); if (null !== y) y.applyMatrix4(this.matrixWorld), (k = o.ray.origin.distanceTo(y)) < c || k < o.near || k > o.far || s.push({ distance: k, point: y, face: new THREE.Face3(x, b, _, THREE.Triangle.normal(i, n, a)), faceIndex: null, object: this }) } } else { v = 0; var H = 0; for (R = (E = l.position.array).length; v < R; v += 3, H += 9) { if (x = v, b = v + 1, _ = v + 2, i.fromArray(E, H), n.fromArray(E, H + 3), a.fromArray(E, H + 6), L.side === THREE.BackSide) y = e.intersectTriangle(a, n, i, !0); else y = e.intersectTriangle(i, n, a, L.side !== THREE.DoubleSide); if (null !== y) y.applyMatrix4(this.matrixWorld), (k = o.ray.origin.distanceTo(y)) < c || k < o.near || k > o.far || s.push({ distance: k, point: y, face: new THREE.Face3(x, b, _, THREE.Triangle.normal(i, n, a)), faceIndex: null, object: this }) } } } else if (h instanceof THREE.Geometry) for (var x, b, _, w = this.material instanceof THREE.MeshFaceMaterial, M = !0 === w ? this.material.materials : null, S = (c = o.precision, h.vertices), A = 0, C = h.faces.length; A < C; A++) { var L, P = h.faces[A]; if (void 0 !== (L = !0 === w ? M[P.materialIndex] : this.material)) { if (x = S[P.a], b = S[P.b], _ = S[P.c], !0 === L.morphTargets) { var F = h.morphTargets, U = this.morphTargetInfluences; i.set(0, 0, 0), n.set(0, 0, 0), a.set(0, 0, 0); for (var B = 0, D = F.length; B < D; B++) { var V = U[B]; if (0 !== V) { var z = F[B].vertices; i.x += (z[P.a].x - x.x) * V, i.y += (z[P.a].y - x.y) * V, i.z += (z[P.a].z - x.z) * V, n.x += (z[P.b].x - b.x) * V, n.y += (z[P.b].y - b.y) * V, n.z += (z[P.b].z - b.z) * V, a.x += (z[P.c].x - _.x) * V, a.y += (z[P.c].y - _.y) * V, a.z += (z[P.c].z - _.z) * V } } i.add(x), n.add(b), a.add(_), x = i, b = n, _ = a } if (L.side === THREE.BackSide) y = e.intersectTriangle(_, b, x, !0); else y = e.intersectTriangle(x, b, _, L.side !== THREE.DoubleSide); var k; if (null !== y) y.applyMatrix4(this.matrixWorld), (k = o.ray.origin.distanceTo(y)) < c || k < o.near || k > o.far || s.push({ distance: k, point: y, face: P, faceIndex: A, object: this }) } } } }(), THREE.Mesh.prototype.clone = function (t, e) { return void 0 === t && (t = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, t, e), t }, THREE.Bone = function (t) { THREE.Object3D.call(this), this.type = "Bone", this.skin = t }, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.constructor = THREE.Bone, THREE.Skeleton = function (t, e, r) { var i; (this.useVertexTexture = void 0 === r || r, this.identityMatrix = new THREE.Matrix4, t = t || [], this.bones = t.slice(0), this.useVertexTexture) ? (i = this.bones.length > 256 ? 64 : this.bones.length > 64 ? 32 : this.bones.length > 16 ? 16 : 8, this.boneTextureWidth = i, this.boneTextureHeight = i, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length); if (void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else { THREE.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = []; for (var n = 0, a = this.bones.length; n < a; n++)this.boneInverses.push(new THREE.Matrix4) } }, THREE.Skeleton.prototype.calculateInverses = function () { this.boneInverses = []; for (var t = 0, e = this.bones.length; t < e; t++) { var r = new THREE.Matrix4; this.bones[t] && r.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(r) } }, THREE.Skeleton.prototype.pose = function () { for (var t, e = 0, r = this.bones.length; e < r; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]); for (e = 0, r = this.bones.length; e < r; e++)(t = this.bones[e]) && (t.parent ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) }, THREE.Skeleton.prototype.update = function () { var t = new THREE.Matrix4; return function () { for (var e = 0, r = this.bones.length; e < r; e++) { var i = this.bones[e] ? this.bones[e].matrixWorld : this.identityMatrix; t.multiplyMatrices(i, this.boneInverses[e]), t.flattenToArrayOffset(this.boneMatrices, 16 * e) } this.useVertexTexture && (this.boneTexture.needsUpdate = !0) } }(), THREE.SkinnedMesh = function (t, e, r) { THREE.Mesh.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new THREE.Matrix4, this.bindMatrixInverse = new THREE.Matrix4; var i = []; if (this.geometry && void 0 !== this.geometry.bones) { for (var n, a, o, s, h, l = 0, c = this.geometry.bones.length; l < c; ++l)o = (a = this.geometry.bones[l]).pos, s = a.rotq, h = a.scl, n = new THREE.Bone(this), i.push(n), n.name = a.name, n.position.set(o[0], o[1], o[2]), n.quaternion.set(s[0], s[1], s[2], s[3]), void 0 !== h ? n.scale.set(h[0], h[1], h[2]) : n.scale.set(1, 1, 1); for (l = 0, c = this.geometry.bones.length; l < c; ++l)-1 !== (a = this.geometry.bones[l]).parent ? i[a.parent].add(i[l]) : this.add(i[l]) } this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(i, void 0, r)) }, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh, THREE.SkinnedMesh.prototype.bind = function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) }, THREE.SkinnedMesh.prototype.pose = function () { this.skeleton.pose() }, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () { if (this.geometry instanceof THREE.Geometry) for (var t = 0; t < this.geometry.skinIndices.length; t++) { var e = this.geometry.skinWeights[t], r = 1 / e.lengthManhattan(); r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1) } }, THREE.SkinnedMesh.prototype.updateMatrixWorld = function (t) { THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : THREE.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode) }, THREE.SkinnedMesh.prototype.clone = function (t) { return void 0 === t && (t = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), THREE.Mesh.prototype.clone.call(this, t), t }, THREE.MorphAnimMesh = function (t, e) { THREE.Mesh.call(this, t, e), this.type = "MorphAnimMesh", this.duration = 1e3, this.mirroredLoop = !1, this.time = 0, this.lastKeyframe = 0, this.currentKeyframe = 0, this.direction = 1, this.directionBackwards = !1, this.setFrameRange(0, this.geometry.morphTargets.length - 1) }, THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh, THREE.MorphAnimMesh.prototype.setFrameRange = function (t, e) { this.startKeyframe = t, this.endKeyframe = e, this.length = this.endKeyframe - this.startKeyframe + 1 }, THREE.MorphAnimMesh.prototype.setDirectionForward = function () { this.direction = 1, this.directionBackwards = !1 }, THREE.MorphAnimMesh.prototype.setDirectionBackward = function () { this.direction = -1, this.directionBackwards = !0 }, THREE.MorphAnimMesh.prototype.parseAnimations = function () { var t = this.geometry; t.animations || (t.animations = {}); for (var e, r = t.animations, i = /([a-z]+)_?(\d+)/, n = 0, a = t.morphTargets.length; n < a; n++) { var o = t.morphTargets[n].name.match(i); if (o && o.length > 1) { var s = o[1]; r[s] || (r[s] = { start: 1 / 0, end: -1 / 0 }); var h = r[s]; n < h.start && (h.start = n), n > h.end && (h.end = n), e || (e = s) } } t.firstAnimation = e }, THREE.MorphAnimMesh.prototype.setAnimationLabel = function (t, e, r) { this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[t] = { start: e, end: r } }, THREE.MorphAnimMesh.prototype.playAnimation = function (t, e) { var r = this.geometry.animations[t]; r ? (this.setFrameRange(r.start, r.end), this.duration = (r.end - r.start) / e * 1e3, this.time = 0) : THREE.warn("THREE.MorphAnimMesh: animation[" + t + "] undefined in .playAnimation()") }, THREE.MorphAnimMesh.prototype.updateAnimation = function (t) { var e = this.duration / this.length; this.time += this.direction * t, this.mirroredLoop ? (this.time > this.duration || this.time < 0) && (this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), this.time < 0 && (this.time = 0, this.directionBackwards = !1)) : (this.time = this.time % this.duration, this.time < 0 && (this.time += this.duration)); var r = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / e), 0, this.length - 1); r !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[r] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = r); var i = this.time % e / e; this.directionBackwards && (i = 1 - i), this.morphTargetInfluences[this.currentKeyframe] = i, this.morphTargetInfluences[this.lastKeyframe] = 1 - i }, THREE.MorphAnimMesh.prototype.interpolateTargets = function (t, e, r) { for (var i = this.morphTargetInfluences, n = 0, a = i.length; n < a; n++)i[n] = 0; t > -1 && (i[t] = 1 - r), e > -1 && (i[e] = r) }, THREE.MorphAnimMesh.prototype.clone = function (t) { return void 0 === t && (t = new THREE.MorphAnimMesh(this.geometry, this.material)), t.duration = this.duration, t.mirroredLoop = this.mirroredLoop, t.time = this.time, t.lastKeyframe = this.lastKeyframe, t.currentKeyframe = this.currentKeyframe, t.direction = this.direction, t.directionBackwards = this.directionBackwards, THREE.Mesh.prototype.clone.call(this, t), t }, THREE.LOD = function () { THREE.Object3D.call(this), this.objects = [] }, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.constructor = THREE.LOD, THREE.LOD.prototype.addLevel = function (t, e) { void 0 === e && (e = 0), e = Math.abs(e); for (var r = 0; r < this.objects.length && !(e < this.objects[r].distance); r++); this.objects.splice(r, 0, { distance: e, object: t }), this.add(t) }, THREE.LOD.prototype.getObjectForDistance = function (t) { for (var e = 1, r = this.objects.length; e < r && !(t < this.objects[e].distance); e++); return this.objects[e - 1].object }, THREE.LOD.prototype.raycast = function () { var t = new THREE.Vector3; return function (e, r) { t.setFromMatrixPosition(this.matrixWorld); var i = e.ray.origin.distanceTo(t); this.getObjectForDistance(i).raycast(e, r) } }(), THREE.LOD.prototype.update = function () { var t = new THREE.Vector3, e = new THREE.Vector3; return function (r) { if (this.objects.length > 1) { t.setFromMatrixPosition(r.matrixWorld), e.setFromMatrixPosition(this.matrixWorld); var i = t.distanceTo(e); this.objects[0].object.visible = !0; for (var n = 1, a = this.objects.length; n < a && i >= this.objects[n].distance; n++)this.objects[n - 1].object.visible = !1, this.objects[n].object.visible = !0; for (; n < a; n++)this.objects[n].object.visible = !1 } } }(), THREE.LOD.prototype.clone = function (t) { void 0 === t && (t = new THREE.LOD), THREE.Object3D.prototype.clone.call(this, t); for (var e = 0, r = this.objects.length; e < r; e++) { var i = this.objects[e].object.clone(); i.visible = 0 === e, t.addLevel(i, this.objects[e].distance) } return t }, THREE.Sprite = function () { var t = new Uint16Array([0, 1, 2, 0, 2, 3]), e = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]), r = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), i = new THREE.BufferGeometry; return i.addAttribute("index", new THREE.BufferAttribute(t, 1)), i.addAttribute("position", new THREE.BufferAttribute(e, 3)), i.addAttribute("uv", new THREE.BufferAttribute(r, 2)), function (t) { THREE.Object3D.call(this), this.type = "Sprite", this.geometry = i, this.material = void 0 !== t ? t : new THREE.SpriteMaterial } }(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.constructor = THREE.Sprite, THREE.Sprite.prototype.raycast = function () { var t = new THREE.Vector3; return function (e, r) { t.setFromMatrixPosition(this.matrixWorld); var i = e.ray.distanceToPoint(t); i > this.scale.x || r.push({ distance: i, point: this.position, face: null, object: this }) } }(), THREE.Sprite.prototype.clone = function (t) { return void 0 === t && (t = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, t), t }, THREE.Particle = THREE.Sprite, THREE.LensFlare = function (t, e, r, i, n) { THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3, this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, r, i, n) }, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.constructor = THREE.LensFlare, THREE.LensFlare.prototype.add = function (t, e, r, i, n, a) { void 0 === e && (e = -1), void 0 === r && (r = 0), void 0 === a && (a = 1), void 0 === n && (n = new THREE.Color(16777215)), void 0 === i && (i = THREE.NormalBlending), r = Math.min(r, Math.max(0, r)), this.lensFlares.push({ texture: t, size: e, distance: r, x: 0, y: 0, z: 0, scale: 1, rotation: 1, opacity: a, color: n, blending: i }) }, THREE.LensFlare.prototype.updateLensFlares = function () { var t, e, r = this.lensFlares.length, i = 2 * -this.positionScreen.x, n = 2 * -this.positionScreen.y; for (t = 0; t < r; t++)(e = this.lensFlares[t]).x = this.positionScreen.x + i * e.distance, e.y = this.positionScreen.y + n * e.distance, e.wantedRotation = e.x * Math.PI * .25, e.rotation += .25 * (e.wantedRotation - e.rotation) }, THREE.Scene = function () { THREE.Object3D.call(this), this.type = "Scene", this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0 }, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.constructor = THREE.Scene, THREE.Scene.prototype.clone = function (t) { return void 0 === t && (t = new THREE.Scene), THREE.Object3D.prototype.clone.call(this, t), null !== this.fog && (t.fog = this.fog.clone()), null !== this.overrideMaterial && (t.overrideMaterial = this.overrideMaterial.clone()), t.autoUpdate = this.autoUpdate, t.matrixAutoUpdate = this.matrixAutoUpdate, t }, THREE.Fog = function (t, e, r) { this.name = "", this.color = new THREE.Color(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== r ? r : 1e3 }, THREE.Fog.prototype.clone = function () { return new THREE.Fog(this.color.getHex(), this.near, this.far) }, THREE.FogExp2 = function (t, e) { this.name = "", this.color = new THREE.Color(t), this.density = void 0 !== e ? e : 25e-5 }, THREE.FogExp2.prototype.clone = function () { return new THREE.FogExp2(this.color.getHex(), this.density) }, THREE.ShaderChunk = {}, THREE.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n\tfloat distance = dot( planeNormal, point-pointOnPlane );\n\treturn point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\tif ( decayExponent > 0.0 ) {\n\t  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n\t}\n\treturn 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n\treturn a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n\treturn a;\n#endif\n}\n", THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n", THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n\tfloat dotProduct = dot( transformedNormal, dirVector );\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t#endif\n\n\t#endif\n\n\t#ifdef WRAP_AROUND\n\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n\t\t#endif\n\n\t#endif\n\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n\t#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\t\tlVector = normalize( lVector );\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n\t\t\tlVector = normalize( lVector );\n\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n\t\t\t#endif\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n\t\t#endif\n\n\t}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack += ambientLightColor;\n\n#endif\n", THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n\n#endif\n", THREE.ShaderChunk.default_vertex = "#ifdef USE_SKINNING\n\n\tvec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n\tvec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n", THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif", THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\t#ifdef USE_MORPHNORMALS\n\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n\t#else\n\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n\tuniform float logDepthBufFC;\n\n#endif", THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\n#endif", THREE.ShaderChunk.lights_phong_fragment = "#ifndef FLAT_SHADED\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n\t#endif\n\n#else\n\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\t\tlVector = normalize( lVector );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\ttotalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n\t\t\t\t// specular\n\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\ttotalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n\t\tlVector = normalize( lVector );\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\t// diffuse\n\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n\t\t\t#else\n\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t\t#endif\n\n\t\t\ttotalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n\t\t\t// specular\n\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n\t\t\ttotalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\t\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, dirVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\ttotalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n\t\t// specular\n\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n\t\t/*\n\t\t// fresnel term from skin shader\n\t\tconst float F0 = 0.128;\n\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\n\t\tfloat exponential = pow( base, 5.0 );\n\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\n\t\t*/\n\n\t\t/*\n\t\t// fresnel term from fresnel shader\n\t\tconst float mFresnelBias = 0.08;\n\t\tconst float mFresnelScale = 0.3;\n\t\tconst float mFresnelPower = 5.0;\n\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n\t\t*/\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\ttotalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\ttotalDiffuseLight += hemiColor;\n\n\t\t// specular (sky light)\n\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n\t\t// specular (ground light)\n\n\t\tvec3 lVectorGround = -lVector;\n\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n\t\ttotalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n\t}\n\n#endif\n\n#ifdef METAL\n\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n", THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n\n#endif", THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n\tvec3 morphedNormal = vec3( 0.0 );\n\n\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n\tmorphedNormal += normal;\n\n#endif", THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tuniform float refractionRatio;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif", THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n", THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n", THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\tuniform sampler2D lightMap;\n\n#endif", THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n\t}\n\n#endif", THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif", THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\n\n\tdiffuseColor *= texelColor;\n\n#endif", THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n\tvUv2 = uv2;\n\n#endif", THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n", THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n", THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n\tvColor.xyz = inputToLinear( color.xyz );\n\n#endif", THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n\t#ifdef USE_MORPHTARGETS\n\n\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n\t#else\n\n\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n#endif\n", THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvarying vec3 vReflect;\n\n\tuniform float refractionRatio;\n\n#endif\n", THREE.ShaderChunk.linear_to_gamma_fragment = "\n\toutgoingLight = linearToOutput( outgoingLight );\n", THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif", THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n", THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\n#endif\n", THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\n\tenvColor.xyz = inputToLinear( envColor.xyz );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif", THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n\t#endif\n\n#endif", THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif", THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif", THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t#else\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t#endif\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n\t\tfogFactor = whiteCompliment( fogFactor );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\n\t#endif\n\t\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif", THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n", THREE.ShaderChunk.defaultnormal_vertex = "#ifdef USE_SKINNING\n\n\tvec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n\tvec3 objectNormal = morphedNormal;\n\n#else\n\n\tvec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n\tobjectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n", THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n", THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif", THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif", THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n\toutgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif", THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif", THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif", THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n\tvec3 morphed = vec3( 0.0 );\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n\tmorphed += position;\n\n#endif", THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t#else\n\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n\t#ifdef SHADOWMAP_DEBUG\n\n\t\tvec3 frustumColors[3];\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n\t#endif\n\n\t#ifdef SHADOWMAP_CASCADE\n\n\t\tint inFrustumCount = 0;\n\n\t#endif\n\n\tfloat fDepth;\n\tvec3 shadowColor = vec3( 1.0 );\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\tinFrustumCount += int( inFrustum );\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n\t\t#else\n\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\t#endif\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\t\t\tshadow += 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tshadow /= 9.0;\n\n\t\t*/\n\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\n\n\t\t\t\tmat3 shadowKernel;\n\t\t\t\tmat3 depthKernel;\n\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\n\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n\t\t\t\tvec4 shadowValues;\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#else\n\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\tif ( fDepth < shadowCoord.z )\n\n\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n\t\t\t#endif\n\n\t\t}\n\n\n\t\t#ifdef SHADOWMAP_DEBUG\n\n\t\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n\t\t\t#else\n\n\t\t\t\tif ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t}\n\n\t// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n\tshadowColor = inputToLinear( shadowColor );\n\n\toutgoingLight = outgoingLight * shadowColor;\n\n#endif\n", THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n\t#ifdef USE_SKINNING\n\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\n\t#elif defined( USE_MORPHTARGETS )\n\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n\t#else\n\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\n\tuniform float shadowBias[ MAX_SHADOWS ];\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\tfloat depth = dot( rgba_depth, bit_shift );\n\t\treturn depth;\n\n\t}\n\n#endif", THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\t#extension GL_EXT_frag_depth : enable\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif", THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n", THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n", THREE.UniformsUtils = { merge: function (t) { for (var e = {}, r = 0; r < t.length; r++) { var i = this.clone(t[r]); for (var n in i) e[n] = i[n] } return e }, clone: function (t) { var e = {}; for (var r in t) for (var i in e[r] = {}, t[r]) { var n = t[r][i]; n instanceof THREE.Color || n instanceof THREE.Vector2 || n instanceof THREE.Vector3 || n instanceof THREE.Vector4 || n instanceof THREE.Matrix4 || n instanceof THREE.Texture ? e[r][i] = n.clone() : n instanceof Array ? e[r][i] = n.slice() : e[r][i] = n } return e } }, THREE.UniformsLib = { common: { diffuse: { type: "c", value: new THREE.Color(15658734) }, opacity: { type: "f", value: 1 }, map: { type: "t", value: null }, offsetRepeat: { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) }, lightMap: { type: "t", value: null }, specularMap: { type: "t", value: null }, alphaMap: { type: "t", value: null }, envMap: { type: "t", value: null }, flipEnvMap: { type: "f", value: -1 }, reflectivity: { type: "f", value: 1 }, refractionRatio: { type: "f", value: .98 }, morphTargetInfluences: { type: "f", value: 0 } }, bump: { bumpMap: { type: "t", value: null }, bumpScale: { type: "f", value: 1 } }, normalmap: { normalMap: { type: "t", value: null }, normalScale: { type: "v2", value: new THREE.Vector2(1, 1) } }, fog: { fogDensity: { type: "f", value: 25e-5 }, fogNear: { type: "f", value: 1 }, fogFar: { type: "f", value: 2e3 }, fogColor: { type: "c", value: new THREE.Color(16777215) } }, lights: { ambientLightColor: { type: "fv", value: [] }, directionalLightDirection: { type: "fv", value: [] }, directionalLightColor: { type: "fv", value: [] }, hemisphereLightDirection: { type: "fv", value: [] }, hemisphereLightSkyColor: { type: "fv", value: [] }, hemisphereLightGroundColor: { type: "fv", value: [] }, pointLightColor: { type: "fv", value: [] }, pointLightPosition: { type: "fv", value: [] }, pointLightDistance: { type: "fv1", value: [] }, pointLightDecay: { type: "fv1", value: [] }, spotLightColor: { type: "fv", value: [] }, spotLightPosition: { type: "fv", value: [] }, spotLightDirection: { type: "fv", value: [] }, spotLightDistance: { type: "fv1", value: [] }, spotLightAngleCos: { type: "fv1", value: [] }, spotLightExponent: { type: "fv1", value: [] }, spotLightDecay: { type: "fv1", value: [] } }, particle: { psColor: { type: "c", value: new THREE.Color(15658734) }, opacity: { type: "f", value: 1 }, size: { type: "f", value: 1 }, scale: { type: "f", value: 1 }, map: { type: "t", value: null }, offsetRepeat: { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) }, fogDensity: { type: "f", value: 25e-5 }, fogNear: { type: "f", value: 1 }, fogFar: { type: "f", value: 2e3 }, fogColor: { type: "c", value: new THREE.Color(16777215) } }, shadowmap: { shadowMap: { type: "tv", value: [] }, shadowMapSize: { type: "v2v", value: [] }, shadowBias: { type: "fv1", value: [] }, shadowDarkness: { type: "fv1", value: [] }, shadowMatrix: { type: "m4v", value: [] } } }, THREE.ShaderLib = { basic: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]), vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "\t#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "\t#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"), fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tvec3 outgoingLight = vec3( 0.0 );", "\tvec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "\toutgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n") }, lambert: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, { emissive: { type: "c", value: new THREE.Color(0) }, wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) } }]), vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "\tvarying vec3 vLightBack;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"), fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "\tvarying vec3 vLightBack;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tvec3 outgoingLight = vec3( 0.0 );", "\tvec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "\t#ifdef DOUBLE_SIDED", "\t\tif ( gl_FrontFacing )", "\t\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;", "\t\telse", "\t\t\toutgoingLight += diffuseColor.rgb * vLightBack + emissive;", "\t#else", "\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;", "\t#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n") }, phong: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, { emissive: { type: "c", value: new THREE.Color(0) }, specular: { type: "c", value: new THREE.Color(1118481) }, shininess: { type: "f", value: 30 }, wrapRGB: { type: "v3", value: new THREE.Vector3(1, 1, 1) } }]), vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "\tvarying vec3 vNormal;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED", "\tvNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "\tvViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"), fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tvec3 outgoingLight = vec3( 0.0 );", "\tvec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n") }, particle_basic: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]), vertexShader: ["uniform float size;", "uniform float scale;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "\t#ifdef USE_SIZEATTENUATION", "\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "\t#else", "\t\tgl_PointSize = size;", "\t#endif", "\tgl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"), fragmentShader: ["uniform vec3 psColor;", "uniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tvec3 outgoingLight = vec3( 0.0 );", "\tvec4 diffuseColor = vec4( psColor, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphatest_fragment, "\toutgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n") }, dashed: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, { scale: { type: "f", value: 1 }, dashSize: { type: "f", value: 1 }, totalSize: { type: "f", value: 2 } }]), vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvLineDistance = scale * lineDistance;", "\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "\tgl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tif ( mod( vLineDistance, totalSize ) > dashSize ) {", "\t\tdiscard;", "\t}", "\tvec3 outgoingLight = vec3( 0.0 );", "\tvec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, "\toutgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n") }, depth: { uniforms: { mNear: { type: "f", value: 1 }, mFar: { type: "f", value: 2e3 }, opacity: { type: "f", value: 1 } }, vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT", "\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;", "\t#else", "\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;", "\t#endif", "\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );", "\tgl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n") }, normal: { uniforms: { opacity: { type: "f", value: 1 } }, vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "\tvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n") }, cube: { uniforms: { tCube: { type: "t", value: null }, tFlip: { type: "f", value: -1 } }, vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "\tvWorldPosition = transformDirection( position, modelMatrix );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n") }, equirect: { uniforms: { tEquirect: { type: "t", value: null }, tFlip: { type: "f", value: -1 } }, vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", "\tvWorldPosition = transformDirection( position, modelMatrix );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: ["uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n") }, depthRGBA: { uniforms: {}, vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"), fragmentShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {", "\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "\tres -= res.xxyz * bit_mask;", "\treturn res;", "}", "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT", "\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "\t#else", "\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "\t#endif", "}"].join("\n") } }, THREE.WebGLRenderer = function (t) { console.log("THREE.WebGLRenderer", THREE.REVISION); var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElement("canvas"), r = void 0 !== t.context ? t.context : null, i = 1, n = void 0 !== t.precision ? t.precision : "highp", a = void 0 !== t.alpha && t.alpha, o = void 0 === t.depth || t.depth, s = void 0 === t.stencil || t.stencil, h = void 0 !== t.antialias && t.antialias, l = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, u = void 0 !== t.logarithmicDepthBuffer && t.logarithmicDepthBuffer, E = new THREE.Color(0), p = 0, f = [], d = {}, m = [], T = [], g = [], v = [], R = []; this.domElement = e, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.shadowMapEnabled = !1, this.shadowMapType = THREE.PCFShadowMap, this.shadowMapCullFace = THREE.CullFaceFront, this.shadowMapDebug = !1, this.shadowMapCascade = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0, this.info = { memory: { programs: 0, geometries: 0, textures: 0 }, render: { calls: 0, vertices: 0, faces: 0, points: 0 } }; var y, H = this, x = [], b = null, _ = null, w = -1, M = "", S = null, A = 0, C = 0, L = 0, P = e.width, F = e.height, U = 0, B = 0, D = new THREE.Frustum, V = new THREE.Matrix4, z = new THREE.Vector3, k = new THREE.Vector3, N = !0, O = { ambient: [0, 0, 0], directional: { length: 0, colors: [], positions: [] }, point: { length: 0, colors: [], positions: [], distances: [], decays: [] }, spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] }, hemi: { length: 0, skyColors: [], groundColors: [], positions: [] } }; try { var G = { alpha: a, depth: o, stencil: s, antialias: h, premultipliedAlpha: l, preserveDrawingBuffer: c }; if (null === (y = r || e.getContext("webgl", G) || e.getContext("experimental-webgl", G))) throw null !== e.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context."; e.addEventListener("webglcontextlost", function (t) { t.preventDefault(), q(), X(), d = {} }, !1) } catch (t) { THREE.error("THREE.WebGLRenderer: " + t) } var I = new THREE.WebGLState(y, ne); void 0 === y.getShaderPrecisionFormat && (y.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }); var W = new THREE.WebGLExtensions(y); W.get("OES_texture_float"), W.get("OES_texture_float_linear"), W.get("OES_texture_half_float"), W.get("OES_texture_half_float_linear"), W.get("OES_standard_derivatives"), u && W.get("EXT_frag_depth"); var j = function (t, e, r, i) { !0 === l && (t *= i, e *= i, r *= i), y.clearColor(t, e, r, i) }, X = function () { y.clearColor(0, 0, 0, 1), y.clearDepth(1), y.clearStencil(0), y.enable(y.DEPTH_TEST), y.depthFunc(y.LEQUAL), y.frontFace(y.CCW), y.cullFace(y.BACK), y.enable(y.CULL_FACE), y.enable(y.BLEND), y.blendEquation(y.FUNC_ADD), y.blendFunc(y.SRC_ALPHA, y.ONE_MINUS_SRC_ALPHA), y.viewport(C, L, P, F), j(E.r, E.g, E.b, p) }, q = function () { b = null, S = null, M = "", w = -1, N = !0, I.reset() }; X(), this.context = y, this.state = I; var Y, K = y.getParameter(y.MAX_TEXTURE_IMAGE_UNITS), Q = y.getParameter(y.MAX_VERTEX_TEXTURE_IMAGE_UNITS), Z = y.getParameter(y.MAX_TEXTURE_SIZE), J = y.getParameter(y.MAX_CUBE_MAP_TEXTURE_SIZE), $ = Q > 0, tt = $ && W.get("OES_texture_float"), et = y.getShaderPrecisionFormat(y.VERTEX_SHADER, y.HIGH_FLOAT), rt = y.getShaderPrecisionFormat(y.VERTEX_SHADER, y.MEDIUM_FLOAT), it = y.getShaderPrecisionFormat(y.FRAGMENT_SHADER, y.HIGH_FLOAT), nt = y.getShaderPrecisionFormat(y.FRAGMENT_SHADER, y.MEDIUM_FLOAT), at = function () { if (void 0 !== Y) return Y; if (Y = [], W.get("WEBGL_compressed_texture_pvrtc") || W.get("WEBGL_compressed_texture_s3tc")) for (var t = y.getParameter(y.COMPRESSED_TEXTURE_FORMATS), e = 0; e < t.length; e++)Y.push(t[e]); return Y }, ot = et.precision > 0 && it.precision > 0, st = rt.precision > 0 && nt.precision > 0; "highp" !== n || ot || (st ? (n = "mediump", THREE.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (n = "lowp", THREE.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp."))), "mediump" !== n || st || (n = "lowp", THREE.warn("THREE.WebGLRenderer: mediump not supported, using lowp.")); var ht, lt = new THREE.ShadowMapPlugin(this, f, d, m), ct = new THREE.SpritePlugin(this, v), ut = new THREE.LensFlarePlugin(this, R); function Et(t) { t.__webglVertexBuffer = y.createBuffer(), t.__webglNormalBuffer = y.createBuffer(), t.__webglTangentBuffer = y.createBuffer(), t.__webglColorBuffer = y.createBuffer(), t.__webglUVBuffer = y.createBuffer(), t.__webglUV2Buffer = y.createBuffer(), t.__webglSkinIndicesBuffer = y.createBuffer(), t.__webglSkinWeightsBuffer = y.createBuffer(), t.__webglFaceBuffer = y.createBuffer(), t.__webglLineBuffer = y.createBuffer(); var e = t.numMorphTargets; if (e) { t.__webglMorphTargetsBuffers = []; for (var r = 0, i = e; r < i; r++)t.__webglMorphTargetsBuffers.push(y.createBuffer()) } var n = t.numMorphNormals; if (n) { t.__webglMorphNormalsBuffers = []; for (r = 0, i = n; r < i; r++)t.__webglMorphNormalsBuffers.push(y.createBuffer()) } H.info.memory.geometries++ } this.getContext = function () { return y }, this.forceContextLoss = function () { W.get("WEBGL_lose_context").loseContext() }, this.supportsVertexTextures = function () { return $ }, this.supportsFloatTextures = function () { return W.get("OES_texture_float") }, this.supportsHalfFloatTextures = function () { return W.get("OES_texture_half_float") }, this.supportsStandardDerivatives = function () { return W.get("OES_standard_derivatives") }, this.supportsCompressedTextureS3TC = function () { return W.get("WEBGL_compressed_texture_s3tc") }, this.supportsCompressedTexturePVRTC = function () { return W.get("WEBGL_compressed_texture_pvrtc") }, this.supportsBlendMinMax = function () { return W.get("EXT_blend_minmax") }, this.getMaxAnisotropy = function () { if (void 0 !== ht) return ht; var t = W.get("EXT_texture_filter_anisotropic"); return ht = null !== t ? y.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, this.getPrecision = function () { return n }, this.getPixelRatio = function () { return i }, this.setPixelRatio = function (t) { i = t }, this.setSize = function (t, r, n) { e.width = t * i, e.height = r * i, !1 !== n && (e.style.width = t + "px", e.style.height = r + "px"), this.setViewport(0, 0, t, r) }, this.setViewport = function (t, e, r, n) { C = t * i, L = e * i, P = r * i, F = n * i, y.viewport(C, L, P, F) }, this.setScissor = function (t, e, r, n) { y.scissor(t * i, e * i, r * i, n * i) }, this.enableScissorTest = function (t) { t ? y.enable(y.SCISSOR_TEST) : y.disable(y.SCISSOR_TEST) }, this.getClearColor = function () { return E }, this.setClearColor = function (t, e) { E.set(t), p = void 0 !== e ? e : 1, j(E.r, E.g, E.b, p) }, this.getClearAlpha = function () { return p }, this.setClearAlpha = function (t) { p = t, j(E.r, E.g, E.b, p) }, this.clear = function (t, e, r) { var i = 0; (void 0 === t || t) && (i |= y.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= y.DEPTH_BUFFER_BIT), (void 0 === r || r) && (i |= y.STENCIL_BUFFER_BIT), y.clear(i) }, this.clearColor = function () { y.clear(y.COLOR_BUFFER_BIT) }, this.clearDepth = function () { y.clear(y.DEPTH_BUFFER_BIT) }, this.clearStencil = function () { y.clear(y.STENCIL_BUFFER_BIT) }, this.clearTarget = function (t, e, r, i) { this.setRenderTarget(t), this.clear(e, r, i) }, this.resetGLState = q; var pt = function (t) { t.target.traverse(function (t) { t.removeEventListener("remove", pt), function (t) { t instanceof THREE.Mesh || t instanceof THREE.PointCloud || t instanceof THREE.Line ? delete d[t.id] : (t instanceof THREE.ImmediateRenderObject || t.immediateRenderCallback) && function (t, e) { for (var r = t.length - 1; r >= 0; r--)t[r].object === e && t.splice(r, 1) }(m, t); delete t.__webglInit, delete t._modelViewMatrix, delete t._normalMatrix, delete t.__webglActive }(t) }) }, ft = function (t) { var e = t.target; e.removeEventListener("dispose", ft), vt(e) }, dt = function (t) { var e = t.target; e.removeEventListener("dispose", dt), Rt(e), H.info.memory.textures-- }, mt = function (t) { var e = t.target; e.removeEventListener("dispose", mt), yt(e), H.info.memory.textures-- }, Tt = function (t) { var e = t.target; e.removeEventListener("dispose", Tt), Ht(e) }, gt = function (t) { for (var e = ["__webglVertexBuffer", "__webglNormalBuffer", "__webglTangentBuffer", "__webglColorBuffer", "__webglUVBuffer", "__webglUV2Buffer", "__webglSkinIndicesBuffer", "__webglSkinWeightsBuffer", "__webglFaceBuffer", "__webglLineBuffer", "__webglLineDistanceBuffer"], r = 0, i = e.length; r < i; r++) { void 0 !== t[n = e[r]] && (y.deleteBuffer(t[n]), delete t[n]) } if (void 0 !== t.__webglCustomAttributesList) { for (var n in t.__webglCustomAttributesList) y.deleteBuffer(t.__webglCustomAttributesList[n].buffer); delete t.__webglCustomAttributesList } H.info.memory.geometries-- }, vt = function (t) { if (delete t.__webglInit, t instanceof THREE.BufferGeometry) { for (var e in t.attributes) { var r = t.attributes[e]; void 0 !== r.buffer && (y.deleteBuffer(r.buffer), delete r.buffer) } H.info.memory.geometries-- } else { var i = Bt[t.id]; if (void 0 !== i) { for (var n = 0, a = i.length; n < a; n++) { var o = i[n]; if (void 0 !== o.numMorphTargets) { for (var s = 0, h = o.numMorphTargets; s < h; s++)y.deleteBuffer(o.__webglMorphTargetsBuffers[s]); delete o.__webglMorphTargetsBuffers } if (void 0 !== o.numMorphNormals) { for (s = 0, h = o.numMorphNormals; s < h; s++)y.deleteBuffer(o.__webglMorphNormalsBuffers[s]); delete o.__webglMorphNormalsBuffers } gt(o) } delete Bt[t.id] } else gt(t) } M = "" }, Rt = function (t) { if (t.image && t.image.__webglTextureCube) y.deleteTexture(t.image.__webglTextureCube), delete t.image.__webglTextureCube; else { if (void 0 === t.__webglInit) return; y.deleteTexture(t.__webglTexture), delete t.__webglTexture, delete t.__webglInit } }, yt = function (t) { if (t && void 0 !== t.__webglTexture) { if (y.deleteTexture(t.__webglTexture), delete t.__webglTexture, t instanceof THREE.WebGLRenderTargetCube) for (var e = 0; e < 6; e++)y.deleteFramebuffer(t.__webglFramebuffer[e]), y.deleteRenderbuffer(t.__webglRenderbuffer[e]); else y.deleteFramebuffer(t.__webglFramebuffer), y.deleteRenderbuffer(t.__webglRenderbuffer); delete t.__webglFramebuffer, delete t.__webglRenderbuffer } }, Ht = function (t) { var e = t.program.program; if (void 0 !== e) { var r, i, n; t.program = void 0; var a = !1; for (r = 0, i = x.length; r < i; r++)if ((n = x[r]).program === e) { n.usedTimes-- , 0 === n.usedTimes && (a = !0); break } if (!0 === a) { var o = []; for (r = 0, i = x.length; r < i; r++)(n = x[r]).program !== e && o.push(n); x = o, y.deleteProgram(e), H.info.memory.programs-- } } }; function xt(t) { var e = t.geometry, r = t.material, i = e.vertices.length; if (r.attributes) for (var n in void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []), r.attributes) { var a = r.attributes[n]; if (!a.__webglInitialized || a.createUniqueBuffers) { a.__webglInitialized = !0; var o = 1; "v2" === a.type ? o = 2 : "v3" === a.type ? o = 3 : "v4" === a.type ? o = 4 : "c" === a.type && (o = 3), a.size = o, a.array = new Float32Array(i * o), a.buffer = y.createBuffer(), a.buffer.belongsToAttribute = n, a.needsUpdate = !0 } e.__webglCustomAttributesList.push(a) } } function bt(t, e) { var r = e.geometry, i = t.faces3, n = 3 * i.length, a = 1 * i.length, o = 3 * i.length, s = _t(e, t); t.__vertexArray = new Float32Array(3 * n), t.__normalArray = new Float32Array(3 * n), t.__colorArray = new Float32Array(3 * n), t.__uvArray = new Float32Array(2 * n), r.faceVertexUvs.length > 1 && (t.__uv2Array = new Float32Array(2 * n)), r.hasTangents && (t.__tangentArray = new Float32Array(4 * n)), e.geometry.skinWeights.length && e.geometry.skinIndices.length && (t.__skinIndexArray = new Float32Array(4 * n), t.__skinWeightArray = new Float32Array(4 * n)); var h = null !== W.get("OES_element_index_uint") && a > 21845 ? Uint32Array : Uint16Array; t.__typeArray = h, t.__faceArray = new h(3 * a), t.__lineArray = new h(2 * o); var l = t.numMorphTargets; if (l) { t.__morphTargetsArrays = []; for (var c = 0, u = l; c < u; c++)t.__morphTargetsArrays.push(new Float32Array(3 * n)) } var E = t.numMorphNormals; if (E) { t.__morphNormalsArrays = []; for (c = 0, u = E; c < u; c++)t.__morphNormalsArrays.push(new Float32Array(3 * n)) } if (t.__webglFaceCount = 3 * a, t.__webglLineCount = 2 * o, s.attributes) for (var p in void 0 === t.__webglCustomAttributesList && (t.__webglCustomAttributesList = []), s.attributes) { var f = s.attributes[p], d = {}; for (var m in f) d[m] = f[m]; if (!d.__webglInitialized || d.createUniqueBuffers) { d.__webglInitialized = !0; var T = 1; "v2" === d.type ? T = 2 : "v3" === d.type ? T = 3 : "v4" === d.type ? T = 4 : "c" === d.type && (T = 3), d.size = T, d.array = new Float32Array(n * T), d.buffer = y.createBuffer(), d.buffer.belongsToAttribute = p, f.needsUpdate = !0, d.__original = f } t.__webglCustomAttributesList.push(d) } t.__inittedArrays = !0 } function _t(t, e) { return t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[e.materialIndex] : t.material } function wt(t, e, r, i, n) { if (t.__inittedArrays) { var a, o, s, h, l, c, u, E, p, f, d, m, T, g, v, R, H, x, b, _, w, M, S, A, C, L, P, F, U, B, D, V, z, k, N, O, G, I, W, j, X, q = function (t) { return t instanceof THREE.MeshPhongMaterial == 0 && t.shading === THREE.FlatShading }(n), Y = 0, K = 0, Q = 0, Z = 0, J = 0, $ = 0, tt = 0, et = 0, rt = 0, it = 0, nt = 0, at = 0, ot = t.__vertexArray, st = t.__uvArray, ht = t.__uv2Array, lt = t.__normalArray, ct = t.__tangentArray, ut = t.__colorArray, Et = t.__skinIndexArray, pt = t.__skinWeightArray, ft = t.__morphTargetsArrays, dt = t.__morphNormalsArrays, mt = t.__webglCustomAttributesList, Tt = t.__faceArray, gt = t.__lineArray, vt = e.geometry, Rt = vt.verticesNeedUpdate, yt = vt.elementsNeedUpdate, Ht = vt.uvsNeedUpdate, xt = vt.normalsNeedUpdate, bt = vt.tangentsNeedUpdate, _t = vt.colorsNeedUpdate, wt = vt.morphTargetsNeedUpdate, Mt = vt.vertices, St = t.faces3, At = vt.faces, Ct = vt.faceVertexUvs[0], Lt = vt.faceVertexUvs[1], Pt = vt.skinIndices, Ft = vt.skinWeights, Ut = vt.morphTargets, Bt = vt.morphNormals; if (Rt) { for (a = 0, o = St.length; a < o; a++)d = Mt[(s = At[St[a]]).a], m = Mt[s.b], T = Mt[s.c], ot[K] = d.x, ot[K + 1] = d.y, ot[K + 2] = d.z, ot[K + 3] = m.x, ot[K + 4] = m.y, ot[K + 5] = m.z, ot[K + 6] = T.x, ot[K + 7] = T.y, ot[K + 8] = T.z, K += 9; y.bindBuffer(y.ARRAY_BUFFER, t.__webglVertexBuffer), y.bufferData(y.ARRAY_BUFFER, ot, r) } if (wt) for (k = 0, N = Ut.length; k < N; k++) { for (nt = 0, a = 0, o = St.length; a < o; a++)s = At[I = St[a]], d = Ut[k].vertices[s.a], m = Ut[k].vertices[s.b], T = Ut[k].vertices[s.c], (O = ft[k])[nt] = d.x, O[nt + 1] = d.y, O[nt + 2] = d.z, O[nt + 3] = m.x, O[nt + 4] = m.y, O[nt + 5] = m.z, O[nt + 6] = T.x, O[nt + 7] = T.y, O[nt + 8] = T.z, n.morphNormals && (q ? (x = H = Bt[k].faceNormals[I], b = H) : (H = (W = Bt[k].vertexNormals[I]).a, x = W.b, b = W.c), (G = dt[k])[nt] = H.x, G[nt + 1] = H.y, G[nt + 2] = H.z, G[nt + 3] = x.x, G[nt + 4] = x.y, G[nt + 5] = x.z, G[nt + 6] = b.x, G[nt + 7] = b.y, G[nt + 8] = b.z), nt += 9; y.bindBuffer(y.ARRAY_BUFFER, t.__webglMorphTargetsBuffers[k]), y.bufferData(y.ARRAY_BUFFER, ft[k], r), n.morphNormals && (y.bindBuffer(y.ARRAY_BUFFER, t.__webglMorphNormalsBuffers[k]), y.bufferData(y.ARRAY_BUFFER, dt[k], r)) } if (Ft.length) { for (a = 0, o = St.length; a < o; a++)S = Ft[(s = At[St[a]]).a], A = Ft[s.b], C = Ft[s.c], pt[it] = S.x, pt[it + 1] = S.y, pt[it + 2] = S.z, pt[it + 3] = S.w, pt[it + 4] = A.x, pt[it + 5] = A.y, pt[it + 6] = A.z, pt[it + 7] = A.w, pt[it + 8] = C.x, pt[it + 9] = C.y, pt[it + 10] = C.z, pt[it + 11] = C.w, L = Pt[s.a], P = Pt[s.b], F = Pt[s.c], Et[it] = L.x, Et[it + 1] = L.y, Et[it + 2] = L.z, Et[it + 3] = L.w, Et[it + 4] = P.x, Et[it + 5] = P.y, Et[it + 6] = P.z, Et[it + 7] = P.w, Et[it + 8] = F.x, Et[it + 9] = F.y, Et[it + 10] = F.z, Et[it + 11] = F.w, it += 12; it > 0 && (y.bindBuffer(y.ARRAY_BUFFER, t.__webglSkinIndicesBuffer), y.bufferData(y.ARRAY_BUFFER, Et, r), y.bindBuffer(y.ARRAY_BUFFER, t.__webglSkinWeightsBuffer), y.bufferData(y.ARRAY_BUFFER, pt, r)) } if (_t) { for (a = 0, o = St.length; a < o; a++)c = (s = At[St[a]]).vertexColors, u = s.color, 3 === c.length && n.vertexColors === THREE.VertexColors ? (_ = c[0], w = c[1], M = c[2]) : (_ = u, w = u, M = u), ut[rt] = _.r, ut[rt + 1] = _.g, ut[rt + 2] = _.b, ut[rt + 3] = w.r, ut[rt + 4] = w.g, ut[rt + 5] = w.b, ut[rt + 6] = M.r, ut[rt + 7] = M.g, ut[rt + 8] = M.b, rt += 9; rt > 0 && (y.bindBuffer(y.ARRAY_BUFFER, t.__webglColorBuffer), y.bufferData(y.ARRAY_BUFFER, ut, r)) } if (bt && vt.hasTangents) { for (a = 0, o = St.length; a < o; a++)g = (E = (s = At[St[a]]).vertexTangents)[0], v = E[1], R = E[2], ct[tt] = g.x, ct[tt + 1] = g.y, ct[tt + 2] = g.z, ct[tt + 3] = g.w, ct[tt + 4] = v.x, ct[tt + 5] = v.y, ct[tt + 6] = v.z, ct[tt + 7] = v.w, ct[tt + 8] = R.x, ct[tt + 9] = R.y, ct[tt + 10] = R.z, ct[tt + 11] = R.w, tt += 12; y.bindBuffer(y.ARRAY_BUFFER, t.__webglTangentBuffer), y.bufferData(y.ARRAY_BUFFER, ct, r) } if (xt) { for (a = 0, o = St.length; a < o; a++)if (h = (s = At[St[a]]).vertexNormals, l = s.normal, 3 === h.length && !1 === q) for (U = 0; U < 3; U++)D = h[U], lt[$] = D.x, lt[$ + 1] = D.y, lt[$ + 2] = D.z, $ += 3; else for (U = 0; U < 3; U++)lt[$] = l.x, lt[$ + 1] = l.y, lt[$ + 2] = l.z, $ += 3; y.bindBuffer(y.ARRAY_BUFFER, t.__webglNormalBuffer), y.bufferData(y.ARRAY_BUFFER, lt, r) } if (Ht && Ct) { for (a = 0, o = St.length; a < o; a++)if (void 0 !== (p = Ct[St[a]])) for (U = 0; U < 3; U++)V = p[U], st[Q] = V.x, st[Q + 1] = V.y, Q += 2; Q > 0 && (y.bindBuffer(y.ARRAY_BUFFER, t.__webglUVBuffer), y.bufferData(y.ARRAY_BUFFER, st, r)) } if (Ht && Lt) { for (a = 0, o = St.length; a < o; a++)if (void 0 !== (f = Lt[St[a]])) for (U = 0; U < 3; U++)z = f[U], ht[Z] = z.x, ht[Z + 1] = z.y, Z += 2; Z > 0 && (y.bindBuffer(y.ARRAY_BUFFER, t.__webglUV2Buffer), y.bufferData(y.ARRAY_BUFFER, ht, r)) } if (yt) { for (a = 0, o = St.length; a < o; a++)Tt[J] = Y, Tt[J + 1] = Y + 1, Tt[J + 2] = Y + 2, J += 3, gt[et] = Y, gt[et + 1] = Y + 1, gt[et + 2] = Y, gt[et + 3] = Y + 2, gt[et + 4] = Y + 1, gt[et + 5] = Y + 2, et += 6, Y += 3; y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, t.__webglFaceBuffer), y.bufferData(y.ELEMENT_ARRAY_BUFFER, Tt, r), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, t.__webglLineBuffer), y.bufferData(y.ELEMENT_ARRAY_BUFFER, gt, r) } if (mt) for (U = 0, B = mt.length; U < B; U++)if ((X = mt[U]).__original.needsUpdate) { if (at = 0, 1 === X.size) { if (void 0 === X.boundTo || "vertices" === X.boundTo) for (a = 0, o = St.length; a < o; a++)s = At[St[a]], X.array[at] = X.value[s.a], X.array[at + 1] = X.value[s.b], X.array[at + 2] = X.value[s.c], at += 3; else if ("faces" === X.boundTo) for (a = 0, o = St.length; a < o; a++)j = X.value[St[a]], X.array[at] = j, X.array[at + 1] = j, X.array[at + 2] = j, at += 3 } else if (2 === X.size) { if (void 0 === X.boundTo || "vertices" === X.boundTo) for (a = 0, o = St.length; a < o; a++)s = At[St[a]], d = X.value[s.a], m = X.value[s.b], T = X.value[s.c], X.array[at] = d.x, X.array[at + 1] = d.y, X.array[at + 2] = m.x, X.array[at + 3] = m.y, X.array[at + 4] = T.x, X.array[at + 5] = T.y, at += 6; else if ("faces" === X.boundTo) for (a = 0, o = St.length; a < o; a++)d = j = X.value[St[a]], m = j, T = j, X.array[at] = d.x, X.array[at + 1] = d.y, X.array[at + 2] = m.x, X.array[at + 3] = m.y, X.array[at + 4] = T.x, X.array[at + 5] = T.y, at += 6 } else if (3 === X.size) { var Dt; if (Dt = "c" === X.type ? ["r", "g", "b"] : ["x", "y", "z"], void 0 === X.boundTo || "vertices" === X.boundTo) for (a = 0, o = St.length; a < o; a++)s = At[St[a]], d = X.value[s.a], m = X.value[s.b], T = X.value[s.c], X.array[at] = d[Dt[0]], X.array[at + 1] = d[Dt[1]], X.array[at + 2] = d[Dt[2]], X.array[at + 3] = m[Dt[0]], X.array[at + 4] = m[Dt[1]], X.array[at + 5] = m[Dt[2]], X.array[at + 6] = T[Dt[0]], X.array[at + 7] = T[Dt[1]], X.array[at + 8] = T[Dt[2]], at += 9; else if ("faces" === X.boundTo) for (a = 0, o = St.length; a < o; a++)d = j = X.value[St[a]], m = j, T = j, X.array[at] = d[Dt[0]], X.array[at + 1] = d[Dt[1]], X.array[at + 2] = d[Dt[2]], X.array[at + 3] = m[Dt[0]], X.array[at + 4] = m[Dt[1]], X.array[at + 5] = m[Dt[2]], X.array[at + 6] = T[Dt[0]], X.array[at + 7] = T[Dt[1]], X.array[at + 8] = T[Dt[2]], at += 9; else if ("faceVertices" === X.boundTo) for (a = 0, o = St.length; a < o; a++)d = (j = X.value[St[a]])[0], m = j[1], T = j[2], X.array[at] = d[Dt[0]], X.array[at + 1] = d[Dt[1]], X.array[at + 2] = d[Dt[2]], X.array[at + 3] = m[Dt[0]], X.array[at + 4] = m[Dt[1]], X.array[at + 5] = m[Dt[2]], X.array[at + 6] = T[Dt[0]], X.array[at + 7] = T[Dt[1]], X.array[at + 8] = T[Dt[2]], at += 9 } else if (4 === X.size) if (void 0 === X.boundTo || "vertices" === X.boundTo) for (a = 0, o = St.length; a < o; a++)s = At[St[a]], d = X.value[s.a], m = X.value[s.b], T = X.value[s.c], X.array[at] = d.x, X.array[at + 1] = d.y, X.array[at + 2] = d.z, X.array[at + 3] = d.w, X.array[at + 4] = m.x, X.array[at + 5] = m.y, X.array[at + 6] = m.z, X.array[at + 7] = m.w, X.array[at + 8] = T.x, X.array[at + 9] = T.y, X.array[at + 10] = T.z, X.array[at + 11] = T.w, at += 12; else if ("faces" === X.boundTo) for (a = 0, o = St.length; a < o; a++)d = j = X.value[St[a]], m = j, T = j, X.array[at] = d.x, X.array[at + 1] = d.y, X.array[at + 2] = d.z, X.array[at + 3] = d.w, X.array[at + 4] = m.x, X.array[at + 5] = m.y, X.array[at + 6] = m.z, X.array[at + 7] = m.w, X.array[at + 8] = T.x, X.array[at + 9] = T.y, X.array[at + 10] = T.z, X.array[at + 11] = T.w, at += 12; else if ("faceVertices" === X.boundTo) for (a = 0, o = St.length; a < o; a++)d = (j = X.value[St[a]])[0], m = j[1], T = j[2], X.array[at] = d.x, X.array[at + 1] = d.y, X.array[at + 2] = d.z, X.array[at + 3] = d.w, X.array[at + 4] = m.x, X.array[at + 5] = m.y, X.array[at + 6] = m.z, X.array[at + 7] = m.w, X.array[at + 8] = T.x, X.array[at + 9] = T.y, X.array[at + 10] = T.z, X.array[at + 11] = T.w, at += 12; y.bindBuffer(y.ARRAY_BUFFER, X.buffer), y.bufferData(y.ARRAY_BUFFER, X.array, r) } i && (delete t.__inittedArrays, delete t.__colorArray, delete t.__normalArray, delete t.__tangentArray, delete t.__uvArray, delete t.__uv2Array, delete t.__faceArray, delete t.__vertexArray, delete t.__lineArray, delete t.__skinIndexArray, delete t.__skinWeightArray) } } function Mt(t, e, r, i) { for (var n = r.attributes, a = e.attributes, o = e.attributesKeys, s = 0, h = o.length; s < h; s++) { var l = o[s], c = a[l]; if (c >= 0) { var u = n[l]; if (void 0 !== u) { var E = u.itemSize; y.bindBuffer(y.ARRAY_BUFFER, u.buffer), I.enableAttribute(c), y.vertexAttribPointer(c, E, y.FLOAT, !1, 0, i * E * 4) } else void 0 !== t.defaultAttributeValues && (2 === t.defaultAttributeValues[l].length ? y.vertexAttrib2fv(c, t.defaultAttributeValues[l]) : 3 === t.defaultAttributeValues[l].length && y.vertexAttrib3fv(c, t.defaultAttributeValues[l])) } } I.disableUnusedAttributes() } function St(t, e) { return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function At(t, e) { return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function Ct(t, e) { return e[0] - t[0] } function Lt(t, e, r, i, n) { for (var a, o = 0, s = t.length; o < s; o++) { var h = t[o], l = h.object, c = h.buffer; if (Kt(l, e), n) a = n; else { if (!(a = h.material)) continue; Wt(a) } H.setMaterialFaces(a), c instanceof THREE.BufferGeometry ? H.renderBufferDirect(e, r, i, a, c, l) : H.renderBuffer(e, r, i, a, c, l) } } function Pt(t, e, r, i, n, a) { for (var o, s = 0, h = t.length; s < h; s++) { var l = t[s], c = l.object; if (c.visible) { if (a) o = a; else { if (!(o = l[e])) continue; Wt(o) } H.renderImmediateObject(r, i, n, o, c) } } } function Ft(t) { var e = t.object.material; e.transparent ? (t.transparent = e, t.opaque = null) : (t.opaque = e, t.transparent = null) } function Ut(t) { var e = t.object, r = t.buffer, i = e.geometry, n = e.material; if (n instanceof THREE.MeshFaceMaterial) { var a = i instanceof THREE.BufferGeometry ? 0 : r.materialIndex; n = n.materials[a], t.material = n, n.transparent ? g.push(t) : T.push(t) } else n && (t.material = n, n.transparent ? g.push(t) : T.push(t)) } this.renderBufferImmediate = function (t, e, r) { if (I.initAttributes(), t.hasPositions && !t.__webglVertexBuffer && (t.__webglVertexBuffer = y.createBuffer()), t.hasNormals && !t.__webglNormalBuffer && (t.__webglNormalBuffer = y.createBuffer()), t.hasUvs && !t.__webglUvBuffer && (t.__webglUvBuffer = y.createBuffer()), t.hasColors && !t.__webglColorBuffer && (t.__webglColorBuffer = y.createBuffer()), t.hasPositions && (y.bindBuffer(y.ARRAY_BUFFER, t.__webglVertexBuffer), y.bufferData(y.ARRAY_BUFFER, t.positionArray, y.DYNAMIC_DRAW), I.enableAttribute(e.attributes.position), y.vertexAttribPointer(e.attributes.position, 3, y.FLOAT, !1, 0, 0)), t.hasNormals) { if (y.bindBuffer(y.ARRAY_BUFFER, t.__webglNormalBuffer), r instanceof THREE.MeshPhongMaterial == !1 && r.shading === THREE.FlatShading) { var i, n, a, o, s, h, l, c, u, E, p, f = 3 * t.count; for (p = 0; p < f; p += 9)o = (E = t.normalArray)[p], h = E[p + 1], c = E[p + 2], s = E[p + 3], l = E[p + 4], u = E[p + 5], i = (o + s + E[p + 6]) / 3, n = (h + l + E[p + 7]) / 3, a = (c + u + E[p + 8]) / 3, E[p] = i, E[p + 1] = n, E[p + 2] = a, E[p + 3] = i, E[p + 4] = n, E[p + 5] = a, E[p + 6] = i, E[p + 7] = n, E[p + 8] = a } y.bufferData(y.ARRAY_BUFFER, t.normalArray, y.DYNAMIC_DRAW), I.enableAttribute(e.attributes.normal), y.vertexAttribPointer(e.attributes.normal, 3, y.FLOAT, !1, 0, 0) } t.hasUvs && r.map && (y.bindBuffer(y.ARRAY_BUFFER, t.__webglUvBuffer), y.bufferData(y.ARRAY_BUFFER, t.uvArray, y.DYNAMIC_DRAW), I.enableAttribute(e.attributes.uv), y.vertexAttribPointer(e.attributes.uv, 2, y.FLOAT, !1, 0, 0)), t.hasColors && r.vertexColors !== THREE.NoColors && (y.bindBuffer(y.ARRAY_BUFFER, t.__webglColorBuffer), y.bufferData(y.ARRAY_BUFFER, t.colorArray, y.DYNAMIC_DRAW), I.enableAttribute(e.attributes.color), y.vertexAttribPointer(e.attributes.color, 3, y.FLOAT, !1, 0, 0)), I.disableUnusedAttributes(), y.drawArrays(y.TRIANGLES, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, r, n, a, o) { if (!1 !== n.visible) { kt(o); var s = jt(t, e, r, n, o), h = !1, l = n.wireframe ? 1 : 0, c = "direct_" + a.id + "_" + s.id + "_" + l; if (c !== M && (M = c, h = !0), h && I.initAttributes(), o instanceof THREE.Mesh) { var u = !0 === n.wireframe ? y.LINES : y.TRIANGLES; if (m = a.attributes.index) { if (m.array instanceof Uint32Array && W.get("OES_element_index_uint") ? (T = y.UNSIGNED_INT, g = 4) : (T = y.UNSIGNED_SHORT, g = 2), 0 === (v = a.offsets).length) h && (Mt(n, s, a, 0), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, m.buffer)), y.drawElements(u, m.array.length, T, 0), H.info.render.calls++ , H.info.render.vertices += m.array.length, H.info.render.faces += m.array.length / 3; else { h = !0; for (var E = 0, p = v.length; E < p; E++) { var f = v[E].index; h && (Mt(n, s, a, f), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, m.buffer)), y.drawElements(u, v[E].count, T, v[E].start * g), H.info.render.calls++ , H.info.render.vertices += v[E].count, H.info.render.faces += v[E].count / 3 } } } else { h && Mt(n, s, a, 0); var d = a.attributes.position; y.drawArrays(u, 0, d.array.length / d.itemSize), H.info.render.calls++ , H.info.render.vertices += d.array.length / d.itemSize, H.info.render.faces += d.array.length / (3 * d.itemSize) } } else if (o instanceof THREE.PointCloud) { u = y.POINTS; if (m = a.attributes.index) { if (m.array instanceof Uint32Array && W.get("OES_element_index_uint") ? (T = y.UNSIGNED_INT, g = 4) : (T = y.UNSIGNED_SHORT, g = 2), 0 === (v = a.offsets).length) h && (Mt(n, s, a, 0), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, m.buffer)), y.drawElements(u, m.array.length, T, 0), H.info.render.calls++ , H.info.render.points += m.array.length; else { v.length > 1 && (h = !0); for (E = 0, p = v.length; E < p; E++) { f = v[E].index; h && (Mt(n, s, a, f), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, m.buffer)), y.drawElements(u, v[E].count, T, v[E].start * g), H.info.render.calls++ , H.info.render.points += v[E].count } } } else { h && Mt(n, s, a, 0); d = a.attributes.position; if (0 === (v = a.offsets).length) y.drawArrays(u, 0, d.array.length / 3), H.info.render.calls++ , H.info.render.points += d.array.length / 3; else for (E = 0, p = v.length; E < p; E++)y.drawArrays(u, v[E].index, v[E].count), H.info.render.calls++ , H.info.render.points += v[E].count } } else if (o instanceof THREE.Line) { var m; u = o.mode === THREE.LineStrip ? y.LINE_STRIP : y.LINES; if (I.setLineWidth(n.linewidth * i), m = a.attributes.index) { var T, g; if (m.array instanceof Uint32Array ? (T = y.UNSIGNED_INT, g = 4) : (T = y.UNSIGNED_SHORT, g = 2), 0 === (v = a.offsets).length) h && (Mt(n, s, a, 0), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, m.buffer)), y.drawElements(u, m.array.length, T, 0), H.info.render.calls++ , H.info.render.vertices += m.array.length; else { v.length > 1 && (h = !0); for (E = 0, p = v.length; E < p; E++) { f = v[E].index; h && (Mt(n, s, a, f), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, m.buffer)), y.drawElements(u, v[E].count, T, v[E].start * g), H.info.render.calls++ , H.info.render.vertices += v[E].count } } } else { h && Mt(n, s, a, 0); var v; d = a.attributes.position; if (0 === (v = a.offsets).length) y.drawArrays(u, 0, d.array.length / 3), H.info.render.calls++ , H.info.render.vertices += d.array.length / 3; else for (E = 0, p = v.length; E < p; E++)y.drawArrays(u, v[E].index, v[E].count), H.info.render.calls++ , H.info.render.vertices += v[E].count } } } }, this.renderBuffer = function (t, e, r, n, a, o) { if (!1 !== n.visible) { kt(o); var s = jt(t, e, r, n, o), h = s.attributes, l = !1, c = n.wireframe ? 1 : 0, u = a.id + "_" + s.id + "_" + c; if (u !== M && (M = u, l = !0), l && I.initAttributes(), !n.morphTargets && h.position >= 0 ? l && (y.bindBuffer(y.ARRAY_BUFFER, a.__webglVertexBuffer), I.enableAttribute(h.position), y.vertexAttribPointer(h.position, 3, y.FLOAT, !1, 0, 0)) : o.morphTargetBase && function (t, e, r) { var i = t.program.attributes; -1 !== r.morphTargetBase && i.position >= 0 ? (y.bindBuffer(y.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[r.morphTargetBase]), I.enableAttribute(i.position), y.vertexAttribPointer(i.position, 3, y.FLOAT, !1, 0, 0)) : i.position >= 0 && (y.bindBuffer(y.ARRAY_BUFFER, e.__webglVertexBuffer), I.enableAttribute(i.position), y.vertexAttribPointer(i.position, 3, y.FLOAT, !1, 0, 0)); if (r.morphTargetForcedOrder.length) for (var n = 0, a = r.morphTargetForcedOrder, o = r.morphTargetInfluences; n < t.numSupportedMorphTargets && n < a.length;)(s = i["morphTarget" + n]) >= 0 && (y.bindBuffer(y.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[a[n]]), I.enableAttribute(s), y.vertexAttribPointer(s, 3, y.FLOAT, !1, 0, 0)), (s = i["morphNormal" + n]) >= 0 && t.morphNormals && (y.bindBuffer(y.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[a[n]]), I.enableAttribute(s), y.vertexAttribPointer(s, 3, y.FLOAT, !1, 0, 0)), r.__webglMorphTargetInfluences[n] = o[a[n]], n++; else { var s, h = [], o = r.morphTargetInfluences, l = r.geometry.morphTargets; o.length > l.length && (o.length = l.length); for (var c = 0, u = o.length; c < u; c++) { var E = o[c]; h.push([E, c]) } h.length > t.numSupportedMorphTargets ? (h.sort(Ct), h.length = t.numSupportedMorphTargets) : h.length > t.numSupportedMorphNormals ? h.sort(Ct) : 0 === h.length && h.push([0, 0]); for (var n = 0, p = t.numSupportedMorphTargets; n < p; n++)if (h[n]) { var f = h[n][1]; (s = i["morphTarget" + n]) >= 0 && (y.bindBuffer(y.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[f]), I.enableAttribute(s), y.vertexAttribPointer(s, 3, y.FLOAT, !1, 0, 0)), (s = i["morphNormal" + n]) >= 0 && t.morphNormals && (y.bindBuffer(y.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[f]), I.enableAttribute(s), y.vertexAttribPointer(s, 3, y.FLOAT, !1, 0, 0)), r.__webglMorphTargetInfluences[n] = o[f] } else r.__webglMorphTargetInfluences[n] = 0 } null !== t.program.uniforms.morphTargetInfluences && y.uniform1fv(t.program.uniforms.morphTargetInfluences, r.__webglMorphTargetInfluences) }(n, a, o), l) { if (a.__webglCustomAttributesList) for (var E = 0, p = a.__webglCustomAttributesList.length; E < p; E++) { var f = a.__webglCustomAttributesList[E]; h[f.buffer.belongsToAttribute] >= 0 && (y.bindBuffer(y.ARRAY_BUFFER, f.buffer), I.enableAttribute(h[f.buffer.belongsToAttribute]), y.vertexAttribPointer(h[f.buffer.belongsToAttribute], f.size, y.FLOAT, !1, 0, 0)) } h.color >= 0 && (o.geometry.colors.length > 0 || o.geometry.faces.length > 0 ? (y.bindBuffer(y.ARRAY_BUFFER, a.__webglColorBuffer), I.enableAttribute(h.color), y.vertexAttribPointer(h.color, 3, y.FLOAT, !1, 0, 0)) : void 0 !== n.defaultAttributeValues && y.vertexAttrib3fv(h.color, n.defaultAttributeValues.color)), h.normal >= 0 && (y.bindBuffer(y.ARRAY_BUFFER, a.__webglNormalBuffer), I.enableAttribute(h.normal), y.vertexAttribPointer(h.normal, 3, y.FLOAT, !1, 0, 0)), h.tangent >= 0 && (y.bindBuffer(y.ARRAY_BUFFER, a.__webglTangentBuffer), I.enableAttribute(h.tangent), y.vertexAttribPointer(h.tangent, 4, y.FLOAT, !1, 0, 0)), h.uv >= 0 && (o.geometry.faceVertexUvs[0] ? (y.bindBuffer(y.ARRAY_BUFFER, a.__webglUVBuffer), I.enableAttribute(h.uv), y.vertexAttribPointer(h.uv, 2, y.FLOAT, !1, 0, 0)) : void 0 !== n.defaultAttributeValues && y.vertexAttrib2fv(h.uv, n.defaultAttributeValues.uv)), h.uv2 >= 0 && (o.geometry.faceVertexUvs[1] ? (y.bindBuffer(y.ARRAY_BUFFER, a.__webglUV2Buffer), I.enableAttribute(h.uv2), y.vertexAttribPointer(h.uv2, 2, y.FLOAT, !1, 0, 0)) : void 0 !== n.defaultAttributeValues && y.vertexAttrib2fv(h.uv2, n.defaultAttributeValues.uv2)), n.skinning && h.skinIndex >= 0 && h.skinWeight >= 0 && (y.bindBuffer(y.ARRAY_BUFFER, a.__webglSkinIndicesBuffer), I.enableAttribute(h.skinIndex), y.vertexAttribPointer(h.skinIndex, 4, y.FLOAT, !1, 0, 0), y.bindBuffer(y.ARRAY_BUFFER, a.__webglSkinWeightsBuffer), I.enableAttribute(h.skinWeight), y.vertexAttribPointer(h.skinWeight, 4, y.FLOAT, !1, 0, 0)), h.lineDistance >= 0 && (y.bindBuffer(y.ARRAY_BUFFER, a.__webglLineDistanceBuffer), I.enableAttribute(h.lineDistance), y.vertexAttribPointer(h.lineDistance, 1, y.FLOAT, !1, 0, 0)) } if (I.disableUnusedAttributes(), o instanceof THREE.Mesh) { var d = a.__typeArray === Uint32Array ? y.UNSIGNED_INT : y.UNSIGNED_SHORT; n.wireframe ? (I.setLineWidth(n.wireframeLinewidth * i), l && y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, a.__webglLineBuffer), y.drawElements(y.LINES, a.__webglLineCount, d, 0)) : (l && y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, a.__webglFaceBuffer), y.drawElements(y.TRIANGLES, a.__webglFaceCount, d, 0)), H.info.render.calls++ , H.info.render.vertices += a.__webglFaceCount, H.info.render.faces += a.__webglFaceCount / 3 } else if (o instanceof THREE.Line) { var m = o.mode === THREE.LineStrip ? y.LINE_STRIP : y.LINES; I.setLineWidth(n.linewidth * i), y.drawArrays(m, 0, a.__webglLineCount), H.info.render.calls++ } else o instanceof THREE.PointCloud && (y.drawArrays(y.POINTS, 0, a.__webglParticleCount), H.info.render.calls++ , H.info.render.points += a.__webglParticleCount) } }, this.render = function (t, e, r, i) { if (e instanceof THREE.Camera != !1) { var n = t.fog; M = "", w = -1, S = null, N = !0, !0 === t.autoUpdate && t.updateMatrixWorld(), void 0 === e.parent && e.updateMatrixWorld(), t.traverse(function (t) { t instanceof THREE.SkinnedMesh && t.skeleton.update() }), e.matrixWorldInverse.getInverse(e.matrixWorld), V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), D.setFromMatrix(V), f.length = 0, T.length = 0, g.length = 0, v.length = 0, R.length = 0, function t(e) { if (!1 === e.visible) return; if (e instanceof THREE.Scene || e instanceof THREE.Group); else if (function (t) { void 0 === t.__webglInit && (t.__webglInit = !0, t._modelViewMatrix = new THREE.Matrix4, t._normalMatrix = new THREE.Matrix3, t.addEventListener("removed", pt)); var e = t.geometry; void 0 === e || void 0 === e.__webglInit && (e.__webglInit = !0, e.addEventListener("dispose", ft), e instanceof THREE.BufferGeometry ? H.info.memory.geometries++ : t instanceof THREE.Mesh ? Vt(t, e) : t instanceof THREE.Line ? void 0 === e.__webglVertexBuffer && (!function (t) { t.__webglVertexBuffer = y.createBuffer(), t.__webglColorBuffer = y.createBuffer(), t.__webglLineDistanceBuffer = y.createBuffer(), H.info.memory.geometries++ }(e), function (t, e) { var r = t.vertices.length; t.__vertexArray = new Float32Array(3 * r), t.__colorArray = new Float32Array(3 * r), t.__lineDistanceArray = new Float32Array(1 * r), t.__webglLineCount = r, xt(e) }(e, t), e.verticesNeedUpdate = !0, e.colorsNeedUpdate = !0, e.lineDistancesNeedUpdate = !0) : t instanceof THREE.PointCloud && void 0 === e.__webglVertexBuffer && (!function (t) { t.__webglVertexBuffer = y.createBuffer(), t.__webglColorBuffer = y.createBuffer(), H.info.memory.geometries++ }(e), function (t, e) { var r = t.vertices.length; t.__vertexArray = new Float32Array(3 * r), t.__colorArray = new Float32Array(3 * r), t.__webglParticleCount = r, xt(e) }(e, t), e.verticesNeedUpdate = !0, e.colorsNeedUpdate = !0)); if (void 0 === t.__webglActive) if (t.__webglActive = !0, t instanceof THREE.Mesh) { if (e instanceof THREE.BufferGeometry) zt(d, e, t); else if (e instanceof THREE.Geometry) for (var r = Bt[e.id], i = 0, n = r.length; i < n; i++)zt(d, r[i], t) } else t instanceof THREE.Line || t instanceof THREE.PointCloud ? zt(d, e, t) : (t instanceof THREE.ImmediateRenderObject || t.immediateRenderCallback) && function (t, e) { t.push({ id: null, object: e, opaque: null, transparent: null, z: 0 }) }(m, t) }(e), e instanceof THREE.Light) f.push(e); else if (e instanceof THREE.Sprite) v.push(e); else if (e instanceof THREE.LensFlare) R.push(e); else { var r = d[e.id]; if (r && (!1 === e.frustumCulled || !0 === D.intersectsObject(e))) for (var i = 0, n = r.length; i < n; i++) { var a = r[i]; Ut(a), a.render = !0, !0 === H.sortObjects && (z.setFromMatrixPosition(e.matrixWorld), z.applyProjection(V), a.z = z.z) } } for (var i = 0, n = e.children.length; i < n; i++)t(e.children[i]) }(t), !0 === H.sortObjects && (T.sort(St), g.sort(At)), lt.render(t, e), H.info.render.calls = 0, H.info.render.vertices = 0, H.info.render.faces = 0, H.info.render.points = 0, this.setRenderTarget(r), (this.autoClear || i) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil); for (var a = 0, o = m.length; a < o; a++) { var s = m[a], h = s.object; h.visible && (Kt(h, e), Ft(s)) } if (t.overrideMaterial) { var l = t.overrideMaterial; Wt(l), Lt(T, e, f, n, l), Lt(g, e, f, n, l), Pt(m, "", e, f, n, l) } else I.setBlending(THREE.NoBlending), Lt(T, e, f, n, null), Pt(m, "opaque", e, f, n, null), Lt(g, e, f, n, null), Pt(m, "transparent", e, f, n, null); ct.render(t, e), ut.render(t, e, U, B), r && r.generateMipmaps && r.minFilter !== THREE.NearestFilter && r.minFilter !== THREE.LinearFilter && function (t) { t instanceof THREE.WebGLRenderTargetCube ? (y.bindTexture(y.TEXTURE_CUBE_MAP, t.__webglTexture), y.generateMipmap(y.TEXTURE_CUBE_MAP), y.bindTexture(y.TEXTURE_CUBE_MAP, null)) : (y.bindTexture(y.TEXTURE_2D, t.__webglTexture), y.generateMipmap(y.TEXTURE_2D), y.bindTexture(y.TEXTURE_2D, null)) }(r), I.setDepthTest(!0), I.setDepthWrite(!0), I.setColorWrite(!0) } else THREE.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.") }, this.renderImmediateObject = function (t, e, r, i, n) { var a = jt(t, e, r, i, n); M = "", H.setMaterialFaces(i), n.immediateRenderCallback ? n.immediateRenderCallback(a, y, D) : n.render(function (t) { H.renderBufferImmediate(t, a, i) }) }; var Bt = {}, Dt = 0; function Vt(t, e) { var r = t.material, i = !1; void 0 !== Bt[e.id] && !0 !== e.groupsNeedUpdate || (delete d[t.id], Bt[e.id] = function (t, e) { for (var r, i, n = W.get("OES_element_index_uint") ? 4294967296 : 65535, a = {}, o = t.morphTargets.length, s = t.morphNormals.length, h = {}, l = [], c = 0, u = t.faces.length; c < u; c++) { var E = t.faces[c], p = e ? E.materialIndex : 0; p in a || (a[p] = { hash: p, counter: 0 }), (r = a[p].hash + "_" + a[p].counter) in h || (i = { id: Dt++, faces3: [], materialIndex: p, vertices: 0, numMorphTargets: o, numMorphNormals: s }, h[r] = i, l.push(i)), h[r].vertices + 3 > n && (a[p].counter += 1, (r = a[p].hash + "_" + a[p].counter) in h || (i = { id: Dt++, faces3: [], materialIndex: p, vertices: 0, numMorphTargets: o, numMorphNormals: s }, h[r] = i, l.push(i))), h[r].faces3.push(c), h[r].vertices += 3 } return l }(e, r instanceof THREE.MeshFaceMaterial), e.groupsNeedUpdate = !1); for (var n = Bt[e.id], a = 0, o = n.length; a < o; a++) { var s = n[a]; void 0 === s.__webglVertexBuffer ? (Et(s), bt(s, t), e.verticesNeedUpdate = !0, e.morphTargetsNeedUpdate = !0, e.elementsNeedUpdate = !0, e.uvsNeedUpdate = !0, e.normalsNeedUpdate = !0, e.tangentsNeedUpdate = !0, e.colorsNeedUpdate = !0, i = !0) : i = !1, (i || void 0 === t.__webglActive) && zt(d, s, t) } t.__webglActive = !0 } function zt(t, e, r) { var i = r.id; t[i] = t[i] || [], t[i].push({ id: i, buffer: e, object: r, material: null, z: 0 }) } function kt(t) { var e = t.geometry; if (e instanceof THREE.BufferGeometry) for (var r = e.attributes, i = e.attributesKeys, n = 0, a = i.length; n < a; n++) { var o = i[n], s = r[o], h = "index" === o ? y.ELEMENT_ARRAY_BUFFER : y.ARRAY_BUFFER; void 0 === s.buffer ? (s.buffer = y.createBuffer(), y.bindBuffer(h, s.buffer), y.bufferData(h, s.array, s instanceof THREE.DynamicBufferAttribute ? y.DYNAMIC_DRAW : y.STATIC_DRAW), s.needsUpdate = !1) : !0 === s.needsUpdate && (y.bindBuffer(h, s.buffer), void 0 === s.updateRange || -1 === s.updateRange.count ? y.bufferSubData(h, 0, s.array) : 0 === s.updateRange.count ? console.error("THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.") : (y.bufferSubData(h, s.updateRange.offset * s.array.BYTES_PER_ELEMENT, s.array.subarray(s.updateRange.offset, s.updateRange.offset + s.updateRange.count)), s.updateRange.count = 0), s.needsUpdate = !1) } else if (t instanceof THREE.Mesh) { !0 === e.groupsNeedUpdate && Vt(t, e); for (var l = Bt[e.id], c = (n = 0, l.length); n < c; n++) { var u = l[n], E = (p = _t(t, u)).attributes && Nt(p); (e.verticesNeedUpdate || e.morphTargetsNeedUpdate || e.elementsNeedUpdate || e.uvsNeedUpdate || e.normalsNeedUpdate || e.colorsNeedUpdate || e.tangentsNeedUpdate || E) && wt(u, t, y.DYNAMIC_DRAW, !e.dynamic, p) } e.verticesNeedUpdate = !1, e.morphTargetsNeedUpdate = !1, e.elementsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.tangentsNeedUpdate = !1, p.attributes && Ot(p) } else if (t instanceof THREE.Line) { E = (p = _t(t, e)).attributes && Nt(p); (e.verticesNeedUpdate || e.colorsNeedUpdate || e.lineDistancesNeedUpdate || E) && function (t, e) { var r, i, n, a, o, s, h, l, c, u, E, p, f = t.vertices, d = t.colors, m = t.lineDistances, T = f.length, g = d.length, v = m.length, R = t.__vertexArray, H = t.__colorArray, x = t.__lineDistanceArray, b = t.verticesNeedUpdate, _ = t.colorsNeedUpdate, w = t.lineDistancesNeedUpdate, M = t.__webglCustomAttributesList; if (b) { for (r = 0; r < T; r++)a = f[r], R[o = 3 * r] = a.x, R[o + 1] = a.y, R[o + 2] = a.z; y.bindBuffer(y.ARRAY_BUFFER, t.__webglVertexBuffer), y.bufferData(y.ARRAY_BUFFER, R, e) } if (_) { for (i = 0; i < g; i++)s = d[i], H[o = 3 * i] = s.r, H[o + 1] = s.g, H[o + 2] = s.b; y.bindBuffer(y.ARRAY_BUFFER, t.__webglColorBuffer), y.bufferData(y.ARRAY_BUFFER, H, e) } if (w) { for (n = 0; n < v; n++)x[n] = m[n]; y.bindBuffer(y.ARRAY_BUFFER, t.__webglLineDistanceBuffer), y.bufferData(y.ARRAY_BUFFER, x, e) } if (M) for (h = 0, l = M.length; h < l; h++)if ((p = M[h]).needsUpdate && (void 0 === p.boundTo || "vertices" === p.boundTo)) { if (o = 0, u = p.value.length, 1 === p.size) for (c = 0; c < u; c++)p.array[c] = p.value[c]; else if (2 === p.size) for (c = 0; c < u; c++)E = p.value[c], p.array[o] = E.x, p.array[o + 1] = E.y, o += 2; else if (3 === p.size) if ("c" === p.type) for (c = 0; c < u; c++)E = p.value[c], p.array[o] = E.r, p.array[o + 1] = E.g, p.array[o + 2] = E.b, o += 3; else for (c = 0; c < u; c++)E = p.value[c], p.array[o] = E.x, p.array[o + 1] = E.y, p.array[o + 2] = E.z, o += 3; else if (4 === p.size) for (c = 0; c < u; c++)E = p.value[c], p.array[o] = E.x, p.array[o + 1] = E.y, p.array[o + 2] = E.z, p.array[o + 3] = E.w, o += 4; y.bindBuffer(y.ARRAY_BUFFER, p.buffer), y.bufferData(y.ARRAY_BUFFER, p.array, e), p.needsUpdate = !1 } }(e, y.DYNAMIC_DRAW), e.verticesNeedUpdate = !1, e.colorsNeedUpdate = !1, e.lineDistancesNeedUpdate = !1, p.attributes && Ot(p) } else if (t instanceof THREE.PointCloud) { var p; E = (p = _t(t, e)).attributes && Nt(p); (e.verticesNeedUpdate || e.colorsNeedUpdate || E) && function (t, e, r) { var i, n, a, o, s, h, l, c, u, E, p, f = t.vertices, d = f.length, m = t.colors, T = m.length, g = t.__vertexArray, v = t.__colorArray, R = t.verticesNeedUpdate, H = t.colorsNeedUpdate, x = t.__webglCustomAttributesList; if (R) { for (i = 0; i < d; i++)a = f[i], g[o = 3 * i] = a.x, g[o + 1] = a.y, g[o + 2] = a.z; y.bindBuffer(y.ARRAY_BUFFER, t.__webglVertexBuffer), y.bufferData(y.ARRAY_BUFFER, g, e) } if (H) { for (n = 0; n < T; n++)s = m[n], v[o = 3 * n] = s.r, v[o + 1] = s.g, v[o + 2] = s.b; y.bindBuffer(y.ARRAY_BUFFER, t.__webglColorBuffer), y.bufferData(y.ARRAY_BUFFER, v, e) } if (x) for (h = 0, l = x.length; h < l; h++) { if ((p = x[h]).needsUpdate && (void 0 === p.boundTo || "vertices" === p.boundTo)) if (u = p.value.length, o = 0, 1 === p.size) for (c = 0; c < u; c++)p.array[c] = p.value[c]; else if (2 === p.size) for (c = 0; c < u; c++)E = p.value[c], p.array[o] = E.x, p.array[o + 1] = E.y, o += 2; else if (3 === p.size) if ("c" === p.type) for (c = 0; c < u; c++)E = p.value[c], p.array[o] = E.r, p.array[o + 1] = E.g, p.array[o + 2] = E.b, o += 3; else for (c = 0; c < u; c++)E = p.value[c], p.array[o] = E.x, p.array[o + 1] = E.y, p.array[o + 2] = E.z, o += 3; else if (4 === p.size) for (c = 0; c < u; c++)E = p.value[c], p.array[o] = E.x, p.array[o + 1] = E.y, p.array[o + 2] = E.z, p.array[o + 3] = E.w, o += 4; y.bindBuffer(y.ARRAY_BUFFER, p.buffer), y.bufferData(y.ARRAY_BUFFER, p.array, e), p.needsUpdate = !1 } }(e, y.DYNAMIC_DRAW), e.verticesNeedUpdate = !1, e.colorsNeedUpdate = !1, p.attributes && Ot(p) } } function Nt(t) { for (var e in t.attributes) if (t.attributes[e].needsUpdate) return !0; return !1 } function Ot(t) { for (var e in t.attributes) t.attributes[e].needsUpdate = !1 } var Gt = { MeshDepthMaterial: "depth", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointCloudMaterial: "particle_basic" }; function It(t, e, r, i) { t.addEventListener("dispose", Tt); var a = Gt[t.type]; if (a) { var o = THREE.ShaderLib[a]; t.__webglShader = { uniforms: THREE.UniformsUtils.clone(o.uniforms), vertexShader: o.vertexShader, fragmentShader: o.fragmentShader } } else t.__webglShader = { uniforms: t.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader }; var s = function (t) { for (var e = 0, r = 0, i = 0, n = 0, a = 0, o = t.length; a < o; a++) { var s = t[a]; s.onlyShadow || !1 === s.visible || (s instanceof THREE.DirectionalLight && e++ , s instanceof THREE.PointLight && r++ , s instanceof THREE.SpotLight && i++ , s instanceof THREE.HemisphereLight && n++) } return { directional: e, point: r, spot: i, hemi: n } }(e), h = function (t) { for (var e = 0, r = 0, i = t.length; r < i; r++) { var n = t[r]; n.castShadow && (n instanceof THREE.SpotLight && e++ , n instanceof THREE.DirectionalLight && !n.shadowCascade && e++) } return e }(e), l = function (t) { if (tt && t && t.skeleton && t.skeleton.useVertexTexture) return 1024; var e = y.getParameter(y.MAX_VERTEX_UNIFORM_VECTORS), r = Math.floor((e - 20) / 4), i = r; return void 0 !== t && t instanceof THREE.SkinnedMesh && (i = Math.min(t.skeleton.bones.length, i)) < t.skeleton.bones.length && THREE.warn("WebGLRenderer: too many bones - " + t.skeleton.bones.length + ", this GPU supports just " + i + " (try OpenGL instead of ANGLE)"), i }(i), c = { precision: n, supportsVertexTextures: $, map: !!t.map, envMap: !!t.envMap, envMapMode: t.envMap && t.envMap.mapping, lightMap: !!t.lightMap, bumpMap: !!t.bumpMap, normalMap: !!t.normalMap, specularMap: !!t.specularMap, alphaMap: !!t.alphaMap, combine: t.combine, vertexColors: t.vertexColors, fog: r, useFog: t.fog, fogExp: r instanceof THREE.FogExp2, flatShading: t.shading === THREE.FlatShading, sizeAttenuation: t.sizeAttenuation, logarithmicDepthBuffer: u, skinning: t.skinning, maxBones: l, useVertexTexture: tt && i && i.skeleton && i.skeleton.useVertexTexture, morphTargets: t.morphTargets, morphNormals: t.morphNormals, maxMorphTargets: H.maxMorphTargets, maxMorphNormals: H.maxMorphNormals, maxDirLights: s.directional, maxPointLights: s.point, maxSpotLights: s.spot, maxHemiLights: s.hemi, maxShadows: h, shadowMapEnabled: H.shadowMapEnabled && i.receiveShadow && h > 0, shadowMapType: H.shadowMapType, shadowMapDebug: H.shadowMapDebug, shadowMapCascade: H.shadowMapCascade, alphaTest: t.alphaTest, metal: t.metal, wrapAround: t.wrapAround, doubleSided: t.side === THREE.DoubleSide, flipSided: t.side === THREE.BackSide }, E = []; if (a ? E.push(a) : (E.push(t.fragmentShader), E.push(t.vertexShader)), void 0 !== t.defines) for (var p in t.defines) E.push(p), E.push(t.defines[p]); for (var p in c) E.push(p), E.push(c[p]); for (var f, d = E.join(), m = 0, T = x.length; m < T; m++) { var g = x[m]; if (g.code === d) { (f = g).usedTimes++; break } } void 0 === f && (f = new THREE.WebGLProgram(H, d, t, c), x.push(f), H.info.memory.programs = x.length), t.program = f; var v = f.attributes; if (t.morphTargets) { t.numSupportedMorphTargets = 0; for (var R = "morphTarget", b = 0; b < H.maxMorphTargets; b++)v[R + b] >= 0 && t.numSupportedMorphTargets++ } if (t.morphNormals) { t.numSupportedMorphNormals = 0; R = "morphNormal"; for (b = 0; b < H.maxMorphNormals; b++)v[R + b] >= 0 && t.numSupportedMorphNormals++ } for (var _ in t.uniformsList = [], t.__webglShader.uniforms) { var w = t.program.uniforms[_]; w && t.uniformsList.push([t.__webglShader.uniforms[_], w]) } } function Wt(t) { !0 === t.transparent ? I.setBlending(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha) : I.setBlending(THREE.NoBlending), I.setDepthTest(t.depthTest), I.setDepthWrite(t.depthWrite), I.setColorWrite(t.colorWrite), I.setPolygonOffset(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) } function jt(t, r, i, n, a) { A = 0, n.needsUpdate && (n.program && Ht(n), It(n, r, i, a), n.needsUpdate = !1), n.morphTargets && (a.__webglMorphTargetInfluences || (a.__webglMorphTargetInfluences = new Float32Array(H.maxMorphTargets))); var o = !1, s = !1, h = !1, l = n.program, c = l.uniforms, E = n.__webglShader.uniforms; if (l.id !== b && (y.useProgram(l.program), b = l.id, o = !0, s = !0, h = !0), n.id !== w && (-1 === w && (h = !0), w = n.id, s = !0), (o || t !== S) && (y.uniformMatrix4fv(c.projectionMatrix, !1, t.projectionMatrix.elements), u && y.uniform1f(c.logDepthBufFC, 2 / (Math.log(t.far + 1) / Math.LN2)), t !== S && (S = t), (n instanceof THREE.ShaderMaterial || n instanceof THREE.MeshPhongMaterial || n.envMap) && null !== c.cameraPosition && (z.setFromMatrixPosition(t.matrixWorld), y.uniform3f(c.cameraPosition, z.x, z.y, z.z)), (n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.MeshBasicMaterial || n instanceof THREE.ShaderMaterial || n.skinning) && null !== c.viewMatrix && y.uniformMatrix4fv(c.viewMatrix, !1, t.matrixWorldInverse.elements)), n.skinning) if (a.bindMatrix && null !== c.bindMatrix && y.uniformMatrix4fv(c.bindMatrix, !1, a.bindMatrix.elements), a.bindMatrixInverse && null !== c.bindMatrixInverse && y.uniformMatrix4fv(c.bindMatrixInverse, !1, a.bindMatrixInverse.elements), tt && a.skeleton && a.skeleton.useVertexTexture) { if (null !== c.boneTexture) { var p = Yt(); y.uniform1i(c.boneTexture, p), H.setTexture(a.skeleton.boneTexture, p) } null !== c.boneTextureWidth && y.uniform1i(c.boneTextureWidth, a.skeleton.boneTextureWidth), null !== c.boneTextureHeight && y.uniform1i(c.boneTextureHeight, a.skeleton.boneTextureHeight) } else a.skeleton && a.skeleton.boneMatrices && null !== c.boneGlobalMatrices && y.uniformMatrix4fv(c.boneGlobalMatrices, !1, a.skeleton.boneMatrices); return s && (i && n.fog && function (t, e) { t.fogColor.value = e.color, e instanceof THREE.Fog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e instanceof THREE.FogExp2 && (t.fogDensity.value = e.density) }(E, i), (n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshLambertMaterial || n.lights) && (N && (h = !0, function (t) { var e, r, i, n, a, o, s, h, l = 0, c = 0, u = 0, E = O, p = E.directional.colors, f = E.directional.positions, d = E.point.colors, m = E.point.positions, T = E.point.distances, g = E.point.decays, v = E.spot.colors, R = E.spot.positions, y = E.spot.distances, H = E.spot.directions, x = E.spot.anglesCos, b = E.spot.exponents, _ = E.spot.decays, w = E.hemi.skyColors, M = E.hemi.groundColors, S = E.hemi.positions, A = 0, C = 0, L = 0, P = 0, F = 0, U = 0, B = 0, D = 0, V = 0, N = 0, G = 0, I = 0; for (e = 0, r = t.length; e < r; e++)if (!(i = t[e]).onlyShadow) if (n = i.color, s = i.intensity, h = i.distance, i instanceof THREE.AmbientLight) { if (!i.visible) continue; l += n.r, c += n.g, u += n.b } else if (i instanceof THREE.DirectionalLight) { if (F += 1, !i.visible) continue; k.setFromMatrixPosition(i.matrixWorld), z.setFromMatrixPosition(i.target.matrixWorld), k.sub(z), k.normalize(), f[V = 3 * A] = k.x, f[V + 1] = k.y, f[V + 2] = k.z, Qt(p, V, n, s), A += 1 } else if (i instanceof THREE.PointLight) { if (U += 1, !i.visible) continue; Qt(d, N = 3 * C, n, s), z.setFromMatrixPosition(i.matrixWorld), m[N] = z.x, m[N + 1] = z.y, m[N + 2] = z.z, T[C] = h, g[C] = 0 === i.distance ? 0 : i.decay, C += 1 } else if (i instanceof THREE.SpotLight) { if (B += 1, !i.visible) continue; Qt(v, G = 3 * L, n, s), k.setFromMatrixPosition(i.matrixWorld), R[G] = k.x, R[G + 1] = k.y, R[G + 2] = k.z, y[L] = h, z.setFromMatrixPosition(i.target.matrixWorld), k.sub(z), k.normalize(), H[G] = k.x, H[G + 1] = k.y, H[G + 2] = k.z, x[L] = Math.cos(i.angle), b[L] = i.exponent, _[L] = 0 === i.distance ? 0 : i.decay, L += 1 } else if (i instanceof THREE.HemisphereLight) { if (D += 1, !i.visible) continue; k.setFromMatrixPosition(i.matrixWorld), k.normalize(), S[I = 3 * P] = k.x, S[I + 1] = k.y, S[I + 2] = k.z, a = i.color, o = i.groundColor, Qt(w, I, a, s), Qt(M, I, o, s), P += 1 } for (e = 3 * A, r = Math.max(p.length, 3 * F); e < r; e++)p[e] = 0; for (e = 3 * C, r = Math.max(d.length, 3 * U); e < r; e++)d[e] = 0; for (e = 3 * L, r = Math.max(v.length, 3 * B); e < r; e++)v[e] = 0; for (e = 3 * P, r = Math.max(w.length, 3 * D); e < r; e++)w[e] = 0; for (e = 3 * P, r = Math.max(M.length, 3 * D); e < r; e++)M[e] = 0; E.directional.length = A, E.point.length = C, E.spot.length = L, E.hemi.length = P, E.ambient[0] = l, E.ambient[1] = c, E.ambient[2] = u }(r), N = !1), h ? (!function (t, e) { t.ambientLightColor.value = e.ambient, t.directionalLightColor.value = e.directional.colors, t.directionalLightDirection.value = e.directional.positions, t.pointLightColor.value = e.point.colors, t.pointLightPosition.value = e.point.positions, t.pointLightDistance.value = e.point.distances, t.pointLightDecay.value = e.point.decays, t.spotLightColor.value = e.spot.colors, t.spotLightPosition.value = e.spot.positions, t.spotLightDistance.value = e.spot.distances, t.spotLightDirection.value = e.spot.directions, t.spotLightAngleCos.value = e.spot.anglesCos, t.spotLightExponent.value = e.spot.exponents, t.spotLightDecay.value = e.spot.decays, t.hemisphereLightSkyColor.value = e.hemi.skyColors, t.hemisphereLightGroundColor.value = e.hemi.groundColors, t.hemisphereLightDirection.value = e.hemi.positions }(E, O), qt(E, !0)) : qt(E, !1)), (n instanceof THREE.MeshBasicMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.MeshPhongMaterial) && function (t, e) { t.opacity.value = e.opacity, t.diffuse.value = e.color, t.map.value = e.map, t.lightMap.value = e.lightMap, t.specularMap.value = e.specularMap, t.alphaMap.value = e.alphaMap, e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)); var r; e.map ? r = e.map : e.specularMap ? r = e.specularMap : e.normalMap ? r = e.normalMap : e.bumpMap ? r = e.bumpMap : e.alphaMap && (r = e.alphaMap); if (void 0 !== r) { var i = r.offset, n = r.repeat; t.offsetRepeat.value.set(i.x, i.y, n.x, n.y) } t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio }(E, n), n instanceof THREE.LineBasicMaterial ? Xt(E, n) : n instanceof THREE.LineDashedMaterial ? (Xt(E, n), function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(E, n)) : n instanceof THREE.PointCloudMaterial ? function (t, r) { if (t.psColor.value = r.color, t.opacity.value = r.opacity, t.size.value = r.size, t.scale.value = e.height / 2, t.map.value = r.map, null !== r.map) { var i = r.map.offset, n = r.map.repeat; t.offsetRepeat.value.set(i.x, i.y, n.x, n.y) } }(E, n) : n instanceof THREE.MeshPhongMaterial ? function (t, e) { t.shininess.value = e.shininess, t.emissive.value = e.emissive, t.specular.value = e.specular, e.wrapAround && t.wrapRGB.value.copy(e.wrapRGB) }(E, n) : n instanceof THREE.MeshLambertMaterial ? function (t, e) { t.emissive.value = e.emissive, e.wrapAround && t.wrapRGB.value.copy(e.wrapRGB) }(E, n) : n instanceof THREE.MeshDepthMaterial ? (E.mNear.value = t.near, E.mFar.value = t.far, E.opacity.value = n.opacity) : n instanceof THREE.MeshNormalMaterial && (E.opacity.value = n.opacity), a.receiveShadow && !n._shadowPass && function (t, e) { if (t.shadowMatrix) for (var r = 0, i = 0, n = e.length; i < n; i++) { var a = e[i]; a.castShadow && ((a instanceof THREE.SpotLight || a instanceof THREE.DirectionalLight && !a.shadowCascade) && (t.shadowMap.value[r] = a.shadowMap, t.shadowMapSize.value[r] = a.shadowMapSize, t.shadowMatrix.value[r] = a.shadowMatrix, t.shadowDarkness.value[r] = a.shadowDarkness, t.shadowBias.value[r] = a.shadowBias, r++)) } }(E, r), function (t) { for (var e, r, i, n = 0, a = t.length; n < a; n++) { var o = t[n][0]; if (!1 !== o.needsUpdate) { var s = o.type, h = o.value, l = t[n][1]; switch (s) { case "1i": y.uniform1i(l, h); break; case "1f": y.uniform1f(l, h); break; case "2f": y.uniform2f(l, h[0], h[1]); break; case "3f": y.uniform3f(l, h[0], h[1], h[2]); break; case "4f": y.uniform4f(l, h[0], h[1], h[2], h[3]); break; case "1iv": y.uniform1iv(l, h); break; case "3iv": y.uniform3iv(l, h); break; case "1fv": y.uniform1fv(l, h); break; case "2fv": y.uniform2fv(l, h); break; case "3fv": y.uniform3fv(l, h); break; case "4fv": y.uniform4fv(l, h); break; case "Matrix3fv": y.uniformMatrix3fv(l, !1, h); break; case "Matrix4fv": y.uniformMatrix4fv(l, !1, h); break; case "i": y.uniform1i(l, h); break; case "f": y.uniform1f(l, h); break; case "v2": y.uniform2f(l, h.x, h.y); break; case "v3": y.uniform3f(l, h.x, h.y, h.z); break; case "v4": y.uniform4f(l, h.x, h.y, h.z, h.w); break; case "c": y.uniform3f(l, h.r, h.g, h.b); break; case "iv1": y.uniform1iv(l, h); break; case "iv": y.uniform3iv(l, h); break; case "fv1": y.uniform1fv(l, h); break; case "fv": y.uniform3fv(l, h); break; case "v2v": void 0 === o._array && (o._array = new Float32Array(2 * h.length)); for (var c = 0, u = h.length; c < u; c++)i = 2 * c, o._array[i] = h[c].x, o._array[i + 1] = h[c].y; y.uniform2fv(l, o._array); break; case "v3v": void 0 === o._array && (o._array = new Float32Array(3 * h.length)); for (var c = 0, u = h.length; c < u; c++)i = 3 * c, o._array[i] = h[c].x, o._array[i + 1] = h[c].y, o._array[i + 2] = h[c].z; y.uniform3fv(l, o._array); break; case "v4v": void 0 === o._array && (o._array = new Float32Array(4 * h.length)); for (var c = 0, u = h.length; c < u; c++)i = 4 * c, o._array[i] = h[c].x, o._array[i + 1] = h[c].y, o._array[i + 2] = h[c].z, o._array[i + 3] = h[c].w; y.uniform4fv(l, o._array); break; case "m3": y.uniformMatrix3fv(l, !1, h.elements); break; case "m3v": void 0 === o._array && (o._array = new Float32Array(9 * h.length)); for (var c = 0, u = h.length; c < u; c++)h[c].flattenToArrayOffset(o._array, 9 * c); y.uniformMatrix3fv(l, !1, o._array); break; case "m4": y.uniformMatrix4fv(l, !1, h.elements); break; case "m4v": void 0 === o._array && (o._array = new Float32Array(16 * h.length)); for (var c = 0, u = h.length; c < u; c++)h[c].flattenToArrayOffset(o._array, 16 * c); y.uniformMatrix4fv(l, !1, o._array); break; case "t": if (e = h, r = Yt(), y.uniform1i(l, r), !e) continue; e instanceof THREE.CubeTexture || e.image instanceof Array && 6 === e.image.length ? $t(e, r) : e instanceof THREE.WebGLRenderTargetCube ? te(e, r) : H.setTexture(e, r); break; case "tv": void 0 === o._array && (o._array = []); for (var c = 0, u = o.value.length; c < u; c++)o._array[c] = Yt(); y.uniform1iv(l, o._array); for (var c = 0, u = o.value.length; c < u; c++)e = o.value[c], r = o._array[c], e && H.setTexture(e, r); break; default: THREE.warn("THREE.WebGLRenderer: Unknown uniform type: " + s) } } } }(n.uniformsList)), function (t, e) { y.uniformMatrix4fv(t.modelViewMatrix, !1, e._modelViewMatrix.elements), t.normalMatrix && y.uniformMatrix3fv(t.normalMatrix, !1, e._normalMatrix.elements) }(c, a), null !== c.modelMatrix && y.uniformMatrix4fv(c.modelMatrix, !1, a.matrixWorld.elements), l } function Xt(t, e) { t.diffuse.value = e.color, t.opacity.value = e.opacity } function qt(t, e) { t.ambientLightColor.needsUpdate = e, t.directionalLightColor.needsUpdate = e, t.directionalLightDirection.needsUpdate = e, t.pointLightColor.needsUpdate = e, t.pointLightPosition.needsUpdate = e, t.pointLightDistance.needsUpdate = e, t.pointLightDecay.needsUpdate = e, t.spotLightColor.needsUpdate = e, t.spotLightPosition.needsUpdate = e, t.spotLightDistance.needsUpdate = e, t.spotLightDirection.needsUpdate = e, t.spotLightAngleCos.needsUpdate = e, t.spotLightExponent.needsUpdate = e, t.spotLightDecay.needsUpdate = e, t.hemisphereLightSkyColor.needsUpdate = e, t.hemisphereLightGroundColor.needsUpdate = e, t.hemisphereLightDirection.needsUpdate = e } function Yt() { var t = A; return t >= K && THREE.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + K), A += 1, t } function Kt(t, e) { t._modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, t.matrixWorld), t._normalMatrix.getNormalMatrix(t._modelViewMatrix) } function Qt(t, e, r, i) { t[e] = r.r * i, t[e + 1] = r.g * i, t[e + 2] = r.b * i } function Zt(t, e, r) { var i; r ? (y.texParameteri(t, y.TEXTURE_WRAP_S, ne(e.wrapS)), y.texParameteri(t, y.TEXTURE_WRAP_T, ne(e.wrapT)), y.texParameteri(t, y.TEXTURE_MAG_FILTER, ne(e.magFilter)), y.texParameteri(t, y.TEXTURE_MIN_FILTER, ne(e.minFilter))) : (y.texParameteri(t, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE), y.texParameteri(t, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE), e.wrapS === THREE.ClampToEdgeWrapping && e.wrapT === THREE.ClampToEdgeWrapping || THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( " + e.sourceFile + " )"), y.texParameteri(t, y.TEXTURE_MAG_FILTER, ie(e.magFilter)), y.texParameteri(t, y.TEXTURE_MIN_FILTER, ie(e.minFilter)), e.minFilter !== THREE.NearestFilter && e.minFilter !== THREE.LinearFilter && THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( " + e.sourceFile + " )")), (i = W.get("EXT_texture_filter_anisotropic")) && e.type !== THREE.FloatType && e.type !== THREE.HalfFloatType && (e.anisotropy > 1 || e.__currentAnisotropy) && (y.texParameterf(t, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, H.getMaxAnisotropy())), e.__currentAnisotropy = e.anisotropy) } function Jt(t, e) { if (t.width > e || t.height > e) { var r = e / Math.max(t.width, t.height), i = document.createElement("canvas"); return i.width = Math.floor(t.width * r), i.height = Math.floor(t.height * r), i.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height), THREE.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height, t), i } return t } function $t(t, e) { if (6 === t.image.length) if (t.needsUpdate) { t.image.__webglTextureCube || (t.addEventListener("dispose", dt), t.image.__webglTextureCube = y.createTexture(), H.info.memory.textures++), y.activeTexture(y.TEXTURE0 + e), y.bindTexture(y.TEXTURE_CUBE_MAP, t.image.__webglTextureCube), y.pixelStorei(y.UNPACK_FLIP_Y_WEBGL, t.flipY); for (var r = t instanceof THREE.CompressedTexture, i = t.image[0] instanceof THREE.DataTexture, n = [], a = 0; a < 6; a++)!H.autoScaleCubemaps || r || i ? n[a] = i ? t.image[a].image : t.image[a] : n[a] = Jt(t.image[a], J); var o = n[0], s = THREE.Math.isPowerOfTwo(o.width) && THREE.Math.isPowerOfTwo(o.height), h = ne(t.format), l = ne(t.type); Zt(y.TEXTURE_CUBE_MAP, t, s); for (a = 0; a < 6; a++)if (r) for (var c, u = n[a].mipmaps, E = 0, p = u.length; E < p; E++)c = u[E], t.format !== THREE.RGBAFormat && t.format !== THREE.RGBFormat ? at().indexOf(h) > -1 ? y.compressedTexImage2D(y.TEXTURE_CUBE_MAP_POSITIVE_X + a, E, h, c.width, c.height, 0, c.data) : THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : y.texImage2D(y.TEXTURE_CUBE_MAP_POSITIVE_X + a, E, h, c.width, c.height, 0, h, l, c.data); else i ? y.texImage2D(y.TEXTURE_CUBE_MAP_POSITIVE_X + a, 0, h, n[a].width, n[a].height, 0, h, l, n[a].data) : y.texImage2D(y.TEXTURE_CUBE_MAP_POSITIVE_X + a, 0, h, h, l, n[a]); t.generateMipmaps && s && y.generateMipmap(y.TEXTURE_CUBE_MAP), t.needsUpdate = !1, t.onUpdate && t.onUpdate() } else y.activeTexture(y.TEXTURE0 + e), y.bindTexture(y.TEXTURE_CUBE_MAP, t.image.__webglTextureCube) } function te(t, e) { y.activeTexture(y.TEXTURE0 + e), y.bindTexture(y.TEXTURE_CUBE_MAP, t.__webglTexture) } function ee(t, e, r) { y.bindFramebuffer(y.FRAMEBUFFER, t), y.framebufferTexture2D(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0, r, e.__webglTexture, 0) } function re(t, e) { y.bindRenderbuffer(y.RENDERBUFFER, t), e.depthBuffer && !e.stencilBuffer ? (y.renderbufferStorage(y.RENDERBUFFER, y.DEPTH_COMPONENT16, e.width, e.height), y.framebufferRenderbuffer(y.FRAMEBUFFER, y.DEPTH_ATTACHMENT, y.RENDERBUFFER, t)) : e.depthBuffer && e.stencilBuffer ? (y.renderbufferStorage(y.RENDERBUFFER, y.DEPTH_STENCIL, e.width, e.height), y.framebufferRenderbuffer(y.FRAMEBUFFER, y.DEPTH_STENCIL_ATTACHMENT, y.RENDERBUFFER, t)) : y.renderbufferStorage(y.RENDERBUFFER, y.RGBA4, e.width, e.height) } function ie(t) { return t === THREE.NearestFilter || t === THREE.NearestMipMapNearestFilter || t === THREE.NearestMipMapLinearFilter ? y.NEAREST : y.LINEAR } function ne(t) { var e; if (t === THREE.RepeatWrapping) return y.REPEAT; if (t === THREE.ClampToEdgeWrapping) return y.CLAMP_TO_EDGE; if (t === THREE.MirroredRepeatWrapping) return y.MIRRORED_REPEAT; if (t === THREE.NearestFilter) return y.NEAREST; if (t === THREE.NearestMipMapNearestFilter) return y.NEAREST_MIPMAP_NEAREST; if (t === THREE.NearestMipMapLinearFilter) return y.NEAREST_MIPMAP_LINEAR; if (t === THREE.LinearFilter) return y.LINEAR; if (t === THREE.LinearMipMapNearestFilter) return y.LINEAR_MIPMAP_NEAREST; if (t === THREE.LinearMipMapLinearFilter) return y.LINEAR_MIPMAP_LINEAR; if (t === THREE.UnsignedByteType) return y.UNSIGNED_BYTE; if (t === THREE.UnsignedShort4444Type) return y.UNSIGNED_SHORT_4_4_4_4; if (t === THREE.UnsignedShort5551Type) return y.UNSIGNED_SHORT_5_5_5_1; if (t === THREE.UnsignedShort565Type) return y.UNSIGNED_SHORT_5_6_5; if (t === THREE.ByteType) return y.BYTE; if (t === THREE.ShortType) return y.SHORT; if (t === THREE.UnsignedShortType) return y.UNSIGNED_SHORT; if (t === THREE.IntType) return y.INT; if (t === THREE.UnsignedIntType) return y.UNSIGNED_INT; if (t === THREE.FloatType) return y.FLOAT; if (null !== (e = W.get("OES_texture_half_float")) && t === THREE.HalfFloatType) return e.HALF_FLOAT_OES; if (t === THREE.AlphaFormat) return y.ALPHA; if (t === THREE.RGBFormat) return y.RGB; if (t === THREE.RGBAFormat) return y.RGBA; if (t === THREE.LuminanceFormat) return y.LUMINANCE; if (t === THREE.LuminanceAlphaFormat) return y.LUMINANCE_ALPHA; if (t === THREE.AddEquation) return y.FUNC_ADD; if (t === THREE.SubtractEquation) return y.FUNC_SUBTRACT; if (t === THREE.ReverseSubtractEquation) return y.FUNC_REVERSE_SUBTRACT; if (t === THREE.ZeroFactor) return y.ZERO; if (t === THREE.OneFactor) return y.ONE; if (t === THREE.SrcColorFactor) return y.SRC_COLOR; if (t === THREE.OneMinusSrcColorFactor) return y.ONE_MINUS_SRC_COLOR; if (t === THREE.SrcAlphaFactor) return y.SRC_ALPHA; if (t === THREE.OneMinusSrcAlphaFactor) return y.ONE_MINUS_SRC_ALPHA; if (t === THREE.DstAlphaFactor) return y.DST_ALPHA; if (t === THREE.OneMinusDstAlphaFactor) return y.ONE_MINUS_DST_ALPHA; if (t === THREE.DstColorFactor) return y.DST_COLOR; if (t === THREE.OneMinusDstColorFactor) return y.ONE_MINUS_DST_COLOR; if (t === THREE.SrcAlphaSaturateFactor) return y.SRC_ALPHA_SATURATE; if (null !== (e = W.get("WEBGL_compressed_texture_s3tc"))) { if (t === THREE.RGB_S3TC_DXT1_Format) return e.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === THREE.RGBA_S3TC_DXT1_Format) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === THREE.RGBA_S3TC_DXT3_Format) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === THREE.RGBA_S3TC_DXT5_Format) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (null !== (e = W.get("WEBGL_compressed_texture_pvrtc"))) { if (t === THREE.RGB_PVRTC_4BPPV1_Format) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === THREE.RGB_PVRTC_2BPPV1_Format) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === THREE.RGBA_PVRTC_4BPPV1_Format) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === THREE.RGBA_PVRTC_2BPPV1_Format) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (null !== (e = W.get("EXT_blend_minmax"))) { if (t === THREE.MinEquation) return e.MIN_EXT; if (t === THREE.MaxEquation) return e.MAX_EXT } return 0 } this.setFaceCulling = function (t, e) { t === THREE.CullFaceNone ? y.disable(y.CULL_FACE) : (e === THREE.FrontFaceDirectionCW ? y.frontFace(y.CW) : y.frontFace(y.CCW), t === THREE.CullFaceBack ? y.cullFace(y.BACK) : t === THREE.CullFaceFront ? y.cullFace(y.FRONT) : y.cullFace(y.FRONT_AND_BACK), y.enable(y.CULL_FACE)) }, this.setMaterialFaces = function (t) { I.setDoubleSided(t.side === THREE.DoubleSide), I.setFlipSided(t.side === THREE.BackSide) }, this.uploadTexture = function (t) { void 0 === t.__webglInit && (t.__webglInit = !0, t.addEventListener("dispose", dt), t.__webglTexture = y.createTexture(), H.info.memory.textures++), y.bindTexture(y.TEXTURE_2D, t.__webglTexture), y.pixelStorei(y.UNPACK_FLIP_Y_WEBGL, t.flipY), y.pixelStorei(y.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), y.pixelStorei(y.UNPACK_ALIGNMENT, t.unpackAlignment), t.image = Jt(t.image, Z); var e = t.image, r = THREE.Math.isPowerOfTwo(e.width) && THREE.Math.isPowerOfTwo(e.height), i = ne(t.format), n = ne(t.type); Zt(y.TEXTURE_2D, t, r); var a, o = t.mipmaps; if (t instanceof THREE.DataTexture) if (o.length > 0 && r) { for (var s = 0, h = o.length; s < h; s++)a = o[s], y.texImage2D(y.TEXTURE_2D, s, i, a.width, a.height, 0, i, n, a.data); t.generateMipmaps = !1 } else y.texImage2D(y.TEXTURE_2D, 0, i, e.width, e.height, 0, i, n, e.data); else if (t instanceof THREE.CompressedTexture) for (s = 0, h = o.length; s < h; s++)a = o[s], t.format !== THREE.RGBAFormat && t.format !== THREE.RGBFormat ? at().indexOf(i) > -1 ? y.compressedTexImage2D(y.TEXTURE_2D, s, i, a.width, a.height, 0, a.data) : THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : y.texImage2D(y.TEXTURE_2D, s, i, a.width, a.height, 0, i, n, a.data); else if (o.length > 0 && r) { for (s = 0, h = o.length; s < h; s++)a = o[s], y.texImage2D(y.TEXTURE_2D, s, i, i, n, a); t.generateMipmaps = !1 } else y.texImage2D(y.TEXTURE_2D, 0, i, i, n, t.image); t.generateMipmaps && r && y.generateMipmap(y.TEXTURE_2D), t.needsUpdate = !1, t.onUpdate && t.onUpdate() }, this.setTexture = function (t, e) { y.activeTexture(y.TEXTURE0 + e), t.needsUpdate ? H.uploadTexture(t) : y.bindTexture(y.TEXTURE_2D, t.__webglTexture) }, this.setRenderTarget = function (t) { var e, r, i, n, a, o = t instanceof THREE.WebGLRenderTargetCube; if (t && void 0 === t.__webglFramebuffer) { void 0 === t.depthBuffer && (t.depthBuffer = !0), void 0 === t.stencilBuffer && (t.stencilBuffer = !0), t.addEventListener("dispose", mt), t.__webglTexture = y.createTexture(), H.info.memory.textures++; var s = THREE.Math.isPowerOfTwo(t.width) && THREE.Math.isPowerOfTwo(t.height), h = ne(t.format), l = ne(t.type); if (o) { t.__webglFramebuffer = [], t.__webglRenderbuffer = [], y.bindTexture(y.TEXTURE_CUBE_MAP, t.__webglTexture), Zt(y.TEXTURE_CUBE_MAP, t, s); for (var c = 0; c < 6; c++)t.__webglFramebuffer[c] = y.createFramebuffer(), t.__webglRenderbuffer[c] = y.createRenderbuffer(), y.texImage2D(y.TEXTURE_CUBE_MAP_POSITIVE_X + c, 0, h, t.width, t.height, 0, h, l, null), ee(t.__webglFramebuffer[c], t, y.TEXTURE_CUBE_MAP_POSITIVE_X + c), re(t.__webglRenderbuffer[c], t); s && y.generateMipmap(y.TEXTURE_CUBE_MAP) } else t.__webglFramebuffer = y.createFramebuffer(), t.shareDepthFrom ? t.__webglRenderbuffer = t.shareDepthFrom.__webglRenderbuffer : t.__webglRenderbuffer = y.createRenderbuffer(), y.bindTexture(y.TEXTURE_2D, t.__webglTexture), Zt(y.TEXTURE_2D, t, s), y.texImage2D(y.TEXTURE_2D, 0, h, t.width, t.height, 0, h, l, null), ee(t.__webglFramebuffer, t, y.TEXTURE_2D), t.shareDepthFrom ? t.depthBuffer && !t.stencilBuffer ? y.framebufferRenderbuffer(y.FRAMEBUFFER, y.DEPTH_ATTACHMENT, y.RENDERBUFFER, t.__webglRenderbuffer) : t.depthBuffer && t.stencilBuffer && y.framebufferRenderbuffer(y.FRAMEBUFFER, y.DEPTH_STENCIL_ATTACHMENT, y.RENDERBUFFER, t.__webglRenderbuffer) : re(t.__webglRenderbuffer, t), s && y.generateMipmap(y.TEXTURE_2D); o ? y.bindTexture(y.TEXTURE_CUBE_MAP, null) : y.bindTexture(y.TEXTURE_2D, null), y.bindRenderbuffer(y.RENDERBUFFER, null), y.bindFramebuffer(y.FRAMEBUFFER, null) } t ? (e = o ? t.__webglFramebuffer[t.activeCubeFace] : t.__webglFramebuffer, r = t.width, i = t.height, n = 0, a = 0) : (e = null, r = P, i = F, n = C, a = L), e !== _ && (y.bindFramebuffer(y.FRAMEBUFFER, e), y.viewport(n, a, r, i), _ = e), U = r, B = i }, this.readRenderTargetPixels = function (t, e, r, i, n, a) { if (t instanceof THREE.WebGLRenderTarget) { if (t.__webglFramebuffer) { if (t.format !== THREE.RGBAFormat) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format."); var o = !1; t.__webglFramebuffer !== _ && (y.bindFramebuffer(y.FRAMEBUFFER, t.__webglFramebuffer), o = !0), y.checkFramebufferStatus(y.FRAMEBUFFER) === y.FRAMEBUFFER_COMPLETE ? y.readPixels(e, r, i, n, y.RGBA, y.UNSIGNED_BYTE, a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."), o && y.bindFramebuffer(y.FRAMEBUFFER, _) } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.initMaterial = function () { THREE.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, this.addPrePlugin = function () { THREE.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, this.addPostPlugin = function () { THREE.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, this.updateShadowMap = function () { THREE.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") } }, THREE.WebGLRenderTarget = function (t, e, r) { this.width = t, this.height = e, r = r || {}, this.wrapS = void 0 !== r.wrapS ? r.wrapS : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== r.wrapT ? r.wrapT : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== r.magFilter ? r.magFilter : THREE.LinearFilter, this.minFilter = void 0 !== r.minFilter ? r.minFilter : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.format = void 0 !== r.format ? r.format : THREE.RGBAFormat, this.type = void 0 !== r.type ? r.type : THREE.UnsignedByteType, this.depthBuffer = void 0 === r.depthBuffer || r.depthBuffer, this.stencilBuffer = void 0 === r.stencilBuffer || r.stencilBuffer, this.generateMipmaps = !0, this.shareDepthFrom = void 0 !== r.shareDepthFrom ? r.shareDepthFrom : null }, THREE.WebGLRenderTarget.prototype = { constructor: THREE.WebGLRenderTarget, setSize: function (t, e) { this.width = t, this.height = e }, clone: function () { var t = new THREE.WebGLRenderTarget(this.width, this.height); return t.wrapS = this.wrapS, t.wrapT = this.wrapT, t.magFilter = this.magFilter, t.minFilter = this.minFilter, t.anisotropy = this.anisotropy, t.offset.copy(this.offset), t.repeat.copy(this.repeat), t.format = this.format, t.type = this.type, t.depthBuffer = this.depthBuffer, t.stencilBuffer = this.stencilBuffer, t.generateMipmaps = this.generateMipmaps, t.shareDepthFrom = this.shareDepthFrom, t }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function (t, e, r) { THREE.WebGLRenderTarget.call(this, t, e, r), this.activeCubeFace = 0 }, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube, THREE.WebGLExtensions = function (t) { var e = {}; this.get = function (r) { if (void 0 !== e[r]) return e[r]; var i; switch (r) { case "EXT_texture_filter_anisotropic": i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = t.getExtension(r) }return null === i && THREE.warn("THREE.WebGLRenderer: " + r + " extension not supported."), e[r] = i, i } }, THREE.WebGLProgram = function () { var t = 0; return function (e, r, i, n) { var a = e, o = a.context, s = i.defines, h = i.__webglShader.uniforms, l = i.attributes, c = i.__webglShader.vertexShader, u = i.__webglShader.fragmentShader, E = i.index0AttributeName; void 0 === E && !0 === n.morphTargets && (E = "position"); var p = "SHADOWMAP_TYPE_BASIC"; n.shadowMapType === THREE.PCFShadowMap ? p = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === THREE.PCFSoftShadowMap && (p = "SHADOWMAP_TYPE_PCF_SOFT"); var f = "ENVMAP_TYPE_CUBE", d = "ENVMAP_MODE_REFLECTION", m = "ENVMAP_BLENDING_MULTIPLY"; if (n.envMap) { switch (i.envMap.mapping) { case THREE.CubeReflectionMapping: case THREE.CubeRefractionMapping: f = "ENVMAP_TYPE_CUBE"; break; case THREE.EquirectangularReflectionMapping: case THREE.EquirectangularRefractionMapping: f = "ENVMAP_TYPE_EQUIREC"; break; case THREE.SphericalReflectionMapping: f = "ENVMAP_TYPE_SPHERE" }switch (i.envMap.mapping) { case THREE.CubeRefractionMapping: case THREE.EquirectangularRefractionMapping: d = "ENVMAP_MODE_REFRACTION" }switch (i.combine) { case THREE.MultiplyOperation: m = "ENVMAP_BLENDING_MULTIPLY"; break; case THREE.MixOperation: m = "ENVMAP_BLENDING_MIX"; break; case THREE.AddOperation: m = "ENVMAP_BLENDING_ADD" } } var T, g, v = e.gammaFactor > 0 ? e.gammaFactor : 1, R = function (t) { var e, r, i = []; for (var n in t) !1 !== (e = t[n]) && (r = "#define " + n + " " + e, i.push(r)); return i.join("\n") }(s), y = o.createProgram(); i instanceof THREE.RawShaderMaterial ? (T = "", g = "") : (T = ["precision " + n.precision + " float;", "precision " + n.precision + " int;", R, n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", a.gammaInput ? "#define GAMMA_INPUT" : "", a.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + v, "#define MAX_DIR_LIGHTS " + n.maxDirLights, "#define MAX_POINT_LIGHTS " + n.maxPointLights, "#define MAX_SPOT_LIGHTS " + n.maxSpotLights, "#define MAX_HEMI_LIGHTS " + n.maxHemiLights, "#define MAX_SHADOWS " + n.maxShadows, "#define MAX_BONES " + n.maxBones, n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals ? "#define USE_MORPHNORMALS" : "", n.wrapAround ? "#define WRAP_AROUND" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", n.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "attribute vec2 uv2;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", ""].join("\n"), g = ["precision " + n.precision + " float;", "precision " + n.precision + " int;", n.bumpMap || n.normalMap || n.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", R, "#define MAX_DIR_LIGHTS " + n.maxDirLights, "#define MAX_POINT_LIGHTS " + n.maxPointLights, "#define MAX_SPOT_LIGHTS " + n.maxSpotLights, "#define MAX_HEMI_LIGHTS " + n.maxHemiLights, "#define MAX_SHADOWS " + n.maxShadows, n.alphaTest ? "#define ALPHATEST " + n.alphaTest : "", a.gammaInput ? "#define GAMMA_INPUT" : "", a.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.metal ? "#define METAL" : "", n.wrapAround ? "#define WRAP_AROUND" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", n.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", ""].join("\n")); var H = new THREE.WebGLShader(o, o.VERTEX_SHADER, T + c), x = new THREE.WebGLShader(o, o.FRAGMENT_SHADER, g + u); o.attachShader(y, H), o.attachShader(y, x), void 0 !== E && o.bindAttribLocation(y, 0, E), o.linkProgram(y); var b = o.getProgramInfoLog(y); !1 === o.getProgramParameter(y, o.LINK_STATUS) && THREE.error("THREE.WebGLProgram: shader error: " + o.getError(), "gl.VALIDATE_STATUS", o.getProgramParameter(y, o.VALIDATE_STATUS), "gl.getPRogramInfoLog", b), "" !== b && THREE.warn("THREE.WebGLProgram: gl.getProgramInfoLog()" + b), o.deleteShader(H), o.deleteShader(x); var _ = ["viewMatrix", "modelViewMatrix", "projectionMatrix", "normalMatrix", "modelMatrix", "cameraPosition", "morphTargetInfluences", "bindMatrix", "bindMatrixInverse"]; for (var w in n.useVertexTexture ? (_.push("boneTexture"), _.push("boneTextureWidth"), _.push("boneTextureHeight")) : _.push("boneGlobalMatrices"), n.logarithmicDepthBuffer && _.push("logDepthBufFC"), h) _.push(w); this.uniforms = function (t, e, r) { for (var i = {}, n = 0, a = r.length; n < a; n++) { var o = r[n]; i[o] = t.getUniformLocation(e, o) } return i }(o, y, _), _ = ["position", "normal", "uv", "uv2", "tangent", "color", "skinIndex", "skinWeight", "lineDistance"]; for (var M = 0; M < n.maxMorphTargets; M++)_.push("morphTarget" + M); for (M = 0; M < n.maxMorphNormals; M++)_.push("morphNormal" + M); for (var S in l) _.push(S); return this.attributes = function (t, e, r) { for (var i = {}, n = 0, a = r.length; n < a; n++) { var o = r[n]; i[o] = t.getAttribLocation(e, o) } return i }(o, y, _), this.attributesKeys = Object.keys(this.attributes), this.id = t++ , this.code = r, this.usedTimes = 1, this.program = y, this.vertexShader = H, this.fragmentShader = x, this } }(), THREE.WebGLShader = function (t, e, r) { var i = t.createShader(e); return t.shaderSource(i, r), t.compileShader(i), !1 === t.getShaderParameter(i, t.COMPILE_STATUS) && THREE.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(i) && THREE.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t.getShaderInfoLog(i), function (t) { for (var e = t.split("\n"), r = 0; r < e.length; r++)e[r] = r + 1 + ": " + e[r]; return e.join("\n") }(r)), i }, THREE.WebGLState = function (t, e) { var r = new Uint8Array(16), i = new Uint8Array(16), n = null, a = null, o = null, s = null, h = null, l = null, c = null, u = null, E = null, p = null, f = null, d = null, m = null, T = null, g = null, v = null; this.initAttributes = function () { for (var t = 0, e = r.length; t < e; t++)r[t] = 0 }, this.enableAttribute = function (e) { r[e] = 1, 0 === i[e] && (t.enableVertexAttribArray(e), i[e] = 1) }, this.disableUnusedAttributes = function () { for (var e = 0, n = i.length; e < n; e++)i[e] !== r[e] && (t.disableVertexAttribArray(e), i[e] = 0) }, this.setBlending = function (r, i, u, E, p, f, d) { r !== n && (r === THREE.NoBlending ? t.disable(t.BLEND) : r === THREE.AdditiveBlending ? (t.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE)) : r === THREE.SubtractiveBlending ? (t.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : r === THREE.MultiplyBlending ? (t.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR)) : r === THREE.CustomBlending ? t.enable(t.BLEND) : (t.enable(t.BLEND), t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)), n = r), r === THREE.CustomBlending ? (p = p || i, f = f || u, d = d || E, i === a && p === h || (t.blendEquationSeparate(e(i), e(p)), a = i, h = p), u === o && E === s && f === l && d === c || (t.blendFuncSeparate(e(u), e(E), e(f), e(d)), o = u, s = E, l = f, c = d)) : (a = null, o = null, s = null, h = null, l = null, c = null) }, this.setDepthTest = function (e) { u !== e && (e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), u = e) }, this.setDepthWrite = function (e) { E !== e && (t.depthMask(e), E = e) }, this.setColorWrite = function (e) { p !== e && (t.colorMask(e, e, e, e), p = e) }, this.setDoubleSided = function (e) { f !== e && (e ? t.disable(t.CULL_FACE) : t.enable(t.CULL_FACE), f = e) }, this.setFlipSided = function (e) { d !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), d = e) }, this.setLineWidth = function (e) { e !== m && (t.lineWidth(e), m = e) }, this.setPolygonOffset = function (e, r, i) { T !== e && (e ? t.enable(t.POLYGON_OFFSET_FILL) : t.disable(t.POLYGON_OFFSET_FILL), T = e), !e || g === r && v === i || (t.polygonOffset(r, i), g = r, v = i) }, this.reset = function () { for (var t = 0; t < i.length; t++)i[t] = 0; n = null, u = null, E = null, p = null, f = null, d = null } }, THREE.LensFlarePlugin = function (t, e) { var r, i, n, a, o, s, h, l, c = t.context, u = function () { var e, u = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]), E = new Uint16Array([0, 1, 2, 0, 2, 3]); r = c.createBuffer(), i = c.createBuffer(), c.bindBuffer(c.ARRAY_BUFFER, r), c.bufferData(c.ARRAY_BUFFER, u, c.STATIC_DRAW), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, i), c.bufferData(c.ELEMENT_ARRAY_BUFFER, E, c.STATIC_DRAW), h = c.createTexture(), l = c.createTexture(), c.bindTexture(c.TEXTURE_2D, h), c.texImage2D(c.TEXTURE_2D, 0, c.RGB, 16, 16, 0, c.RGB, c.UNSIGNED_BYTE, null), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.bindTexture(c.TEXTURE_2D, l), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, 16, 16, 0, c.RGBA, c.UNSIGNED_BYTE, null), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), e = (s = c.getParameter(c.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0) ? { vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"), fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n") } : { vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"), fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n") }, n = function (e) { var r = c.createProgram(), i = c.createShader(c.FRAGMENT_SHADER), n = c.createShader(c.VERTEX_SHADER), a = "precision " + t.getPrecision() + " float;\n"; return c.shaderSource(i, a + e.fragmentShader), c.shaderSource(n, a + e.vertexShader), c.compileShader(i), c.compileShader(n), c.attachShader(r, i), c.attachShader(r, n), c.linkProgram(r), r }(e), a = { vertex: c.getAttribLocation(n, "position"), uv: c.getAttribLocation(n, "uv") }, o = { renderType: c.getUniformLocation(n, "renderType"), map: c.getUniformLocation(n, "map"), occlusionMap: c.getUniformLocation(n, "occlusionMap"), opacity: c.getUniformLocation(n, "opacity"), color: c.getUniformLocation(n, "color"), scale: c.getUniformLocation(n, "scale"), rotation: c.getUniformLocation(n, "rotation"), screenPosition: c.getUniformLocation(n, "screenPosition") } }; this.render = function (E, p, f, d) { if (0 !== e.length) { var m = new THREE.Vector3, T = d / f, g = .5 * f, v = .5 * d, R = 16 / d, y = new THREE.Vector2(R * T, R), H = new THREE.Vector3(1, 1, 0), x = new THREE.Vector2(1, 1); void 0 === n && u(), c.useProgram(n), c.enableVertexAttribArray(a.vertex), c.enableVertexAttribArray(a.uv), c.uniform1i(o.occlusionMap, 0), c.uniform1i(o.map, 1), c.bindBuffer(c.ARRAY_BUFFER, r), c.vertexAttribPointer(a.vertex, 2, c.FLOAT, !1, 16, 0), c.vertexAttribPointer(a.uv, 2, c.FLOAT, !1, 16, 8), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, i), c.disable(c.CULL_FACE), c.depthMask(!1); for (var b = 0, _ = e.length; b < _; b++) { R = 16 / d, y.set(R * T, R); var w = e[b]; if (m.set(w.matrixWorld.elements[12], w.matrixWorld.elements[13], w.matrixWorld.elements[14]), m.applyMatrix4(p.matrixWorldInverse), m.applyProjection(p.projectionMatrix), H.copy(m), x.x = H.x * g + g, x.y = H.y * v + v, s || x.x > 0 && x.x < f && x.y > 0 && x.y < d) { c.activeTexture(c.TEXTURE1), c.bindTexture(c.TEXTURE_2D, h), c.copyTexImage2D(c.TEXTURE_2D, 0, c.RGB, x.x - 8, x.y - 8, 16, 16, 0), c.uniform1i(o.renderType, 0), c.uniform2f(o.scale, y.x, y.y), c.uniform3f(o.screenPosition, H.x, H.y, H.z), c.disable(c.BLEND), c.enable(c.DEPTH_TEST), c.drawElements(c.TRIANGLES, 6, c.UNSIGNED_SHORT, 0), c.activeTexture(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, l), c.copyTexImage2D(c.TEXTURE_2D, 0, c.RGBA, x.x - 8, x.y - 8, 16, 16, 0), c.uniform1i(o.renderType, 1), c.disable(c.DEPTH_TEST), c.activeTexture(c.TEXTURE1), c.bindTexture(c.TEXTURE_2D, h), c.drawElements(c.TRIANGLES, 6, c.UNSIGNED_SHORT, 0), w.positionScreen.copy(H), w.customUpdateCallback ? w.customUpdateCallback(w) : w.updateLensFlares(), c.uniform1i(o.renderType, 2), c.enable(c.BLEND); for (var M = 0, S = w.lensFlares.length; M < S; M++) { var A = w.lensFlares[M]; A.opacity > .001 && A.scale > .001 && (H.x = A.x, H.y = A.y, H.z = A.z, R = A.size * A.scale / d, y.x = R * T, y.y = R, c.uniform3f(o.screenPosition, H.x, H.y, H.z), c.uniform2f(o.scale, y.x, y.y), c.uniform1f(o.rotation, A.rotation), c.uniform1f(o.opacity, A.opacity), c.uniform3f(o.color, A.color.r, A.color.g, A.color.b), t.state.setBlending(A.blending, A.blendEquation, A.blendSrc, A.blendDst), t.setTexture(A.texture, 1), c.drawElements(c.TRIANGLES, 6, c.UNSIGNED_SHORT, 0)) } } } c.enable(c.CULL_FACE), c.enable(c.DEPTH_TEST), c.depthMask(!0), t.resetGLState() } } }, THREE.ShadowMapPlugin = function (t, e, r, i) { var n, a, o, s, h = t.context, l = new THREE.Frustum, c = new THREE.Matrix4, u = new THREE.Vector3, E = new THREE.Vector3, p = new THREE.Vector3, f = [], d = THREE.ShaderLib.depthRGBA, m = THREE.UniformsUtils.clone(d.uniforms); function T(t, e, i) { if (e.visible) { var n = r[e.id]; if (n && e.castShadow && (!1 === e.frustumCulled || !0 === l.intersectsObject(e))) for (var a = 0, o = n.length; a < o; a++) { var s = n[a]; e._modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), f.push(s) } for (a = 0, o = e.children.length; a < o; a++)T(t, e.children[a], i) } } function g(t, e) { var r = new THREE.DirectionalLight; r.isVirtual = !0, r.onlyShadow = !0, r.castShadow = !0, r.shadowCameraNear = t.shadowCameraNear, r.shadowCameraFar = t.shadowCameraFar, r.shadowCameraLeft = t.shadowCameraLeft, r.shadowCameraRight = t.shadowCameraRight, r.shadowCameraBottom = t.shadowCameraBottom, r.shadowCameraTop = t.shadowCameraTop, r.shadowCameraVisible = t.shadowCameraVisible, r.shadowDarkness = t.shadowDarkness, r.shadowBias = t.shadowCascadeBias[e], r.shadowMapWidth = t.shadowCascadeWidth[e], r.shadowMapHeight = t.shadowCascadeHeight[e], r.pointsWorld = [], r.pointsFrustum = []; for (var i = r.pointsWorld, n = r.pointsFrustum, a = 0; a < 8; a++)i[a] = new THREE.Vector3, n[a] = new THREE.Vector3; var o = t.shadowCascadeNearZ[e], s = t.shadowCascadeFarZ[e]; return n[0].set(-1, -1, o), n[1].set(1, -1, o), n[2].set(-1, 1, o), n[3].set(1, 1, o), n[4].set(-1, -1, s), n[5].set(1, -1, s), n[6].set(-1, 1, s), n[7].set(1, 1, s), r } function v(t, e) { var r = t.shadowCascadeArray[e]; r.position.copy(t.position), r.target.position.copy(t.target.position), r.lookAt(r.target), r.shadowCameraVisible = t.shadowCameraVisible, r.shadowDarkness = t.shadowDarkness, r.shadowBias = t.shadowCascadeBias[e]; var i = t.shadowCascadeNearZ[e], n = t.shadowCascadeFarZ[e], a = r.pointsFrustum; a[0].z = i, a[1].z = i, a[2].z = i, a[3].z = i, a[4].z = n, a[5].z = n, a[6].z = n, a[7].z = n } function R(t, e) { var r = e.shadowCamera, i = e.pointsFrustum, n = e.pointsWorld; u.set(1 / 0, 1 / 0, 1 / 0), E.set(-1 / 0, -1 / 0, -1 / 0); for (var a = 0; a < 8; a++) { var o = n[a]; o.copy(i[a]), o.unproject(t), o.applyMatrix4(r.matrixWorldInverse), o.x < u.x && (u.x = o.x), o.x > E.x && (E.x = o.x), o.y < u.y && (u.y = o.y), o.y > E.y && (E.y = o.y), o.z < u.z && (u.z = o.z), o.z > E.z && (E.z = o.z) } r.left = u.x, r.right = E.x, r.top = E.y, r.bottom = u.y, r.updateProjectionMatrix() } function y(t) { return t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[0] : t.material } n = new THREE.ShaderMaterial({ uniforms: m, vertexShader: d.vertexShader, fragmentShader: d.fragmentShader }), a = new THREE.ShaderMaterial({ uniforms: m, vertexShader: d.vertexShader, fragmentShader: d.fragmentShader, morphTargets: !0 }), o = new THREE.ShaderMaterial({ uniforms: m, vertexShader: d.vertexShader, fragmentShader: d.fragmentShader, skinning: !0 }), s = new THREE.ShaderMaterial({ uniforms: m, vertexShader: d.vertexShader, fragmentShader: d.fragmentShader, morphTargets: !0, skinning: !0 }), n._shadowPass = !0, a._shadowPass = !0, o._shadowPass = !0, s._shadowPass = !0, this.render = function (r, u) { if (!1 !== t.shadowMapEnabled) { var E, d, m, H, x, b, _, w, M, S, A, C, L, P = [], F = 0; for (h.clearColor(1, 1, 1, 1), h.disable(h.BLEND), h.enable(h.CULL_FACE), h.frontFace(h.CCW), t.shadowMapCullFace === THREE.CullFaceFront ? h.cullFace(h.FRONT) : h.cullFace(h.BACK), t.state.setDepthTest(!0), E = 0, d = e.length; E < d; E++)if ((L = e[E]).castShadow) if (L instanceof THREE.DirectionalLight && L.shadowCascade) for (x = 0; x < L.shadowCascadeCount; x++) { var U; if (L.shadowCascadeArray[x]) U = L.shadowCascadeArray[x]; else { (U = g(L, x)).originalCamera = u; var B = new THREE.Gyroscope; B.position.copy(L.shadowCascadeOffset), B.add(U), B.add(U.target), u.add(B), L.shadowCascadeArray[x] = U } v(L, x), P[F] = U, F++ } else P[F] = L, F++; for (E = 0, d = P.length; E < d; E++) { if (!(L = P[E]).shadowMap) { var D = THREE.LinearFilter; t.shadowMapType === THREE.PCFSoftShadowMap && (D = THREE.NearestFilter); var V = { minFilter: D, magFilter: D, format: THREE.RGBAFormat }; L.shadowMap = new THREE.WebGLRenderTarget(L.shadowMapWidth, L.shadowMapHeight, V), L.shadowMapSize = new THREE.Vector2(L.shadowMapWidth, L.shadowMapHeight), L.shadowMatrix = new THREE.Matrix4 } if (!L.shadowCamera) { if (L instanceof THREE.SpotLight) L.shadowCamera = new THREE.PerspectiveCamera(L.shadowCameraFov, L.shadowMapWidth / L.shadowMapHeight, L.shadowCameraNear, L.shadowCameraFar); else { if (!(L instanceof THREE.DirectionalLight)) { THREE.error("THREE.ShadowMapPlugin: Unsupported light type for shadow", L); continue } L.shadowCamera = new THREE.OrthographicCamera(L.shadowCameraLeft, L.shadowCameraRight, L.shadowCameraTop, L.shadowCameraBottom, L.shadowCameraNear, L.shadowCameraFar) } r.add(L.shadowCamera), !0 === r.autoUpdate && r.updateMatrixWorld() } var z, k, N; for (L.shadowCameraVisible && !L.cameraHelper && (L.cameraHelper = new THREE.CameraHelper(L.shadowCamera), r.add(L.cameraHelper)), L.isVirtual && U.originalCamera == u && R(u, L), b = L.shadowMap, _ = L.shadowMatrix, (w = L.shadowCamera).position.setFromMatrixPosition(L.matrixWorld), p.setFromMatrixPosition(L.target.matrixWorld), w.lookAt(p), w.updateMatrixWorld(), w.matrixWorldInverse.getInverse(w.matrixWorld), L.cameraHelper && (L.cameraHelper.visible = L.shadowCameraVisible), L.shadowCameraVisible && L.cameraHelper.update(), _.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), _.multiply(w.projectionMatrix), _.multiply(w.matrixWorldInverse), c.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse), l.setFromMatrix(c), t.setRenderTarget(b), t.clear(), f.length = 0, T(r, r, w), m = 0, H = f.length; m < H; m++)C = (A = f[m]).object, M = A.buffer, z = y(C), k = void 0 !== C.geometry.morphTargets && C.geometry.morphTargets.length > 0 && z.morphTargets, N = C instanceof THREE.SkinnedMesh && z.skinning, S = C.customDepthMaterial ? C.customDepthMaterial : N ? k ? s : o : k ? a : n, t.setMaterialFaces(z), M instanceof THREE.BufferGeometry ? t.renderBufferDirect(w, e, null, S, M, C) : t.renderBuffer(w, e, null, S, M, C); for (m = 0, H = i.length; m < H; m++)(C = (A = i[m]).object).visible && C.castShadow && (C._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, C.matrixWorld), t.renderImmediateObject(w, e, null, n, C)) } var O = t.getClearColor(), G = t.getClearAlpha(); h.clearColor(O.r, O.g, O.b, G), h.enable(h.BLEND), t.shadowMapCullFace === THREE.CullFaceFront && h.cullFace(h.BACK), t.resetGLState() } } }, THREE.SpritePlugin = function (t, e) { var r, i, n, a, o, s, h = t.context, l = new THREE.Vector3, c = new THREE.Quaternion, u = new THREE.Vector3, E = function () { var e = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), l = new Uint16Array([0, 1, 2, 0, 2, 3]); r = h.createBuffer(), i = h.createBuffer(), h.bindBuffer(h.ARRAY_BUFFER, r), h.bufferData(h.ARRAY_BUFFER, e, h.STATIC_DRAW), h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, i), h.bufferData(h.ELEMENT_ARRAY_BUFFER, l, h.STATIC_DRAW), n = function () { var e = h.createProgram(), r = h.createShader(h.VERTEX_SHADER), i = h.createShader(h.FRAGMENT_SHADER); return h.shaderSource(r, ["precision " + t.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")), h.shaderSource(i, ["precision " + t.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")), h.compileShader(r), h.compileShader(i), h.attachShader(e, r), h.attachShader(e, i), h.linkProgram(e), e }(), a = { position: h.getAttribLocation(n, "position"), uv: h.getAttribLocation(n, "uv") }, o = { uvOffset: h.getUniformLocation(n, "uvOffset"), uvScale: h.getUniformLocation(n, "uvScale"), rotation: h.getUniformLocation(n, "rotation"), scale: h.getUniformLocation(n, "scale"), color: h.getUniformLocation(n, "color"), map: h.getUniformLocation(n, "map"), opacity: h.getUniformLocation(n, "opacity"), modelViewMatrix: h.getUniformLocation(n, "modelViewMatrix"), projectionMatrix: h.getUniformLocation(n, "projectionMatrix"), fogType: h.getUniformLocation(n, "fogType"), fogDensity: h.getUniformLocation(n, "fogDensity"), fogNear: h.getUniformLocation(n, "fogNear"), fogFar: h.getUniformLocation(n, "fogFar"), fogColor: h.getUniformLocation(n, "fogColor"), alphaTest: h.getUniformLocation(n, "alphaTest") }; var c = document.createElement("canvas"); c.width = 8, c.height = 8; var u = c.getContext("2d"); u.fillStyle = "white", u.fillRect(0, 0, 8, 8), (s = new THREE.Texture(c)).needsUpdate = !0 }; function p(t, e) { return t.z !== e.z ? e.z - t.z : e.id - t.id } this.render = function (f, d) { if (0 !== e.length) { void 0 === n && E(), h.useProgram(n), h.enableVertexAttribArray(a.position), h.enableVertexAttribArray(a.uv), h.disable(h.CULL_FACE), h.enable(h.BLEND), h.bindBuffer(h.ARRAY_BUFFER, r), h.vertexAttribPointer(a.position, 2, h.FLOAT, !1, 16, 0), h.vertexAttribPointer(a.uv, 2, h.FLOAT, !1, 16, 8), h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, i), h.uniformMatrix4fv(o.projectionMatrix, !1, d.projectionMatrix.elements), h.activeTexture(h.TEXTURE0), h.uniform1i(o.map, 0); var m = 0, T = 0, g = f.fog; g ? (h.uniform3f(o.fogColor, g.color.r, g.color.g, g.color.b), g instanceof THREE.Fog ? (h.uniform1f(o.fogNear, g.near), h.uniform1f(o.fogFar, g.far), h.uniform1i(o.fogType, 1), m = 1, T = 1) : g instanceof THREE.FogExp2 && (h.uniform1f(o.fogDensity, g.density), h.uniform1i(o.fogType, 2), m = 2, T = 2)) : (h.uniform1i(o.fogType, 0), m = 0, T = 0); for (var v = 0, R = e.length; v < R; v++) { (H = e[v])._modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, H.matrixWorld), H.z = -H._modelViewMatrix.elements[14] } e.sort(p); var y = []; for (v = 0, R = e.length; v < R; v++) { var H, x = (H = e[v]).material; h.uniform1f(o.alphaTest, x.alphaTest), h.uniformMatrix4fv(o.modelViewMatrix, !1, H._modelViewMatrix.elements), H.matrixWorld.decompose(l, c, u), y[0] = u.x, y[1] = u.y; var b = 0; f.fog && x.fog && (b = T), m !== b && (h.uniform1i(o.fogType, b), m = b), null !== x.map ? (h.uniform2f(o.uvOffset, x.map.offset.x, x.map.offset.y), h.uniform2f(o.uvScale, x.map.repeat.x, x.map.repeat.y)) : (h.uniform2f(o.uvOffset, 0, 0), h.uniform2f(o.uvScale, 1, 1)), h.uniform1f(o.opacity, x.opacity), h.uniform3f(o.color, x.color.r, x.color.g, x.color.b), h.uniform1f(o.rotation, x.rotation), h.uniform2fv(o.scale, y), t.state.setBlending(x.blending, x.blendEquation, x.blendSrc, x.blendDst), t.state.setDepthTest(x.depthTest), t.state.setDepthWrite(x.depthWrite), x.map && x.map.image && x.map.image.width ? t.setTexture(x.map, 0) : t.setTexture(s, 0), h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0) } h.enable(h.CULL_FACE), t.resetGLState() } } }, THREE.GeometryUtils = { merge: function (t, e, r) { var i; THREE.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e instanceof THREE.Mesh && (e.matrixAutoUpdate && e.updateMatrix(), i = e.matrix, e = e.geometry), t.merge(e, i, r) }, center: function (t) { return THREE.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center() } }, THREE.ImageUtils = { crossOrigin: void 0, loadTexture: function (t, e, r, i) { var n = new THREE.ImageLoader; n.crossOrigin = this.crossOrigin; var a = new THREE.Texture(void 0, e); return n.load(t, function (t) { a.image = t, a.needsUpdate = !0, r && r(a) }, void 0, function (t) { i && i(t) }), a.sourceFile = t, a }, loadTextureCube: function (t, e, r, i) { var n = new THREE.ImageLoader; n.crossOrigin = this.crossOrigin; var a = new THREE.CubeTexture([], e); a.flipY = !1; for (var o = 0, s = function (e) { n.load(t[e], function (t) { a.images[e] = t, 6 === (o += 1) && (a.needsUpdate = !0, r && r(a)) }, void 0, i) }, h = 0, l = t.length; h < l; ++h)s(h); return a }, loadCompressedTexture: function () { THREE.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, loadCompressedTextureCube: function () { THREE.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }, getNormalMap: function (t, e) { var r = function (t, e) { return [t[0] - e[0], t[1] - e[1], t[2] - e[2]] }, i = function (t) { var e = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]); return [t[0] / e, t[1] / e, t[2] / e] }; e |= 1; var n = t.width, a = t.height, o = document.createElement("canvas"); o.width = n, o.height = a; var s = o.getContext("2d"); s.drawImage(t, 0, 0); for (var h, l, c = s.getImageData(0, 0, n, a).data, u = s.createImageData(n, a), E = u.data, p = 0; p < n; p++)for (var f = 0; f < a; f++) { var d = f - 1 < 0 ? 0 : f - 1, m = f + 1 > a - 1 ? a - 1 : f + 1, T = p - 1 < 0 ? 0 : p - 1, g = p + 1 > n - 1 ? n - 1 : p + 1, v = [], R = [0, 0, c[4 * (f * n + p)] / 255 * e]; v.push([-1, 0, c[4 * (f * n + T)] / 255 * e]), v.push([-1, -1, c[4 * (d * n + T)] / 255 * e]), v.push([0, -1, c[4 * (d * n + p)] / 255 * e]), v.push([1, -1, c[4 * (d * n + g)] / 255 * e]), v.push([1, 0, c[4 * (f * n + g)] / 255 * e]), v.push([1, 1, c[4 * (m * n + g)] / 255 * e]), v.push([0, 1, c[4 * (m * n + p)] / 255 * e]), v.push([-1, 1, c[4 * (m * n + T)] / 255 * e]); for (var y = [], H = v.length, x = 0; x < H; x++) { var b = v[x], _ = v[(x + 1) % H]; b = r(b, R), _ = r(_, R), y.push(i((l = _, [(h = b)[1] * l[2] - h[2] * l[1], h[2] * l[0] - h[0] * l[2], h[0] * l[1] - h[1] * l[0]]))) } var w = [0, 0, 0]; for (x = 0; x < y.length; x++)w[0] += y[x][0], w[1] += y[x][1], w[2] += y[x][2]; w[0] /= y.length, w[1] /= y.length, w[2] /= y.length; var M = 4 * (f * n + p); E[M] = (w[0] + 1) / 2 * 255 | 0, E[M + 1] = (w[1] + 1) / 2 * 255 | 0, E[M + 2] = 255 * w[2] | 0, E[M + 3] = 255 } return s.putImageData(u, 0, 0), o }, generateDataTexture: function (t, e, r) { for (var i = t * e, n = new Uint8Array(3 * i), a = Math.floor(255 * r.r), o = Math.floor(255 * r.g), s = Math.floor(255 * r.b), h = 0; h < i; h++)n[3 * h] = a, n[3 * h + 1] = o, n[3 * h + 2] = s; var l = new THREE.DataTexture(n, t, e, THREE.RGBFormat); return l.needsUpdate = !0, l } }, THREE.SceneUtils = { createMultiMaterialObject: function (t, e) { for (var r = new THREE.Object3D, i = 0, n = e.length; i < n; i++)r.add(new THREE.Mesh(t, e[i])); return r }, detach: function (t, e, r) { t.applyMatrix(e.matrixWorld), e.remove(t), r.add(t) }, attach: function (t, e, r) { var i = new THREE.Matrix4; i.getInverse(r.matrixWorld), t.applyMatrix(i), e.remove(t), r.add(t) } }, THREE.FontUtils = { faces: {}, face: "helvetiker", weight: "normal", style: "normal", size: 150, divisions: 10, getFace: function () { try { return this.faces[this.face][this.weight][this.style] } catch (t) { throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing." } }, loadFace: function (t) { var e = t.familyName.toLowerCase(); return this.faces[e] = this.faces[e] || {}, this.faces[e][t.cssFontWeight] = this.faces[e][t.cssFontWeight] || {}, this.faces[e][t.cssFontWeight][t.cssFontStyle] = t, this.faces[e][t.cssFontWeight][t.cssFontStyle] = t, t }, drawText: function (t) { var e, r = this.getFace(), i = this.size / r.resolution, n = 0, a = String(t).split(""), o = a.length, s = []; for (e = 0; e < o; e++) { var h = new THREE.Path, l = this.extractGlyphPoints(a[e], r, i, n, h); n += l.offset, s.push(l.path) } return { paths: s, offset: n / 2 } }, extractGlyphPoints: function (t, e, r, i, n) { var a, o, s, h, l, c, u, E, p, f, d, m, T, g, v, R, y, H, x = [], b = e.glyphs[t] || e.glyphs["?"]; if (b) { if (b.o) for (l = (h = b._cachedOutline || (b._cachedOutline = b.o.split(" "))).length, c = r, u = r, a = 0; a < l;)switch (h[a++]) { case "m": E = h[a++] * c + i, p = h[a++] * u, n.moveTo(E, p); break; case "l": E = h[a++] * c + i, p = h[a++] * u, n.lineTo(E, p); break; case "q": if (f = h[a++] * c + i, d = h[a++] * u, g = h[a++] * c + i, v = h[a++] * u, n.quadraticCurveTo(g, v, f, d), H = x[x.length - 1]) for (m = H.x, T = H.y, o = 1, s = this.divisions; o <= s; o++) { var _ = o / s; THREE.Shape.Utils.b2(_, m, g, f), THREE.Shape.Utils.b2(_, T, v, d) } break; case "b": if (f = h[a++] * c + i, d = h[a++] * u, g = h[a++] * c + i, v = h[a++] * u, R = h[a++] * c + i, y = h[a++] * u, n.bezierCurveTo(g, v, R, y, f, d), H = x[x.length - 1]) for (m = H.x, T = H.y, o = 1, s = this.divisions; o <= s; o++) { _ = o / s; THREE.Shape.Utils.b3(_, m, g, R, f), THREE.Shape.Utils.b3(_, T, v, y, d) } }return { offset: b.ha * r, path: n } } } }, THREE.FontUtils.generateShapes = function (t, e) { var r = void 0 !== (e = e || {}).size ? e.size : 100, i = void 0 !== e.curveSegments ? e.curveSegments : 4, n = void 0 !== e.font ? e.font : "helvetiker", a = void 0 !== e.weight ? e.weight : "normal", o = void 0 !== e.style ? e.style : "normal"; THREE.FontUtils.size = r, THREE.FontUtils.divisions = i, THREE.FontUtils.face = n, THREE.FontUtils.weight = a, THREE.FontUtils.style = o; for (var s = THREE.FontUtils.drawText(t).paths, h = [], l = 0, c = s.length; l < c; l++)Array.prototype.push.apply(h, s[l].toShapes()); return h }, function (t) { var e = function (t) { for (var e = t.length, r = 0, i = e - 1, n = 0; n < e; i = n++)r += t[i].x * t[n].y - t[n].x * t[i].y; return .5 * r }, r = function (t, e, r, i, n, a) { var o, s, h, l, c, u, E, p, f, d, m, T, g, v, R; if (s = t[a[e]].x, h = t[a[e]].y, l = t[a[r]].x, c = t[a[r]].y, u = t[a[i]].x, 1e-10 > (l - s) * ((E = t[a[i]].y) - h) - (c - h) * (u - s)) return !1; for (d = u - l, m = E - c, T = s - u, g = h - E, v = l - s, R = c - h, o = 0; o < n; o++)if (p = t[a[o]].x, f = t[a[o]].y, !(p === s && f === h || p === l && f === c || p === u && f === E) && d * (f - c) - m * (p - l) >= -1e-10 && T * (f - E) - g * (p - u) >= -1e-10 && v * (f - h) - R * (p - s) >= -1e-10) return !1; return !0 }; t.Triangulate = function (t, i) { var n = t.length; if (n < 3) return null; var a, o, s, h = [], l = [], c = []; if (e(t) > 0) for (o = 0; o < n; o++)l[o] = o; else for (o = 0; o < n; o++)l[o] = n - 1 - o; var u = n, E = 2 * u; for (o = u - 1; u > 2;) { if (E-- <= 0) return THREE.warn("THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()"), i ? c : h; if (u <= (a = o) && (a = 0), u <= (o = a + 1) && (o = 0), u <= (s = o + 1) && (s = 0), r(t, a, o, s, u, l)) { var p, f, d, m, T; for (p = l[a], f = l[o], d = l[s], h.push([t[p], t[f], t[d]]), c.push([l[a], l[o], l[s]]), m = o, T = o + 1; T < u; m++ , T++)l[m] = l[T]; E = 2 * --u } } return i ? c : h }, t.Triangulate.area = e }(THREE.FontUtils), self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace }, THREE.typeface_js = self._typeface_js, THREE.Audio = function (t) { THREE.Object3D.call(this), this.type = "Audio", this.context = t.context, this.source = this.context.createBufferSource(), this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.panner = this.context.createPanner(), this.panner.connect(this.gain), this.autoplay = !1, this.startTime = 0, this.isPlaying = !1 }, THREE.Audio.prototype = Object.create(THREE.Object3D.prototype), THREE.Audio.prototype.constructor = THREE.Audio, THREE.Audio.prototype.load = function (t) { var e = this, r = new XMLHttpRequest; return r.open("GET", t, !0), r.responseType = "arraybuffer", r.onload = function (t) { e.context.decodeAudioData(this.response, function (t) { e.source.buffer = t, e.autoplay && e.play() }) }, r.send(), this }, THREE.Audio.prototype.play = function () { if (!0 !== this.isPlaying) { var t = this.context.createBufferSource(); t.buffer = this.source.buffer, t.loop = this.source.loop, t.onended = this.source.onended, t.connect(this.panner), t.start(0, this.startTime), this.isPlaying = !0, this.source = t } else THREE.warn("THREE.Audio: Audio is already playing.") }, THREE.Audio.prototype.pause = function () { this.source.stop(), this.startTime = this.context.currentTime }, THREE.Audio.prototype.stop = function () { this.source.stop(), this.startTime = 0 }, THREE.Audio.prototype.onEnded = function () { this.isPlaying = !1 }, THREE.Audio.prototype.setLoop = function (t) { this.source.loop = t }, THREE.Audio.prototype.setRefDistance = function (t) { this.panner.refDistance = t }, THREE.Audio.prototype.setRolloffFactor = function (t) { this.panner.rolloffFactor = t }, THREE.Audio.prototype.setVolume = function (t) { this.gain.gain.value = t }, THREE.Audio.prototype.updateMatrixWorld = function () { var t = new THREE.Vector3; return function (e) { THREE.Object3D.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z) } }(), THREE.AudioListener = function () { THREE.Object3D.call(this), this.type = "AudioListener", this.context = new (window.AudioContext || window.webkitAudioContext) }, THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype), THREE.AudioListener.prototype.constructor = THREE.AudioListener, THREE.AudioListener.prototype.updateMatrixWorld = function () { var t = new THREE.Vector3, e = new THREE.Quaternion, r = new THREE.Vector3, i = new THREE.Vector3, n = new THREE.Vector3, a = new THREE.Vector3; return function (o) { THREE.Object3D.prototype.updateMatrixWorld.call(this, o); var s = this.context.listener, h = this.up; this.matrixWorld.decompose(t, e, r), i.set(0, 0, -1).applyQuaternion(e), n.subVectors(t, a), s.setPosition(t.x, t.y, t.z), s.setOrientation(i.x, i.y, i.z, h.x, h.y, h.z), s.setVelocity(n.x, n.y, n.z), a.copy(t) } }(), THREE.Curve = function () { }, THREE.Curve.prototype.getPoint = function (t) { return THREE.warn("THREE.Curve: Warning, getPoint() not implemented!"), null }, THREE.Curve.prototype.getPointAt = function (t) { var e = this.getUtoTmapping(t); return this.getPoint(e) }, THREE.Curve.prototype.getPoints = function (t) { t || (t = 5); var e, r = []; for (e = 0; e <= t; e++)r.push(this.getPoint(e / t)); return r }, THREE.Curve.prototype.getSpacedPoints = function (t) { t || (t = 5); var e, r = []; for (e = 0; e <= t; e++)r.push(this.getPointAt(e / t)); return r }, THREE.Curve.prototype.getLength = function () { var t = this.getLengths(); return t[t.length - 1] }, THREE.Curve.prototype.getLengths = function (t) { if (t || (t = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length == t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var e, r, i = [], n = this.getPoint(0), a = 0; for (i.push(0), r = 1; r <= t; r++)a += (e = this.getPoint(r / t)).distanceTo(n), i.push(a), n = e; return this.cacheArcLengths = i, i }, THREE.Curve.prototype.updateArcLengths = function () { this.needsUpdate = !0, this.getLengths() }, THREE.Curve.prototype.getUtoTmapping = function (t, e) { var r, i = this.getLengths(), n = 0, a = i.length; r = e || t * i[a - 1]; for (var o, s = 0, h = a - 1; s <= h;)if ((o = i[n = Math.floor(s + (h - s) / 2)] - r) < 0) s = n + 1; else { if (!(o > 0)) { h = n; break } h = n - 1 } if (i[n = h] == r) return n / (a - 1); var l = i[n]; return (n + (r - l) / (i[n + 1] - l)) / (a - 1) }, THREE.Curve.prototype.getTangent = function (t) { var e = t - 1e-4, r = t + 1e-4; e < 0 && (e = 0), r > 1 && (r = 1); var i = this.getPoint(e); return this.getPoint(r).clone().sub(i).normalize() }, THREE.Curve.prototype.getTangentAt = function (t) { var e = this.getUtoTmapping(t); return this.getTangent(e) }, THREE.Curve.Utils = { tangentQuadraticBezier: function (t, e, r, i) { return 2 * (1 - t) * (r - e) + 2 * t * (i - r) }, tangentCubicBezier: function (t, e, r, i, n) { return -3 * e * (1 - t) * (1 - t) + 3 * r * (1 - t) * (1 - t) - 6 * t * r * (1 - t) + 6 * t * i * (1 - t) - 3 * t * t * i + 3 * t * t * n }, tangentSpline: function (t, e, r, i, n) { return 6 * t * t - 6 * t + (3 * t * t - 4 * t + 1) + (-6 * t * t + 6 * t) + (3 * t * t - 2 * t) }, interpolate: function (t, e, r, i, n) { var a = .5 * (r - t), o = .5 * (i - e), s = n * n; return (2 * e - 2 * r + a + o) * (n * s) + (-3 * e + 3 * r - 2 * a - o) * s + a * n + e } }, THREE.Curve.create = function (t, e) { return t.prototype = Object.create(THREE.Curve.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, THREE.CurvePath = function () { this.curves = [], this.bends = [], this.autoClose = !1 }, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.constructor = THREE.CurvePath, THREE.CurvePath.prototype.add = function (t) { this.curves.push(t) }, THREE.CurvePath.prototype.checkConnection = function () { }, THREE.CurvePath.prototype.closePath = function () { var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new THREE.LineCurve(e, t)) }, THREE.CurvePath.prototype.getPoint = function (t) { for (var e, r = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) { if (i[n] >= r) { var a = 1 - (i[n] - r) / (e = this.curves[n]).getLength(); return e.getPointAt(a) } n++ } return null }, THREE.CurvePath.prototype.getLength = function () { var t = this.getCurveLengths(); return t[t.length - 1] }, THREE.CurvePath.prototype.getCurveLengths = function () { if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths; var t, e = [], r = 0, i = this.curves.length; for (t = 0; t < i; t++)r += this.curves[t].getLength(), e.push(r); return this.cacheLengths = e, e }, THREE.CurvePath.prototype.getBoundingBox = function () { var t, e, r, i, n, a, o, s, h, l, c = this.getPoints(); t = e = Number.NEGATIVE_INFINITY, i = n = Number.POSITIVE_INFINITY; var u = c[0] instanceof THREE.Vector3; for (l = u ? new THREE.Vector3 : new THREE.Vector2, s = 0, h = c.length; s < h; s++)(o = c[s]).x > t ? t = o.x : o.x < i && (i = o.x), o.y > e ? e = o.y : o.y < n && (n = o.y), u && (o.z > r ? r = o.z : o.z < a && (a = o.z)), l.add(o); var E = { minX: i, minY: n, maxX: t, maxY: e }; return u && (E.maxZ = r, E.minZ = a), E }, THREE.CurvePath.prototype.createPointsGeometry = function (t) { var e = this.getPoints(t, !0); return this.createGeometry(e) }, THREE.CurvePath.prototype.createSpacedPointsGeometry = function (t) { var e = this.getSpacedPoints(t, !0); return this.createGeometry(e) }, THREE.CurvePath.prototype.createGeometry = function (t) { for (var e = new THREE.Geometry, r = 0; r < t.length; r++)e.vertices.push(new THREE.Vector3(t[r].x, t[r].y, t[r].z || 0)); return e }, THREE.CurvePath.prototype.addWrapPath = function (t) { this.bends.push(t) }, THREE.CurvePath.prototype.getTransformedPoints = function (t, e) { var r, i, n = this.getPoints(t); for (e || (e = this.bends), r = 0, i = e.length; r < i; r++)n = this.getWrapPoints(n, e[r]); return n }, THREE.CurvePath.prototype.getTransformedSpacedPoints = function (t, e) { var r, i, n = this.getSpacedPoints(t); for (e || (e = this.bends), r = 0, i = e.length; r < i; r++)n = this.getWrapPoints(n, e[r]); return n }, THREE.CurvePath.prototype.getWrapPoints = function (t, e) { var r, i, n, a, o, s, h = this.getBoundingBox(); for (r = 0, i = t.length; r < i; r++) { a = (n = t[r]).x, o = n.y, s = a / h.maxX, s = e.getUtoTmapping(s, a); var l = e.getPoint(s), c = e.getTangent(s); c.set(-c.y, c.x).multiplyScalar(o), n.x = l.x + c.x, n.y = l.y + c.y } return t }, THREE.Gyroscope = function () { THREE.Object3D.call(this) }, THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype), THREE.Gyroscope.prototype.constructor = THREE.Gyroscope, THREE.Gyroscope.prototype.updateMatrixWorld = function () { var t = new THREE.Vector3, e = new THREE.Quaternion, r = new THREE.Vector3, i = new THREE.Vector3, n = new THREE.Quaternion, a = new THREE.Vector3; return function (o) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || o) && (this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(i, n, a), this.matrix.decompose(t, e, r), this.matrixWorld.compose(i, e, a)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, o = !0); for (var s = 0, h = this.children.length; s < h; s++)this.children[s].updateMatrixWorld(o) } }(), THREE.Path = function (t) { THREE.CurvePath.call(this), this.actions = [], t && this.fromPoints(t) }, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.Path.prototype.constructor = THREE.Path, THREE.PathActions = { MOVE_TO: "moveTo", LINE_TO: "lineTo", QUADRATIC_CURVE_TO: "quadraticCurveTo", BEZIER_CURVE_TO: "bezierCurveTo", CSPLINE_THRU: "splineThru", ARC: "arc", ELLIPSE: "ellipse" }, THREE.Path.prototype.fromPoints = function (t) { this.moveTo(t[0].x, t[0].y); for (var e = 1, r = t.length; e < r; e++)this.lineTo(t[e].x, t[e].y) }, THREE.Path.prototype.moveTo = function (t, e) { var r = Array.prototype.slice.call(arguments); this.actions.push({ action: THREE.PathActions.MOVE_TO, args: r }) }, THREE.Path.prototype.lineTo = function (t, e) { var r = Array.prototype.slice.call(arguments), i = this.actions[this.actions.length - 1].args, n = i[i.length - 2], a = i[i.length - 1], o = new THREE.LineCurve(new THREE.Vector2(n, a), new THREE.Vector2(t, e)); this.curves.push(o), this.actions.push({ action: THREE.PathActions.LINE_TO, args: r }) }, THREE.Path.prototype.quadraticCurveTo = function (t, e, r, i) { var n = Array.prototype.slice.call(arguments), a = this.actions[this.actions.length - 1].args, o = a[a.length - 2], s = a[a.length - 1], h = new THREE.QuadraticBezierCurve(new THREE.Vector2(o, s), new THREE.Vector2(t, e), new THREE.Vector2(r, i)); this.curves.push(h), this.actions.push({ action: THREE.PathActions.QUADRATIC_CURVE_TO, args: n }) }, THREE.Path.prototype.bezierCurveTo = function (t, e, r, i, n, a) { var o = Array.prototype.slice.call(arguments), s = this.actions[this.actions.length - 1].args, h = s[s.length - 2], l = s[s.length - 1], c = new THREE.CubicBezierCurve(new THREE.Vector2(h, l), new THREE.Vector2(t, e), new THREE.Vector2(r, i), new THREE.Vector2(n, a)); this.curves.push(c), this.actions.push({ action: THREE.PathActions.BEZIER_CURVE_TO, args: o }) }, THREE.Path.prototype.splineThru = function (t) { var e = Array.prototype.slice.call(arguments), r = this.actions[this.actions.length - 1].args, i = r[r.length - 2], n = r[r.length - 1], a = [new THREE.Vector2(i, n)]; Array.prototype.push.apply(a, t); var o = new THREE.SplineCurve(a); this.curves.push(o), this.actions.push({ action: THREE.PathActions.CSPLINE_THRU, args: e }) }, THREE.Path.prototype.arc = function (t, e, r, i, n, a) { var o = this.actions[this.actions.length - 1].args, s = o[o.length - 2], h = o[o.length - 1]; this.absarc(t + s, e + h, r, i, n, a) }, THREE.Path.prototype.absarc = function (t, e, r, i, n, a) { this.absellipse(t, e, r, r, i, n, a) }, THREE.Path.prototype.ellipse = function (t, e, r, i, n, a, o) { var s = this.actions[this.actions.length - 1].args, h = s[s.length - 2], l = s[s.length - 1]; this.absellipse(t + h, e + l, r, i, n, a, o) }, THREE.Path.prototype.absellipse = function (t, e, r, i, n, a, o) { var s = Array.prototype.slice.call(arguments), h = new THREE.EllipseCurve(t, e, r, i, n, a, o); this.curves.push(h); var l = h.getPoint(1); s.push(l.x), s.push(l.y), this.actions.push({ action: THREE.PathActions.ELLIPSE, args: s }) }, THREE.Path.prototype.getSpacedPoints = function (t, e) { t || (t = 40); for (var r = [], i = 0; i < t; i++)r.push(this.getPoint(i / t)); return r }, THREE.Path.prototype.getPoints = function (t, e) { if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(t, e); t = t || 12; var r, i, n, a, o, s, h, l, c, u, E, p, f, d, m, T, g, v, R = []; for (r = 0, i = this.actions.length; r < i; r++)switch (a = (n = this.actions[r]).action, o = n.args, a) { case THREE.PathActions.MOVE_TO: case THREE.PathActions.LINE_TO: R.push(new THREE.Vector2(o[0], o[1])); break; case THREE.PathActions.QUADRATIC_CURVE_TO: for (s = o[2], h = o[3], u = o[0], E = o[1], R.length > 0 ? (p = (d = R[R.length - 1]).x, f = d.y) : (p = (d = this.actions[r - 1].args)[d.length - 2], f = d[d.length - 1]), m = 1; m <= t; m++)T = m / t, g = THREE.Shape.Utils.b2(T, p, u, s), v = THREE.Shape.Utils.b2(T, f, E, h), R.push(new THREE.Vector2(g, v)); break; case THREE.PathActions.BEZIER_CURVE_TO: for (s = o[4], h = o[5], u = o[0], E = o[1], l = o[2], c = o[3], R.length > 0 ? (p = (d = R[R.length - 1]).x, f = d.y) : (p = (d = this.actions[r - 1].args)[d.length - 2], f = d[d.length - 1]), m = 1; m <= t; m++)T = m / t, g = THREE.Shape.Utils.b3(T, p, u, l, s), v = THREE.Shape.Utils.b3(T, f, E, c, h), R.push(new THREE.Vector2(g, v)); break; case THREE.PathActions.CSPLINE_THRU: d = this.actions[r - 1].args; var y = [new THREE.Vector2(d[d.length - 2], d[d.length - 1])], H = t * o[0].length; y = y.concat(o[0]); var x = new THREE.SplineCurve(y); for (m = 1; m <= H; m++)R.push(x.getPointAt(m / H)); break; case THREE.PathActions.ARC: var b = o[0], _ = o[1], w = o[2], M = o[3], S = o[4], A = !!o[5], C = S - M, L = 2 * t; for (m = 1; m <= L; m++)T = m / L, A || (T = 1 - T), P = M + T * C, g = b + w * Math.cos(P), v = _ + w * Math.sin(P), R.push(new THREE.Vector2(g, v)); break; case THREE.PathActions.ELLIPSE: b = o[0], _ = o[1]; var P, F = o[2], U = o[3]; M = o[4], S = o[5], A = !!o[6], C = S - M, L = 2 * t; for (m = 1; m <= L; m++)T = m / L, A || (T = 1 - T), P = M + T * C, g = b + F * Math.cos(P), v = _ + U * Math.sin(P), R.push(new THREE.Vector2(g, v)) }var B = R[R.length - 1]; return Math.abs(B.x - R[0].x) < 1e-10 && Math.abs(B.y - R[0].y) < 1e-10 && R.splice(R.length - 1, 1), e && R.push(R[0]), R }, THREE.Path.prototype.toShapes = function (t, e) { function r(t) { for (var e = [], r = 0, i = t.length; r < i; r++) { var n = t[r], a = new THREE.Shape; a.actions = n.actions, a.curves = n.curves, e.push(a) } return e } function i(t, e) { for (var r = e.length, i = !1, n = r - 1, a = 0; a < r; n = a++) { var o = e[n], s = e[a], h = s.x - o.x, l = s.y - o.y; if (Math.abs(l) > 1e-10) { if (l < 0 && (o = e[a], h = -h, s = e[n], l = -l), t.y < o.y || t.y > s.y) continue; if (t.y == o.y) { if (t.x == o.x) return !0 } else { var c = l * (t.x - o.x) - h * (t.y - o.y); if (0 == c) return !0; if (c < 0) continue; i = !i } } else { if (t.y != o.y) continue; if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return !0 } } return i } var n = function (t) { var e, r, i, n, a, o = [], s = new THREE.Path; for (e = 0, r = t.length; e < r; e++)a = (i = t[e]).args, (n = i.action) == THREE.PathActions.MOVE_TO && 0 != s.actions.length && (o.push(s), s = new THREE.Path), s[n].apply(s, a); return 0 != s.actions.length && o.push(s), o }(this.actions); if (0 == n.length) return []; if (!0 === e) return r(n); var a, o, s, h = []; if (1 == n.length) return o = n[0], (s = new THREE.Shape).actions = o.actions, s.curves = o.curves, h.push(s), h; var l = !THREE.Shape.Utils.isClockWise(n[0].getPoints()); l = t ? !l : l; var c, u, E, p, f, d, m = [], T = [], g = [], v = 0; for (T[v] = void 0, g[v] = [], u = 0, E = n.length; u < E; u++)c = (o = n[u]).getPoints(), a = THREE.Shape.Utils.isClockWise(c), (a = t ? !a : a) ? (!l && T[v] && v++ , T[v] = { s: new THREE.Shape, p: c }, T[v].s.actions = o.actions, T[v].s.curves = o.curves, l && v++ , g[v] = []) : g[v].push({ h: o, p: c[0] }); if (!T[0]) return r(n); if (T.length > 1) { for (var R = !1, y = [], H = 0, x = T.length; H < x; H++)m[H] = []; for (H = 0, x = T.length; H < x; H++)for (var b = g[H], _ = 0; _ < b.length; _++) { for (var w = b[_], M = !0, S = 0; S < T.length; S++)i(w.p, T[S].p) && (H != S && y.push({ froms: H, tos: S, hole: _ }), M ? (M = !1, m[S].push(w)) : R = !0); M && m[H].push(w) } y.length > 0 && (R || (g = m)) } for (u = 0, E = T.length; u < E; u++)for (s = T[u].s, h.push(s), f = 0, d = (p = g[u]).length; f < d; f++)s.holes.push(p[f].h); return h }, THREE.Shape = function () { THREE.Path.apply(this, arguments), this.holes = [] }, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.constructor = THREE.Shape, THREE.Shape.prototype.extrude = function (t) { return new THREE.ExtrudeGeometry(this, t) }, THREE.Shape.prototype.makeGeometry = function (t) { return new THREE.ShapeGeometry(this, t) }, THREE.Shape.prototype.getPointsHoles = function (t) { var e, r = this.holes.length, i = []; for (e = 0; e < r; e++)i[e] = this.holes[e].getTransformedPoints(t, this.bends); return i }, THREE.Shape.prototype.getSpacedPointsHoles = function (t) { var e, r = this.holes.length, i = []; for (e = 0; e < r; e++)i[e] = this.holes[e].getTransformedSpacedPoints(t, this.bends); return i }, THREE.Shape.prototype.extractAllPoints = function (t) { return { shape: this.getTransformedPoints(t), holes: this.getPointsHoles(t) } }, THREE.Shape.prototype.extractPoints = function (t) { return this.useSpacedPoints ? this.extractAllSpacedPoints(t) : this.extractAllPoints(t) }, THREE.Shape.prototype.extractAllSpacedPoints = function (t) { return { shape: this.getTransformedSpacedPoints(t), holes: this.getSpacedPointsHoles(t) } }, THREE.Shape.Utils = { triangulateShape: function (t, e) { function r(t, e, r) { return t.x != e.x ? t.x < e.x ? t.x <= r.x && r.x <= e.x : e.x <= r.x && r.x <= t.x : t.y < e.y ? t.y <= r.y && r.y <= e.y : e.y <= r.y && r.y <= t.y } function i(t, e, i, n, a) { var o = e.x - t.x, s = e.y - t.y, h = n.x - i.x, l = n.y - i.y, c = t.x - i.x, u = t.y - i.y, E = s * h - o * l, p = s * c - o * u; if (Math.abs(E) > 1e-10) { var f; if (E > 0) { if (p < 0 || p > E) return []; if ((f = l * c - h * u) < 0 || f > E) return [] } else { if (p > 0 || p < E) return []; if ((f = l * c - h * u) > 0 || f < E) return [] } if (0 == f) return !a || 0 != p && p != E ? [t] : []; if (f == E) return !a || 0 != p && p != E ? [e] : []; if (0 == p) return [i]; if (p == E) return [n]; var d = f / E; return [{ x: t.x + d * o, y: t.y + d * s }] } if (0 != p || l * c != h * u) return []; var m, T, g, v, R, y, H, x, b = 0 == o && 0 == s, _ = 0 == h && 0 == l; return b && _ ? t.x != i.x || t.y != i.y ? [] : [t] : b ? r(i, n, t) ? [t] : [] : _ ? r(t, e, i) ? [i] : [] : (0 != o ? (t.x < e.x ? (m = t, g = t.x, T = e, v = e.x) : (m = e, g = e.x, T = t, v = t.x), i.x < n.x ? (R = i, H = i.x, y = n, x = n.x) : (R = n, H = n.x, y = i, x = i.x)) : (t.y < e.y ? (m = t, g = t.y, T = e, v = e.y) : (m = e, g = e.y, T = t, v = t.y), i.y < n.y ? (R = i, H = i.y, y = n, x = n.y) : (R = n, H = n.y, y = i, x = i.y)), g <= H ? v < H ? [] : v == H ? a ? [] : [R] : v <= x ? [R, T] : [R, y] : g > x ? [] : g == x ? a ? [] : [m] : v <= x ? [m, T] : [m, y]) } function n(t, e, r, i) { var n = e.x - t.x, a = e.y - t.y, o = r.x - t.x, s = r.y - t.y, h = i.x - t.x, l = i.y - t.y, c = n * s - a * o, u = n * l - a * h; if (Math.abs(c) > 1e-10) { var E = h * s - l * o; return c > 0 ? u >= 0 && E >= 0 : u >= 0 || E >= 0 } return u > 0 } for (var a, o, s, h, l, c, u = {}, E = t.concat(), p = 0, f = e.length; p < f; p++)Array.prototype.push.apply(E, e[p]); for (a = 0, o = E.length; a < o; a++)void 0 !== u[l = E[a].x + ":" + E[a].y] && THREE.warn("THREE.Shape: Duplicate point", l), u[l] = a; var d = function (t, e) { var r, a = t.concat(); function o(t, e) { var i = a.length - 1, o = t - 1; o < 0 && (o = i); var s = t + 1; s > i && (s = 0); var h = n(a[t], a[o], a[s], r[e]); if (!h) return !1; var l = r.length - 1, c = e - 1; c < 0 && (c = l); var u = e + 1; return u > l && (u = 0), !!(h = n(r[e], r[c], r[u], a[t])) } function s(t, e) { var r, n; for (r = 0; r < a.length; r++)if (n = r + 1, n %= a.length, i(t, e, a[r], a[n], !0).length > 0) return !0; return !1 } var h = []; function l(t, r) { var n, a, o, s; for (n = 0; n < h.length; n++)for (a = e[h[n]], o = 0; o < a.length; o++)if (s = o + 1, s %= a.length, i(t, r, a[o], a[s], !0).length > 0) return !0; return !1 } for (var c, u, E, p, f, d, m, T, g, v, R = [], y = 0, H = e.length; y < H; y++)h.push(y); for (var x = 0, b = 2 * h.length; h.length > 0;) { if (--b < 0) { console.log("Infinite Loop! Holes left:" + h.length + ", Probably Hole outside Shape!"); break } for (u = x; u < a.length; u++) { for (E = a[u], c = -1, y = 0; y < h.length; y++)if (f = h[y], void 0 === R[d = E.x + ":" + E.y + ":" + f]) { r = e[f]; for (var _ = 0; _ < r.length; _++)if (p = r[_], o(u, _) && !s(E, p) && !l(E, p)) { c = _, h.splice(y, 1), m = a.slice(0, u + 1), T = a.slice(u), g = r.slice(c), v = r.slice(0, c + 1), a = m.concat(g).concat(v).concat(T), x = u; break } if (c >= 0) break; R[d] = !0 } if (c >= 0) break } } return a }(t, e), m = THREE.FontUtils.Triangulate(d, !1); for (a = 0, o = m.length; a < o; a++)for (h = m[a], s = 0; s < 3; s++)void 0 !== (c = u[l = h[s].x + ":" + h[s].y]) && (h[s] = c); return m.concat() }, isClockWise: function (t) { return THREE.FontUtils.Triangulate.area(t) < 0 }, b2p0: function (t, e) { var r = 1 - t; return r * r * e }, b2p1: function (t, e) { return 2 * (1 - t) * t * e }, b2p2: function (t, e) { return t * t * e }, b2: function (t, e, r, i) { return this.b2p0(t, e) + this.b2p1(t, r) + this.b2p2(t, i) }, b3p0: function (t, e) { var r = 1 - t; return r * r * r * e }, b3p1: function (t, e) { var r = 1 - t; return 3 * r * r * t * e }, b3p2: function (t, e) { return 3 * (1 - t) * t * t * e }, b3p3: function (t, e) { return t * t * t * e }, b3: function (t, e, r, i, n) { return this.b3p0(t, e) + this.b3p1(t, r) + this.b3p2(t, i) + this.b3p3(t, n) } }, THREE.LineCurve = function (t, e) { this.v1 = t, this.v2 = e }, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.constructor = THREE.LineCurve, THREE.LineCurve.prototype.getPoint = function (t) { var e = this.v2.clone().sub(this.v1); return e.multiplyScalar(t).add(this.v1), e }, THREE.LineCurve.prototype.getPointAt = function (t) { return this.getPoint(t) }, THREE.LineCurve.prototype.getTangent = function (t) { return this.v2.clone().sub(this.v1).normalize() }, THREE.QuadraticBezierCurve = function (t, e, r) { this.v0 = t, this.v1 = e, this.v2 = r }, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve, THREE.QuadraticBezierCurve.prototype.getPoint = function (t) { var e = new THREE.Vector2; return e.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x), e.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y), e }, THREE.QuadraticBezierCurve.prototype.getTangent = function (t) { var e = new THREE.Vector2; return e.x = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), e.y = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y), e.normalize() }, THREE.CubicBezierCurve = function (t, e, r, i) { this.v0 = t, this.v1 = e, this.v2 = r, this.v3 = i }, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve, THREE.CubicBezierCurve.prototype.getPoint = function (t) { var e, r; return e = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), r = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new THREE.Vector2(e, r) }, THREE.CubicBezierCurve.prototype.getTangent = function (t) { var e, r; e = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), r = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y); var i = new THREE.Vector2(e, r); return i.normalize(), i }, THREE.SplineCurve = function (t) { this.points = null == t ? [] : t }, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.constructor = THREE.SplineCurve, THREE.SplineCurve.prototype.getPoint = function (t) { var e = this.points, r = (e.length - 1) * t, i = Math.floor(r), n = r - i, a = e[0 == i ? i : i - 1], o = e[i], s = e[i > e.length - 2 ? e.length - 1 : i + 1], h = e[i > e.length - 3 ? e.length - 1 : i + 2], l = new THREE.Vector2; return l.x = THREE.Curve.Utils.interpolate(a.x, o.x, s.x, h.x, n), l.y = THREE.Curve.Utils.interpolate(a.y, o.y, s.y, h.y, n), l }, THREE.EllipseCurve = function (t, e, r, i, n, a, o) { this.aX = t, this.aY = e, this.xRadius = r, this.yRadius = i, this.aStartAngle = n, this.aEndAngle = a, this.aClockwise = o }, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve, THREE.EllipseCurve.prototype.getPoint = function (t) { var e, r = this.aEndAngle - this.aStartAngle; r < 0 && (r += 2 * Math.PI), r > 2 * Math.PI && (r -= 2 * Math.PI), e = !0 === this.aClockwise ? this.aEndAngle + (1 - t) * (2 * Math.PI - r) : this.aStartAngle + t * r; var i = new THREE.Vector2; return i.x = this.aX + this.xRadius * Math.cos(e), i.y = this.aY + this.yRadius * Math.sin(e), i }, THREE.ArcCurve = function (t, e, r, i, n, a) { THREE.EllipseCurve.call(this, t, e, r, r, i, n, a) }, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.ArcCurve.prototype.constructor = THREE.ArcCurve, THREE.LineCurve3 = THREE.Curve.create(function (t, e) { this.v1 = t, this.v2 = e }, function (t) { var e = new THREE.Vector3; return e.subVectors(this.v2, this.v1), e.multiplyScalar(t), e.add(this.v1), e }), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (t, e, r) { this.v0 = t, this.v1 = e, this.v2 = r }, function (t) { var e = new THREE.Vector3; return e.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x), e.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y), e.z = THREE.Shape.Utils.b2(t, this.v0.z, this.v1.z, this.v2.z), e }), THREE.CubicBezierCurve3 = THREE.Curve.create(function (t, e, r, i) { this.v0 = t, this.v1 = e, this.v2 = r, this.v3 = i }, function (t) { var e = new THREE.Vector3; return e.x = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e.y = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), e.z = THREE.Shape.Utils.b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z), e }), THREE.SplineCurve3 = THREE.Curve.create(function (t) { this.points = null == t ? [] : t }, function (t) { var e = this.points, r = (e.length - 1) * t, i = Math.floor(r), n = r - i, a = e[0 == i ? i : i - 1], o = e[i], s = e[i > e.length - 2 ? e.length - 1 : i + 1], h = e[i > e.length - 3 ? e.length - 1 : i + 2], l = new THREE.Vector3; return l.x = THREE.Curve.Utils.interpolate(a.x, o.x, s.x, h.x, n), l.y = THREE.Curve.Utils.interpolate(a.y, o.y, s.y, h.y, n), l.z = THREE.Curve.Utils.interpolate(a.z, o.z, s.z, h.z, n), l }), THREE.ClosedSplineCurve3 = THREE.Curve.create(function (t) { this.points = null == t ? [] : t }, function (t) { var e = this.points, r = (e.length - 0) * t, i = Math.floor(r), n = r - i, a = e[((i += i > 0 ? 0 : (Math.floor(Math.abs(i) / e.length) + 1) * e.length) - 1) % e.length], o = e[i % e.length], s = e[(i + 1) % e.length], h = e[(i + 2) % e.length], l = new THREE.Vector3; return l.x = THREE.Curve.Utils.interpolate(a.x, o.x, s.x, h.x, n), l.y = THREE.Curve.Utils.interpolate(a.y, o.y, s.y, h.y, n), l.z = THREE.Curve.Utils.interpolate(a.z, o.z, s.z, h.z, n), l }), THREE.AnimationHandler = { LINEAR: 0, CATMULLROM: 1, CATMULLROM_FORWARD: 2, add: function () { THREE.warn("THREE.AnimationHandler.add() has been deprecated.") }, get: function () { THREE.warn("THREE.AnimationHandler.get() has been deprecated.") }, remove: function () { THREE.warn("THREE.AnimationHandler.remove() has been deprecated.") }, animations: [], init: function (t) { if (!0 === t.initialized) return t; for (var e = 0; e < t.hierarchy.length; e++) { for (var r = 0; r < t.hierarchy[e].keys.length; r++)if (t.hierarchy[e].keys[r].time < 0 && (t.hierarchy[e].keys[r].time = 0), void 0 !== t.hierarchy[e].keys[r].rot && !(t.hierarchy[e].keys[r].rot instanceof THREE.Quaternion)) { var i = t.hierarchy[e].keys[r].rot; t.hierarchy[e].keys[r].rot = (new THREE.Quaternion).fromArray(i) } if (t.hierarchy[e].keys.length && void 0 !== t.hierarchy[e].keys[0].morphTargets) { var n = {}; for (r = 0; r < t.hierarchy[e].keys.length; r++)for (var a = 0; a < t.hierarchy[e].keys[r].morphTargets.length; a++) { n[s = t.hierarchy[e].keys[r].morphTargets[a]] = -1 } t.hierarchy[e].usedMorphTargets = n; for (r = 0; r < t.hierarchy[e].keys.length; r++) { var o = {}; for (var s in n) { for (a = 0; a < t.hierarchy[e].keys[r].morphTargets.length; a++)if (t.hierarchy[e].keys[r].morphTargets[a] === s) { o[s] = t.hierarchy[e].keys[r].morphTargetsInfluences[a]; break } a === t.hierarchy[e].keys[r].morphTargets.length && (o[s] = 0) } t.hierarchy[e].keys[r].morphTargetsInfluences = o } } for (r = 1; r < t.hierarchy[e].keys.length; r++)t.hierarchy[e].keys[r].time === t.hierarchy[e].keys[r - 1].time && (t.hierarchy[e].keys.splice(r, 1), r--); for (r = 0; r < t.hierarchy[e].keys.length; r++)t.hierarchy[e].keys[r].index = r } return t.initialized = !0, t }, parse: function (t) { var e = function (t, r) { r.push(t); for (var i = 0; i < t.children.length; i++)e(t.children[i], r) }, r = []; if (t instanceof THREE.SkinnedMesh) for (var i = 0; i < t.skeleton.bones.length; i++)r.push(t.skeleton.bones[i]); else e(t, r); return r }, play: function (t) { -1 === this.animations.indexOf(t) && this.animations.push(t) }, stop: function (t) { var e = this.animations.indexOf(t); -1 !== e && this.animations.splice(e, 1) }, update: function (t) { for (var e = 0; e < this.animations.length; e++)this.animations[e].resetBlendWeights(); for (e = 0; e < this.animations.length; e++)this.animations[e].update(t) } }, THREE.Animation = function (t, e) { this.root = t, this.data = THREE.AnimationHandler.init(e), this.hierarchy = THREE.AnimationHandler.parse(t), this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = !0, this.weight = 0, this.interpolationType = THREE.AnimationHandler.LINEAR }, THREE.Animation.prototype = { constructor: THREE.Animation, keyTypes: ["pos", "rot", "scl"], play: function (t, e) { this.currentTime = void 0 !== t ? t : 0, this.weight = void 0 !== e ? e : 1, this.isPlaying = !0, this.reset(), THREE.AnimationHandler.play(this) }, stop: function () { this.isPlaying = !1, THREE.AnimationHandler.stop(this) }, reset: function () { for (var t = 0, e = this.hierarchy.length; t < e; t++) { var r = this.hierarchy[t]; void 0 === r.animationCache && (r.animationCache = { animations: {}, blending: { positionWeight: 0, quaternionWeight: 0, scaleWeight: 0 } }); var i = this.data.name, n = r.animationCache.animations, a = n[i]; void 0 === a && (a = { prevKey: { pos: 0, rot: 0, scl: 0 }, nextKey: { pos: 0, rot: 0, scl: 0 }, originalMatrix: r.matrix }, n[i] = a); for (var o = 0; o < 3; o++) { for (var s = this.keyTypes[o], h = this.data.hierarchy[t].keys[0], l = this.getNextKeyWith(s, t, 1); l.time < this.currentTime && l.index > h.index;)h = l, l = this.getNextKeyWith(s, t, l.index + 1); a.prevKey[s] = h, a.nextKey[s] = l } } }, resetBlendWeights: function () { for (var t = 0, e = this.hierarchy.length; t < e; t++) { var r = this.hierarchy[t].animationCache; if (void 0 !== r) { var i = r.blending; i.positionWeight = 0, i.quaternionWeight = 0, i.scaleWeight = 0 } } }, update: function () { var t = [], e = new THREE.Vector3, r = new THREE.Vector3, i = new THREE.Quaternion, n = function (t, e) { var r, i, n, o, s, h, l, c, u, E = [], p = []; return n = (r = (t.length - 1) * e) - (i = Math.floor(r)), E[0] = 0 === i ? i : i - 1, E[1] = i, E[2] = i > t.length - 2 ? i : i + 1, E[3] = i > t.length - 3 ? i : i + 2, h = t[E[0]], l = t[E[1]], c = t[E[2]], u = t[E[3]], s = n * (o = n * n), p[0] = a(h[0], l[0], c[0], u[0], n, o, s), p[1] = a(h[1], l[1], c[1], u[1], n, o, s), p[2] = a(h[2], l[2], c[2], u[2], n, o, s), p }, a = function (t, e, r, i, n, a, o) { var s = .5 * (r - t), h = .5 * (i - e); return (2 * (e - r) + s + h) * o + (-3 * (e - r) - 2 * s - h) * a + s * n + e }; return function (a) { if (!1 !== this.isPlaying && (this.currentTime += a * this.timeScale, 0 !== this.weight)) { var o = this.data.length; (this.currentTime > o || this.currentTime < 0) && (this.loop ? (this.currentTime %= o, this.currentTime < 0 && (this.currentTime += o), this.reset()) : this.stop()); for (var s = 0, h = this.hierarchy.length; s < h; s++)for (var l = this.hierarchy[s], c = l.animationCache.animations[this.data.name], u = l.animationCache.blending, E = 0; E < 3; E++) { var p = this.keyTypes[E], f = c.prevKey[p], d = c.nextKey[p]; if (this.timeScale > 0 && d.time <= this.currentTime || this.timeScale < 0 && f.time >= this.currentTime) { for (f = this.data.hierarchy[s].keys[0], d = this.getNextKeyWith(p, s, 1); d.time < this.currentTime && d.index > f.index;)f = d, d = this.getNextKeyWith(p, s, d.index + 1); c.prevKey[p] = f, c.nextKey[p] = d } var m = (this.currentTime - f.time) / (d.time - f.time), T = f[p], g = d[p]; if (m < 0 && (m = 0), m > 1 && (m = 1), "pos" === p) { if (this.interpolationType === THREE.AnimationHandler.LINEAR) { r.x = T[0] + (g[0] - T[0]) * m, r.y = T[1] + (g[1] - T[1]) * m, r.z = T[2] + (g[2] - T[2]) * m; var v = this.weight / (this.weight + u.positionWeight); l.position.lerp(r, v), u.positionWeight += this.weight } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) { t[0] = this.getPrevKeyWith("pos", s, f.index - 1).pos, t[1] = T, t[2] = g, t[3] = this.getNextKeyWith("pos", s, d.index + 1).pos; var R = n(t, m = .33 * m + .33); v = this.weight / (this.weight + u.positionWeight); u.positionWeight += this.weight; var y = l.position; if (y.x = y.x + (R[0] - y.x) * v, y.y = y.y + (R[1] - y.y) * v, y.z = y.z + (R[2] - y.z) * v, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) { var H = n(t, 1.01 * m); e.set(H[0], H[1], H[2]), e.sub(y), e.y = 0, e.normalize(); var x = Math.atan2(e.x, e.z); l.rotation.set(0, x, 0) } } } else if ("rot" === p) if (THREE.Quaternion.slerp(T, g, i, m), 0 === u.quaternionWeight) l.quaternion.copy(i), u.quaternionWeight = this.weight; else { v = this.weight / (this.weight + u.quaternionWeight); THREE.Quaternion.slerp(l.quaternion, i, l.quaternion, v), u.quaternionWeight += this.weight } else if ("scl" === p) { r.x = T[0] + (g[0] - T[0]) * m, r.y = T[1] + (g[1] - T[1]) * m, r.z = T[2] + (g[2] - T[2]) * m; v = this.weight / (this.weight + u.scaleWeight); l.scale.lerp(r, v), u.scaleWeight += this.weight } } return !0 } } }(), getNextKeyWith: function (t, e, r) { var i = this.data.hierarchy[e].keys; for (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? r = r < i.length - 1 ? r : i.length - 1 : r %= i.length; r < i.length; r++)if (void 0 !== i[r][t]) return i[r]; return this.data.hierarchy[e].keys[0] }, getPrevKeyWith: function (t, e, r) { var i = this.data.hierarchy[e].keys; for (r = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? r > 0 ? r : 0 : r >= 0 ? r : r + i.length; r >= 0; r--)if (void 0 !== i[r][t]) return i[r]; return this.data.hierarchy[e].keys[i.length - 1] } }, THREE.KeyFrameAnimation = function (t) { this.root = t.node, this.data = THREE.AnimationHandler.init(t), this.hierarchy = THREE.AnimationHandler.parse(this.root), this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.isPaused = !0, this.loop = !0; for (var e = 0, r = this.hierarchy.length; e < r; e++) { var i = this.data.hierarchy[e].keys, n = this.data.hierarchy[e].sids, a = this.hierarchy[e]; if (i.length && n) { for (var o = 0; o < n.length; o++) { var s = n[o], h = this.getNextKeyWith(s, e, 0); h && h.apply(s) } a.matrixAutoUpdate = !1, this.data.hierarchy[e].node.updateMatrix(), a.matrixWorldNeedsUpdate = !0 } } }, THREE.KeyFrameAnimation.prototype = { constructor: THREE.KeyFrameAnimation, play: function (t) { if (this.currentTime = void 0 !== t ? t : 0, !1 === this.isPlaying) { this.isPlaying = !0; var e, r, i, n = this.hierarchy.length; for (e = 0; e < n; e++) { r = this.hierarchy[e], void 0 === (i = this.data.hierarchy[e]).animationCache && (i.animationCache = {}, i.animationCache.prevKey = null, i.animationCache.nextKey = null, i.animationCache.originalMatrix = r.matrix); var a = this.data.hierarchy[e].keys; a.length && (i.animationCache.prevKey = a[0], i.animationCache.nextKey = a[1], this.startTime = Math.min(a[0].time, this.startTime), this.endTime = Math.max(a[a.length - 1].time, this.endTime)) } this.update(0) } this.isPaused = !1, THREE.AnimationHandler.play(this) }, stop: function () { this.isPlaying = !1, this.isPaused = !1, THREE.AnimationHandler.stop(this); for (var t = 0; t < this.data.hierarchy.length; t++) { var e = this.hierarchy[t], r = this.data.hierarchy[t]; if (void 0 !== r.animationCache) { var i = r.animationCache.originalMatrix; i.copy(e.matrix), e.matrix = i, delete r.animationCache } } }, update: function (t) { if (!1 !== this.isPlaying) { this.currentTime += t * this.timeScale; var e = this.data.length; !0 === this.loop && this.currentTime > e && (this.currentTime %= e), this.currentTime = Math.min(this.currentTime, e); for (var r = 0, i = this.hierarchy.length; r < i; r++) { var n = this.hierarchy[r], a = this.data.hierarchy[r], o = a.keys, s = a.animationCache; if (o.length) { var h = s.prevKey, l = s.nextKey; if (l.time <= this.currentTime) { for (; l.time < this.currentTime && l.index > h.index;)l = o[(h = l).index + 1]; s.prevKey = h, s.nextKey = l } l.time >= this.currentTime ? h.interpolate(l, this.currentTime) : h.interpolate(l, l.time), this.data.hierarchy[r].node.updateMatrix(), n.matrixWorldNeedsUpdate = !0 } } } }, getNextKeyWith: function (t, e, r) { var i = this.data.hierarchy[e].keys; for (r %= i.length; r < i.length; r++)if (i[r].hasTarget(t)) return i[r]; return i[0] }, getPrevKeyWith: function (t, e, r) { var i = this.data.hierarchy[e].keys; for (r = r >= 0 ? r : r + i.length; r >= 0; r--)if (i[r].hasTarget(t)) return i[r]; return i[i.length - 1] } }, THREE.MorphAnimation = function (t) { this.mesh = t, this.frames = t.morphTargetInfluences.length, this.currentTime = 0, this.duration = 1e3, this.loop = !0, this.lastFrame = 0, this.currentFrame = 0, this.isPlaying = !1 }, THREE.MorphAnimation.prototype = { constructor: THREE.MorphAnimation, play: function () { this.isPlaying = !0 }, pause: function () { this.isPlaying = !1 }, update: function (t) { if (!1 !== this.isPlaying) { this.currentTime += t, !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration), this.currentTime = Math.min(this.currentTime, this.duration); var e = this.duration / this.frames, r = Math.floor(this.currentTime / e), i = this.mesh.morphTargetInfluences; r != this.currentFrame && (i[this.lastFrame] = 0, i[this.currentFrame] = 1, i[r] = 0, this.lastFrame = this.currentFrame, this.currentFrame = r), i[r] = this.currentTime % e / e, i[this.lastFrame] = 1 - i[r] } } }, THREE.BoxGeometry = function (t, e, r, i, n, a) { THREE.Geometry.call(this), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: r, widthSegments: i, heightSegments: n, depthSegments: a }, this.widthSegments = i || 1, this.heightSegments = n || 1, this.depthSegments = a || 1; var o = this, s = t / 2, h = e / 2, l = r / 2; function c(t, e, r, i, n, a, s, h) { var l, c, u, E = o.widthSegments, p = o.heightSegments, f = n / 2, d = a / 2, m = o.vertices.length; "x" === t && "y" === e || "y" === t && "x" === e ? l = "z" : "x" === t && "z" === e || "z" === t && "x" === e ? (l = "y", p = o.depthSegments) : ("z" === t && "y" === e || "y" === t && "z" === e) && (l = "x", E = o.depthSegments); var T = E + 1, g = p + 1, v = n / E, R = a / p, y = new THREE.Vector3; for (y[l] = s > 0 ? 1 : -1, u = 0; u < g; u++)for (c = 0; c < T; c++) { var H = new THREE.Vector3; H[t] = (c * v - f) * r, H[e] = (u * R - d) * i, H[l] = s, o.vertices.push(H) } for (u = 0; u < p; u++)for (c = 0; c < E; c++) { var x = c + T * u, b = c + T * (u + 1), _ = c + 1 + T * (u + 1), w = c + 1 + T * u, M = new THREE.Vector2(c / E, 1 - u / p), S = new THREE.Vector2(c / E, 1 - (u + 1) / p), A = new THREE.Vector2((c + 1) / E, 1 - (u + 1) / p), C = new THREE.Vector2((c + 1) / E, 1 - u / p), L = new THREE.Face3(x + m, b + m, w + m); L.normal.copy(y), L.vertexNormals.push(y.clone(), y.clone(), y.clone()), L.materialIndex = h, o.faces.push(L), o.faceVertexUvs[0].push([M, S, C]), (L = new THREE.Face3(b + m, _ + m, w + m)).normal.copy(y), L.vertexNormals.push(y.clone(), y.clone(), y.clone()), L.materialIndex = h, o.faces.push(L), o.faceVertexUvs[0].push([S.clone(), A, C.clone()]) } } c("z", "y", -1, -1, r, e, s, 0), c("z", "y", 1, -1, r, e, -s, 1), c("x", "z", 1, 1, t, r, h, 2), c("x", "z", 1, -1, t, r, -h, 3), c("x", "y", 1, -1, t, e, l, 4), c("x", "y", -1, -1, t, e, -l, 5), this.mergeVertices() }, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry, THREE.CircleGeometry = function (t, e, r, i) { THREE.Geometry.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: r, thetaLength: i }, t = t || 50, e = void 0 !== e ? Math.max(3, e) : 8, r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI; var n, a = [], o = new THREE.Vector3, s = new THREE.Vector2(.5, .5); for (this.vertices.push(o), a.push(s), n = 0; n <= e; n++) { var h = new THREE.Vector3, l = r + n / e * i; h.x = t * Math.cos(l), h.y = t * Math.sin(l), this.vertices.push(h), a.push(new THREE.Vector2((h.x / t + 1) / 2, (h.y / t + 1) / 2)) } var c = new THREE.Vector3(0, 0, 1); for (n = 1; n <= e; n++)this.faces.push(new THREE.Face3(n, n + 1, 0, [c.clone(), c.clone(), c.clone()])), this.faceVertexUvs[0].push([a[n].clone(), a[n + 1].clone(), s.clone()]); this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, t) }, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry, THREE.CubeGeometry = function (t, e, r, i, n, a) { return THREE.warn("THREE.CubeGeometry has been renamed to THREE.BoxGeometry."), new THREE.BoxGeometry(t, e, r, i, n, a) }, THREE.CylinderGeometry = function (t, e, r, i, n, a, o, s) { THREE.Geometry.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: r, radialSegments: i, heightSegments: n, openEnded: a, thetaStart: o, thetaLength: s }, t = void 0 !== t ? t : 20, e = void 0 !== e ? e : 20, r = void 0 !== r ? r : 100, i = i || 8, n = n || 1, a = void 0 !== a && a, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : 2 * Math.PI; var h, l, c = r / 2, u = [], E = []; for (l = 0; l <= n; l++) { var p = [], f = [], d = l / n, m = d * (e - t) + t; for (h = 0; h <= i; h++) { var T = h / i, g = new THREE.Vector3; g.x = m * Math.sin(T * s + o), g.y = -d * r + c, g.z = m * Math.cos(T * s + o), this.vertices.push(g), p.push(this.vertices.length - 1), f.push(new THREE.Vector2(T, 1 - d)) } u.push(p), E.push(f) } var v, R, y = (e - t) / r; for (h = 0; h < i; h++)for (0 !== t ? (v = this.vertices[u[0][h]].clone(), R = this.vertices[u[0][h + 1]].clone()) : (v = this.vertices[u[1][h]].clone(), R = this.vertices[u[1][h + 1]].clone()), v.setY(Math.sqrt(v.x * v.x + v.z * v.z) * y).normalize(), R.setY(Math.sqrt(R.x * R.x + R.z * R.z) * y).normalize(), l = 0; l < n; l++) { var H = u[l][h], x = u[l + 1][h], b = u[l + 1][h + 1], _ = u[l][h + 1], w = v.clone(), M = v.clone(), S = R.clone(), A = R.clone(), C = E[l][h].clone(), L = E[l + 1][h].clone(), P = E[l + 1][h + 1].clone(), F = E[l][h + 1].clone(); this.faces.push(new THREE.Face3(H, x, _, [w, M, A])), this.faceVertexUvs[0].push([C, L, F]), this.faces.push(new THREE.Face3(x, b, _, [M.clone(), S, A.clone()])), this.faceVertexUvs[0].push([L.clone(), P, F.clone()]) } if (!1 === a && t > 0) for (this.vertices.push(new THREE.Vector3(0, c, 0)), h = 0; h < i; h++) { H = u[0][h], x = u[0][h + 1], b = this.vertices.length - 1, w = new THREE.Vector3(0, 1, 0), M = new THREE.Vector3(0, 1, 0), S = new THREE.Vector3(0, 1, 0), C = E[0][h].clone(), L = E[0][h + 1].clone(), P = new THREE.Vector2(L.x, 0); this.faces.push(new THREE.Face3(H, x, b, [w, M, S])), this.faceVertexUvs[0].push([C, L, P]) } if (!1 === a && e > 0) for (this.vertices.push(new THREE.Vector3(0, -c, 0)), h = 0; h < i; h++) { H = u[n][h + 1], x = u[n][h], b = this.vertices.length - 1, w = new THREE.Vector3(0, -1, 0), M = new THREE.Vector3(0, -1, 0), S = new THREE.Vector3(0, -1, 0), C = E[n][h + 1].clone(), L = E[n][h].clone(), P = new THREE.Vector2(L.x, 1); this.faces.push(new THREE.Face3(H, x, b, [w, M, S])), this.faceVertexUvs[0].push([C, L, P]) } this.computeFaceNormals() }, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry, THREE.ExtrudeGeometry = function (t, e) { void 0 !== t ? (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", t = t instanceof Array ? t : [t], this.addShapeList(t, e), this.computeFaceNormals()) : t = [] }, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry, THREE.ExtrudeGeometry.prototype.addShapeList = function (t, e) { for (var r = t.length, i = 0; i < r; i++) { var n = t[i]; this.addShape(n, e) } }, THREE.ExtrudeGeometry.prototype.addShape = function (t, e) { var r, i, n, a, o, s, h, l, c = void 0 !== e.amount ? e.amount : 100, u = void 0 !== e.bevelThickness ? e.bevelThickness : 6, E = void 0 !== e.bevelSize ? e.bevelSize : u - 2, p = void 0 !== e.bevelSegments ? e.bevelSegments : 3, f = void 0 === e.bevelEnabled || e.bevelEnabled, d = void 0 !== e.curveSegments ? e.curveSegments : 12, m = void 0 !== e.steps ? e.steps : 1, T = e.extrudePath, g = !1, v = e.material, R = e.extrudeMaterial, y = void 0 !== e.UVGenerator ? e.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator; T && (r = T.getSpacedPoints(m), g = !0, f = !1, i = void 0 !== e.frames ? e.frames : new THREE.TubeGeometry.FrenetFrames(T, m, !1), n = new THREE.Vector3, a = new THREE.Vector3, o = new THREE.Vector3), f || (p = 0, u = 0, E = 0); var H = this, x = this.vertices.length, b = t.extractPoints(d), _ = b.shape, w = b.holes, M = !THREE.Shape.Utils.isClockWise(_); if (M) { for (_ = _.reverse(), h = 0, l = w.length; h < l; h++)s = w[h], THREE.Shape.Utils.isClockWise(s) && (w[h] = s.reverse()); M = !1 } var S = THREE.Shape.Utils.triangulateShape(_, w), A = _; for (h = 0, l = w.length; h < l; h++)s = w[h], _ = _.concat(s); function C(t, e, r) { return e || THREE.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(r).add(t) } var L, P, F, U, B, D, V = _.length, z = S.length; function k(t, e, r) { var i, n, a = 1, o = t.x - e.x, s = t.y - e.y, h = r.x - t.x, l = r.y - t.y, c = o * o + s * s, u = o * l - s * h; if (Math.abs(u) > 1e-10) { var E = Math.sqrt(c), p = Math.sqrt(h * h + l * l), f = e.x - s / E, d = e.y + o / E, m = ((r.x - l / p - f) * l - (r.y + h / p - d) * h) / (o * l - s * h), T = (i = f + o * m - t.x) * i + (n = d + s * m - t.y) * n; if (T <= 2) return new THREE.Vector2(i, n); a = Math.sqrt(T / 2) } else { var g = !1; o > 1e-10 ? h > 1e-10 && (g = !0) : o < -1e-10 ? h < -1e-10 && (g = !0) : Math.sign(s) == Math.sign(l) && (g = !0), g ? (i = -s, n = o, a = Math.sqrt(c)) : (i = o, n = s, a = Math.sqrt(c / 2)) } return new THREE.Vector2(i / a, n / a) } for (var N = [], O = 0, G = A.length, I = G - 1, W = O + 1; O < G; O++ , I++ , W++)I === G && (I = 0), W === G && (W = 0), N[O] = k(A[O], A[I], A[W]); var j, X, q = [], Y = N.concat(); for (h = 0, l = w.length; h < l; h++) { for (s = w[h], j = [], O = 0, I = (G = s.length) - 1, W = O + 1; O < G; O++ , I++ , W++)I === G && (I = 0), W === G && (W = 0), j[O] = k(s[O], s[I], s[W]); q.push(j), Y = Y.concat(j) } for (L = 0; L < p; L++) { for (U = u * (1 - (F = L / p)), P = E * Math.sin(F * Math.PI / 2), O = 0, G = A.length; O < G; O++)Q((B = C(A[O], N[O], P)).x, B.y, -U); for (h = 0, l = w.length; h < l; h++)for (s = w[h], j = q[h], O = 0, G = s.length; O < G; O++)Q((B = C(s[O], j[O], P)).x, B.y, -U) } for (P = E, O = 0; O < V; O++)B = f ? C(_[O], Y[O], P) : _[O], g ? (a.copy(i.normals[0]).multiplyScalar(B.x), n.copy(i.binormals[0]).multiplyScalar(B.y), o.copy(r[0]).add(a).add(n), Q(o.x, o.y, o.z)) : Q(B.x, B.y, 0); for (X = 1; X <= m; X++)for (O = 0; O < V; O++)B = f ? C(_[O], Y[O], P) : _[O], g ? (a.copy(i.normals[X]).multiplyScalar(B.x), n.copy(i.binormals[X]).multiplyScalar(B.y), o.copy(r[X]).add(a).add(n), Q(o.x, o.y, o.z)) : Q(B.x, B.y, c / m * X); for (L = p - 1; L >= 0; L--) { for (U = u * (1 - (F = L / p)), P = E * Math.sin(F * Math.PI / 2), O = 0, G = A.length; O < G; O++)Q((B = C(A[O], N[O], P)).x, B.y, c + U); for (h = 0, l = w.length; h < l; h++)for (s = w[h], j = q[h], O = 0, G = s.length; O < G; O++)B = C(s[O], j[O], P), g ? Q(B.x, B.y + r[m - 1].y, r[m - 1].x + U) : Q(B.x, B.y, c + U) } function K(t, e) { var r, i; for (O = t.length; --O >= 0;) { r = O, (i = O - 1) < 0 && (i = t.length - 1); var n = 0, a = m + 2 * p; for (n = 0; n < a; n++) { var o = V * n, s = V * (n + 1); J(e + r + o, e + i + o, e + i + s, e + r + s, t, n, a, r, i) } } } function Q(t, e, r) { H.vertices.push(new THREE.Vector3(t, e, r)) } function Z(t, e, r) { t += x, e += x, r += x, H.faces.push(new THREE.Face3(t, e, r, null, null, v)); var i = y.generateTopUV(H, t, e, r); H.faceVertexUvs[0].push(i) } function J(t, e, r, i, n, a, o, s, h) { t += x, e += x, r += x, i += x, H.faces.push(new THREE.Face3(t, e, i, null, null, R)), H.faces.push(new THREE.Face3(e, r, i, null, null, R)); var l = y.generateSideWallUV(H, t, e, r, i); H.faceVertexUvs[0].push([l[0], l[1], l[3]]), H.faceVertexUvs[0].push([l[1], l[2], l[3]]) } !function () { if (f) { var t = 0, e = V * t; for (O = 0; O < z; O++)Z((D = S[O])[2] + e, D[1] + e, D[0] + e); for (e = V * (t = m + 2 * p), O = 0; O < z; O++)Z((D = S[O])[0] + e, D[1] + e, D[2] + e) } else { for (O = 0; O < z; O++)Z((D = S[O])[2], D[1], D[0]); for (O = 0; O < z; O++)Z((D = S[O])[0] + V * m, D[1] + V * m, D[2] + V * m) } }(), function () { var t = 0; for (K(A, t), t += A.length, h = 0, l = w.length; h < l; h++)K(s = w[h], t), t += s.length }() }, THREE.ExtrudeGeometry.WorldUVGenerator = { generateTopUV: function (t, e, r, i) { var n = t.vertices, a = n[e], o = n[r], s = n[i]; return [new THREE.Vector2(a.x, a.y), new THREE.Vector2(o.x, o.y), new THREE.Vector2(s.x, s.y)] }, generateSideWallUV: function (t, e, r, i, n) { var a = t.vertices, o = a[e], s = a[r], h = a[i], l = a[n]; return Math.abs(o.y - s.y) < .01 ? [new THREE.Vector2(o.x, 1 - o.z), new THREE.Vector2(s.x, 1 - s.z), new THREE.Vector2(h.x, 1 - h.z), new THREE.Vector2(l.x, 1 - l.z)] : [new THREE.Vector2(o.y, 1 - o.z), new THREE.Vector2(s.y, 1 - s.z), new THREE.Vector2(h.y, 1 - h.z), new THREE.Vector2(l.y, 1 - l.z)] } }, THREE.ShapeGeometry = function (t, e) { THREE.Geometry.call(this), this.type = "ShapeGeometry", t instanceof Array == !1 && (t = [t]), this.addShapeList(t, e), this.computeFaceNormals() }, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry, THREE.ShapeGeometry.prototype.addShapeList = function (t, e) { for (var r = 0, i = t.length; r < i; r++)this.addShape(t[r], e); return this }, THREE.ShapeGeometry.prototype.addShape = function (t, e) { void 0 === e && (e = {}); var r, i, n, a = void 0 !== e.curveSegments ? e.curveSegments : 12, o = e.material, s = void 0 === e.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : e.UVGenerator, h = this.vertices.length, l = t.extractPoints(a), c = l.shape, u = l.holes, E = !THREE.Shape.Utils.isClockWise(c); if (E) { for (c = c.reverse(), r = 0, i = u.length; r < i; r++)n = u[r], THREE.Shape.Utils.isClockWise(n) && (u[r] = n.reverse()); E = !1 } var p = THREE.Shape.Utils.triangulateShape(c, u); for (r = 0, i = u.length; r < i; r++)n = u[r], c = c.concat(n); var f, d, m = c.length, T = p.length; for (r = 0; r < m; r++)f = c[r], this.vertices.push(new THREE.Vector3(f.x, f.y, 0)); for (r = 0; r < T; r++) { var g = (d = p[r])[0] + h, v = d[1] + h, R = d[2] + h; this.faces.push(new THREE.Face3(g, v, R, null, null, o)), this.faceVertexUvs[0].push(s.generateTopUV(this, g, v, R)) } }, THREE.LatheGeometry = function (t, e, r, i) { THREE.Geometry.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: r, phiLength: i }, e = e || 12, r = r || 0, i = i || 2 * Math.PI; for (var n = 1 / (t.length - 1), a = 1 / e, o = 0, s = e; o <= s; o++)for (var h = r + o * a * i, l = Math.cos(h), c = Math.sin(h), u = 0, E = t.length; u < E; u++) { var p = t[u], f = new THREE.Vector3; f.x = l * p.x - c * p.y, f.y = c * p.x + l * p.y, f.z = p.z, this.vertices.push(f) } var d = t.length; for (o = 0, s = e; o < s; o++)for (u = 0, E = t.length - 1; u < E; u++) { var m = u + d * o, T = m, g = m + d, v = (l = m + 1 + d, m + 1), R = o * a, y = u * n, H = R + a, x = y + n; this.faces.push(new THREE.Face3(T, g, v)), this.faceVertexUvs[0].push([new THREE.Vector2(R, y), new THREE.Vector2(H, y), new THREE.Vector2(R, x)]), this.faces.push(new THREE.Face3(g, l, v)), this.faceVertexUvs[0].push([new THREE.Vector2(H, y), new THREE.Vector2(H, x), new THREE.Vector2(R, x)]) } this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals() }, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry, THREE.PlaneGeometry = function (t, e, r, i) { console.info("THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint."), THREE.Geometry.call(this), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: r, heightSegments: i }, this.fromBufferGeometry(new THREE.PlaneBufferGeometry(t, e, r, i)) }, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry, THREE.PlaneBufferGeometry = function (t, e, r, i) { THREE.BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: t, height: e, widthSegments: r, heightSegments: i }; for (var n = t / 2, a = e / 2, o = r || 1, s = i || 1, h = o + 1, l = s + 1, c = t / o, u = e / s, E = new Float32Array(h * l * 3), p = new Float32Array(h * l * 3), f = new Float32Array(h * l * 2), d = 0, m = 0, T = 0; T < l; T++)for (var g = T * u - a, v = 0; v < h; v++) { var R = v * c - n; E[d] = R, E[d + 1] = -g, p[d + 2] = 1, f[m] = v / o, f[m + 1] = 1 - T / s, d += 3, m += 2 } d = 0; var y = new (E.length / 3 > 65535 ? Uint32Array : Uint16Array)(o * s * 6); for (T = 0; T < s; T++)for (v = 0; v < o; v++) { var H = v + h * T, x = v + h * (T + 1), b = v + 1 + h * (T + 1), _ = v + 1 + h * T; y[d] = H, y[d + 1] = x, y[d + 2] = _, y[d + 3] = x, y[d + 4] = b, y[d + 5] = _, d += 6 } this.addAttribute("index", new THREE.BufferAttribute(y, 1)), this.addAttribute("position", new THREE.BufferAttribute(E, 3)), this.addAttribute("normal", new THREE.BufferAttribute(p, 3)), this.addAttribute("uv", new THREE.BufferAttribute(f, 2)) }, THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry, THREE.RingGeometry = function (t, e, r, i, n, a) { THREE.Geometry.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: r, phiSegments: i, thetaStart: n, thetaLength: a }, t = t || 0, e = e || 50, n = void 0 !== n ? n : 0, a = void 0 !== a ? a : 2 * Math.PI, r = void 0 !== r ? Math.max(3, r) : 8; var o, s, h = [], l = t, c = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 8); for (o = 0; o < i + 1; o++) { for (s = 0; s < r + 1; s++) { var u = new THREE.Vector3, E = n + s / r * a; u.x = l * Math.cos(E), u.y = l * Math.sin(E), this.vertices.push(u), h.push(new THREE.Vector2((u.x / e + 1) / 2, (u.y / e + 1) / 2)) } l += c } var p = new THREE.Vector3(0, 0, 1); for (o = 0; o < i; o++) { var f = o * (r + 1); for (s = 0; s < r; s++) { var d = E = s + f, m = E + r + 1, T = E + r + 2; this.faces.push(new THREE.Face3(d, m, T, [p.clone(), p.clone(), p.clone()])), this.faceVertexUvs[0].push([h[d].clone(), h[m].clone(), h[T].clone()]), d = E, m = E + r + 2, T = E + 1, this.faces.push(new THREE.Face3(d, m, T, [p.clone(), p.clone(), p.clone()])), this.faceVertexUvs[0].push([h[d].clone(), h[m].clone(), h[T].clone()]) } } this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, l) }, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry.prototype.constructor = THREE.RingGeometry, THREE.SphereGeometry = function (t, e, r, i, n, a, o) { THREE.Geometry.call(this), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: r, phiStart: i, phiLength: n, thetaStart: a, thetaLength: o }, t = t || 50, e = Math.max(3, Math.floor(e) || 8), r = Math.max(2, Math.floor(r) || 6), i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : Math.PI; var s, h, l = [], c = []; for (h = 0; h <= r; h++) { var u = [], E = []; for (s = 0; s <= e; s++) { var p = s / e, f = h / r, d = new THREE.Vector3; d.x = -t * Math.cos(i + p * n) * Math.sin(a + f * o), d.y = t * Math.cos(a + f * o), d.z = t * Math.sin(i + p * n) * Math.sin(a + f * o), this.vertices.push(d), u.push(this.vertices.length - 1), E.push(new THREE.Vector2(p, 1 - f)) } l.push(u), c.push(E) } for (h = 0; h < r; h++)for (s = 0; s < e; s++) { var m = l[h][s + 1], T = l[h][s], g = l[h + 1][s], v = l[h + 1][s + 1], R = this.vertices[m].clone().normalize(), y = this.vertices[T].clone().normalize(), H = this.vertices[g].clone().normalize(), x = this.vertices[v].clone().normalize(), b = c[h][s + 1].clone(), _ = c[h][s].clone(), w = c[h + 1][s].clone(), M = c[h + 1][s + 1].clone(); Math.abs(this.vertices[m].y) === t ? (b.x = (b.x + _.x) / 2, this.faces.push(new THREE.Face3(m, g, v, [R, H, x])), this.faceVertexUvs[0].push([b, w, M])) : Math.abs(this.vertices[g].y) === t ? (w.x = (w.x + M.x) / 2, this.faces.push(new THREE.Face3(m, T, g, [R, y, H])), this.faceVertexUvs[0].push([b, _, w])) : (this.faces.push(new THREE.Face3(m, T, v, [R, y, x])), this.faceVertexUvs[0].push([b, _, M]), this.faces.push(new THREE.Face3(T, g, v, [y.clone(), H, x.clone()])), this.faceVertexUvs[0].push([_.clone(), w, M.clone()])) } this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, t) }, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry, THREE.TextGeometry = function (t, e) { e = e || {}; var r = THREE.FontUtils.generateShapes(t, e); e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), THREE.ExtrudeGeometry.call(this, r, e), this.type = "TextGeometry" }, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), THREE.TextGeometry.prototype.constructor = THREE.TextGeometry, THREE.TorusGeometry = function (t, e, r, i, n) { THREE.Geometry.call(this), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: r, tubularSegments: i, arc: n }, t = t || 100, e = e || 40, r = r || 8, i = i || 6, n = n || 2 * Math.PI; for (var a = new THREE.Vector3, o = [], s = [], h = 0; h <= r; h++)for (var l = 0; l <= i; l++) { var c = l / i * n, u = h / r * Math.PI * 2; a.x = t * Math.cos(c), a.y = t * Math.sin(c); var E = new THREE.Vector3; E.x = (t + e * Math.cos(u)) * Math.cos(c), E.y = (t + e * Math.cos(u)) * Math.sin(c), E.z = e * Math.sin(u), this.vertices.push(E), o.push(new THREE.Vector2(l / i, h / r)), s.push(E.clone().sub(a).normalize()) } for (h = 1; h <= r; h++)for (l = 1; l <= i; l++) { var p = (i + 1) * h + l - 1, f = (i + 1) * (h - 1) + l - 1, d = (i + 1) * (h - 1) + l, m = (i + 1) * h + l, T = new THREE.Face3(p, f, m, [s[p].clone(), s[f].clone(), s[m].clone()]); this.faces.push(T), this.faceVertexUvs[0].push([o[p].clone(), o[f].clone(), o[m].clone()]), T = new THREE.Face3(f, d, m, [s[f].clone(), s[d].clone(), s[m].clone()]), this.faces.push(T), this.faceVertexUvs[0].push([o[f].clone(), o[d].clone(), o[m].clone()]) } this.computeFaceNormals() }, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry, THREE.TorusKnotGeometry = function (t, e, r, i, n, a, o) { THREE.Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, radialSegments: r, tubularSegments: i, p: n, q: a, heightScale: o }, t = t || 100, e = e || 40, r = r || 64, i = i || 8, n = n || 2, a = a || 3, o = o || 1; for (var s = new Array(r), h = new THREE.Vector3, l = new THREE.Vector3, c = new THREE.Vector3, u = 0; u < r; ++u) { s[u] = new Array(i); var E = u / r * 2 * n * Math.PI, p = C(E, a, n, t, o), f = C(E + .01, a, n, t, o); h.subVectors(f, p), l.addVectors(f, p), c.crossVectors(h, l), l.crossVectors(c, h), c.normalize(), l.normalize(); for (var d = 0; d < i; ++d) { var m = d / i * 2 * Math.PI, T = -e * Math.cos(m), g = e * Math.sin(m), v = new THREE.Vector3; v.x = p.x + T * l.x + g * c.x, v.y = p.y + T * l.y + g * c.y, v.z = p.z + T * l.z + g * c.z, s[u][d] = this.vertices.push(v) - 1 } } for (u = 0; u < r; ++u)for (d = 0; d < i; ++d) { var R = (u + 1) % r, y = (d + 1) % i, H = s[u][d], x = s[R][d], b = s[R][y], _ = s[u][y], w = new THREE.Vector2(u / r, d / i), M = new THREE.Vector2((u + 1) / r, d / i), S = new THREE.Vector2((u + 1) / r, (d + 1) / i), A = new THREE.Vector2(u / r, (d + 1) / i); this.faces.push(new THREE.Face3(H, x, _)), this.faceVertexUvs[0].push([w, M, A]), this.faces.push(new THREE.Face3(x, b, _)), this.faceVertexUvs[0].push([M.clone(), S, A.clone()]) } function C(t, e, r, i, n) { var a = Math.cos(t), o = Math.sin(t), s = e / r * t, h = Math.cos(s), l = i * (2 + h) * .5 * a, c = i * (2 + h) * o * .5, u = n * i * Math.sin(s) * .5; return new THREE.Vector3(l, c, u) } this.computeFaceNormals(), this.computeVertexNormals() }, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry, THREE.TubeGeometry = function (t, e, r, i, n, a) { THREE.Geometry.call(this), this.type = "TubeGeometry", this.parameters = { path: t, segments: e, radius: r, radialSegments: i, closed: n }, e = e || 64, r = r || 1, i = i || 8, n = n || !1, a = a || THREE.TubeGeometry.NoTaper; var o, s, h, l, c, u, E, p, f, d, m, T, g, v, R, y, H, x, b, _, w, M, S, A = [], C = this, L = e + 1, P = new THREE.Vector3, F = new THREE.TubeGeometry.FrenetFrames(t, e, n), U = F.tangents, B = F.normals, D = F.binormals; for (this.tangents = U, this.normals = B, this.binormals = D, f = 0; f < L; f++)for (A[f] = [], h = f / (L - 1), p = t.getPointAt(h), U[f], o = B[f], s = D[f], c = r * a(h), d = 0; d < i; d++)l = d / i * 2 * Math.PI, u = -c * Math.cos(l), E = c * Math.sin(l), P.copy(p), P.x += u * o.x + E * s.x, P.y += u * o.y + E * s.y, P.z += u * o.z + E * s.z, A[f][d] = (w = P.x, M = P.y, S = P.z, C.vertices.push(new THREE.Vector3(w, M, S)) - 1); for (f = 0; f < e; f++)for (d = 0; d < i; d++)m = n ? (f + 1) % e : f + 1, T = (d + 1) % i, g = A[f][d], v = A[m][d], R = A[m][T], y = A[f][T], H = new THREE.Vector2(f / e, d / i), x = new THREE.Vector2((f + 1) / e, d / i), b = new THREE.Vector2((f + 1) / e, (d + 1) / i), _ = new THREE.Vector2(f / e, (d + 1) / i), this.faces.push(new THREE.Face3(g, v, y)), this.faceVertexUvs[0].push([H, x, _]), this.faces.push(new THREE.Face3(v, R, y)), this.faceVertexUvs[0].push([x.clone(), b, _.clone()]); this.computeFaceNormals(), this.computeVertexNormals() }, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry, THREE.TubeGeometry.NoTaper = function (t) { return 1 }, THREE.TubeGeometry.SinusoidalTaper = function (t) { return Math.sin(Math.PI * t) }, THREE.TubeGeometry.FrenetFrames = function (t, e, r) { var i, n, a, o, s, h, l, c = new THREE.Vector3, u = [], E = [], p = [], f = new THREE.Vector3, d = new THREE.Matrix4, m = e + 1; for (this.tangents = u, this.normals = E, this.binormals = p, h = 0; h < m; h++)l = h / (m - 1), u[h] = t.getTangentAt(l), u[h].normalize(); for (function () { E[0] = new THREE.Vector3, p[0] = new THREE.Vector3, n = Number.MAX_VALUE, a = Math.abs(u[0].x), o = Math.abs(u[0].y), s = Math.abs(u[0].z), a <= n && (n = a, c.set(1, 0, 0)); o <= n && (n = o, c.set(0, 1, 0)); s <= n && c.set(0, 0, 1); f.crossVectors(u[0], c).normalize(), E[0].crossVectors(u[0], f), p[0].crossVectors(u[0], E[0]) }(), h = 1; h < m; h++)E[h] = E[h - 1].clone(), p[h] = p[h - 1].clone(), f.crossVectors(u[h - 1], u[h]), f.length() > 1e-4 && (f.normalize(), i = Math.acos(THREE.Math.clamp(u[h - 1].dot(u[h]), -1, 1)), E[h].applyMatrix4(d.makeRotationAxis(f, i))), p[h].crossVectors(u[h], E[h]); if (r) for (i = Math.acos(THREE.Math.clamp(E[0].dot(E[m - 1]), -1, 1)), i /= m - 1, u[0].dot(f.crossVectors(E[0], E[m - 1])) > 0 && (i = -i), h = 1; h < m; h++)E[h].applyMatrix4(d.makeRotationAxis(u[h], i * h)), p[h].crossVectors(u[h], E[h]) }, THREE.PolyhedronGeometry = function (t, e, r, i) { THREE.Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: r, detail: i }, r = r || 1, i = i || 0; for (var n = this, a = 0, o = t.length; a < o; a += 3)R(new THREE.Vector3(t[a], t[a + 1], t[a + 2])); var s = this.vertices, h = [], l = (a = 0, 0); for (o = e.length; a < o; a += 3, l++) { var c = s[e[a]], u = s[e[a + 1]], E = s[e[a + 2]]; h[l] = new THREE.Face3(c.index, u.index, E.index, [c.clone(), u.clone(), E.clone()]) } var p = new THREE.Vector3; for (a = 0, o = h.length; a < o; a++)H(h[a], i); for (a = 0, o = this.faceVertexUvs[0].length; a < o; a++) { var f = this.faceVertexUvs[0][a], d = f[0].x, m = f[1].x, T = f[2].x, g = Math.max(d, Math.max(m, T)), v = Math.min(d, Math.min(m, T)); g > .9 && v < .1 && (d < .2 && (f[0].x += 1), m < .2 && (f[1].x += 1), T < .2 && (f[2].x += 1)) } for (a = 0, o = this.vertices.length; a < o; a++)this.vertices[a].multiplyScalar(r); function R(t) { var e = t.normalize().clone(); e.index = n.vertices.push(e) - 1; var r = x(t) / 2 / Math.PI + .5, i = function (t) { return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) }(t) / Math.PI + .5; return e.uv = new THREE.Vector2(r, 1 - i), e } function y(t, e, r) { var i = new THREE.Face3(t.index, e.index, r.index, [t.clone(), e.clone(), r.clone()]); n.faces.push(i), p.copy(t).add(e).add(r).divideScalar(3); var a = x(p); n.faceVertexUvs[0].push([b(t.uv, t, a), b(e.uv, e, a), b(r.uv, r, a)]) } function H(t, e) { for (var r = Math.pow(2, e), i = R(n.vertices[t.a]), a = R(n.vertices[t.b]), o = R(n.vertices[t.c]), s = [], h = 0; h <= r; h++) { s[h] = []; for (var l = R(i.clone().lerp(o, h / r)), c = R(a.clone().lerp(o, h / r)), u = r - h, E = 0; E <= u; E++)s[h][E] = 0 == E && h == r ? l : R(l.clone().lerp(c, E / u)) } for (h = 0; h < r; h++)for (E = 0; E < 2 * (r - h) - 1; E++) { var p = Math.floor(E / 2); E % 2 == 0 ? y(s[h][p + 1], s[h + 1][p], s[h][p]) : y(s[h][p + 1], s[h + 1][p + 1], s[h + 1][p]) } } function x(t) { return Math.atan2(t.z, -t.x) } function b(t, e, r) { return r < 0 && 1 === t.x && (t = new THREE.Vector2(t.x - 1, t.y)), 0 === e.x && 0 === e.z && (t = new THREE.Vector2(r / 2 / Math.PI + .5, t.y)), t.clone() } this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, r) }, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry, THREE.DodecahedronGeometry = function (t, e) { this.parameters = { radius: t, detail: e }; var r = (1 + Math.sqrt(5)) / 2, i = 1 / r, n = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, 0, -r, 0, -i, r, 0, -i, -r, 0, i, r, 0, i]; THREE.PolyhedronGeometry.call(this, n, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e) }, THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry, THREE.IcosahedronGeometry = function (t, e) { var r = (1 + Math.sqrt(5)) / 2, i = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1]; THREE.PolyhedronGeometry.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e } }, THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry, THREE.OctahedronGeometry = function (t, e) { this.parameters = { radius: t, detail: e }; THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e } }, THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry, THREE.TetrahedronGeometry = function (t, e) { THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e } }, THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry, THREE.ParametricGeometry = function (t, e, r) { THREE.Geometry.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: r }; var i, n, a, o, s, h, l, c, u, E, p, f, d = this.vertices, m = this.faces, T = this.faceVertexUvs[0], g = e + 1; for (i = 0; i <= r; i++)for (o = i / r, n = 0; n <= e; n++)a = t(n / e, o), d.push(a); for (i = 0; i < r; i++)for (n = 0; n < e; n++)s = i * g + n, h = i * g + n + 1, l = (i + 1) * g + n + 1, c = (i + 1) * g + n, u = new THREE.Vector2(n / e, i / r), E = new THREE.Vector2((n + 1) / e, i / r), p = new THREE.Vector2((n + 1) / e, (i + 1) / r), f = new THREE.Vector2(n / e, (i + 1) / r), m.push(new THREE.Face3(s, h, c)), T.push([u, E, f]), m.push(new THREE.Face3(h, l, c)), T.push([E.clone(), p, f.clone()]); this.computeFaceNormals(), this.computeVertexNormals() }, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry, THREE.AxisHelper = function (t) { t = t || 1; var e = new Float32Array([0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]), r = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]), i = new THREE.BufferGeometry; i.addAttribute("position", new THREE.BufferAttribute(e, 3)), i.addAttribute("color", new THREE.BufferAttribute(r, 3)); var n = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors }); THREE.Line.call(this, i, n, THREE.LinePieces) }, THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype), THREE.AxisHelper.prototype.constructor = THREE.AxisHelper, THREE.ArrowHelper = function () { var t = new THREE.Geometry; t.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)); var e = new THREE.CylinderGeometry(0, .5, 1, 5, 1); return e.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)), function (r, i, n, a, o, s) { THREE.Object3D.call(this), void 0 === a && (a = 16776960), void 0 === n && (n = 1), void 0 === o && (o = .2 * n), void 0 === s && (s = .2 * o), this.position.copy(i), this.line = new THREE.Line(t, new THREE.LineBasicMaterial({ color: a })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new THREE.Mesh(e, new THREE.MeshBasicMaterial({ color: a })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(r), this.setLength(n, o, s) } }(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper, THREE.ArrowHelper.prototype.setDirection = function () { var t, e = new THREE.Vector3; return function (r) { r.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : r.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(r.z, 0, -r.x).normalize(), t = Math.acos(r.y), this.quaternion.setFromAxisAngle(e, t)) } }(), THREE.ArrowHelper.prototype.setLength = function (t, e, r) { void 0 === e && (e = .2 * t), void 0 === r && (r = .2 * e), this.line.scale.set(1, t - e, 1), this.line.updateMatrix(), this.cone.scale.set(r, e, r), this.cone.position.y = t, this.cone.updateMatrix() }, THREE.ArrowHelper.prototype.setColor = function (t) { this.line.material.color.set(t), this.cone.material.color.set(t) }, THREE.BoxHelper = function (t) { var e = new THREE.BufferGeometry; e.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3)), THREE.Line.call(this, e, new THREE.LineBasicMaterial({ color: 16776960 }), THREE.LinePieces), void 0 !== t && this.update(t) }, THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype), THREE.BoxHelper.prototype.constructor = THREE.BoxHelper, THREE.BoxHelper.prototype.update = function (t) { var e = t.geometry; null === e.boundingBox && e.computeBoundingBox(); var r = e.boundingBox.min, i = e.boundingBox.max, n = this.geometry.attributes.position.array; n[0] = i.x, n[1] = i.y, n[2] = i.z, n[3] = r.x, n[4] = i.y, n[5] = i.z, n[6] = r.x, n[7] = i.y, n[8] = i.z, n[9] = r.x, n[10] = r.y, n[11] = i.z, n[12] = r.x, n[13] = r.y, n[14] = i.z, n[15] = i.x, n[16] = r.y, n[17] = i.z, n[18] = i.x, n[19] = r.y, n[20] = i.z, n[21] = i.x, n[22] = i.y, n[23] = i.z, n[24] = i.x, n[25] = i.y, n[26] = r.z, n[27] = r.x, n[28] = i.y, n[29] = r.z, n[30] = r.x, n[31] = i.y, n[32] = r.z, n[33] = r.x, n[34] = r.y, n[35] = r.z, n[36] = r.x, n[37] = r.y, n[38] = r.z, n[39] = i.x, n[40] = r.y, n[41] = r.z, n[42] = i.x, n[43] = r.y, n[44] = r.z, n[45] = i.x, n[46] = i.y, n[47] = r.z, n[48] = i.x, n[49] = i.y, n[50] = i.z, n[51] = i.x, n[52] = i.y, n[53] = r.z, n[54] = r.x, n[55] = i.y, n[56] = i.z, n[57] = r.x, n[58] = i.y, n[59] = r.z, n[60] = r.x, n[61] = r.y, n[62] = i.z, n[63] = r.x, n[64] = r.y, n[65] = r.z, n[66] = i.x, n[67] = r.y, n[68] = i.z, n[69] = i.x, n[70] = r.y, n[71] = r.z, this.geometry.attributes.position.needsUpdate = !0, this.geometry.computeBoundingSphere(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 }, THREE.BoundingBoxHelper = function (t, e) { var r = void 0 !== e ? e : 8947848; this.object = t, this.box = new THREE.Box3, THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: r, wireframe: !0 })) }, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper, THREE.BoundingBoxHelper.prototype.update = function () { this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position) }, THREE.CameraHelper = function (t) { var e = new THREE.Geometry, r = new THREE.LineBasicMaterial({ color: 16777215, vertexColors: THREE.FaceColors }), i = {}; function n(t, e, r) { a(t, r), a(e, r) } function a(t, r) { e.vertices.push(new THREE.Vector3), e.colors.push(new THREE.Color(r)), void 0 === i[t] && (i[t] = []), i[t].push(e.vertices.length - 1) } n("n1", "n2", 16755200), n("n2", "n4", 16755200), n("n4", "n3", 16755200), n("n3", "n1", 16755200), n("f1", "f2", 16755200), n("f2", "f4", 16755200), n("f4", "f3", 16755200), n("f3", "f1", 16755200), n("n1", "f1", 16755200), n("n2", "f2", 16755200), n("n3", "f3", 16755200), n("n4", "f4", 16755200), n("p", "n1", 16711680), n("p", "n2", 16711680), n("p", "n3", 16711680), n("p", "n4", 16711680), n("u1", "u2", 43775), n("u2", "u3", 43775), n("u3", "u1", 43775), n("c", "t", 16777215), n("p", "c", 3355443), n("cn1", "cn2", 3355443), n("cn3", "cn4", 3355443), n("cf1", "cf2", 3355443), n("cf3", "cf4", 3355443), THREE.Line.call(this, e, r, THREE.LinePieces), this.camera = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = i, this.update() }, THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype), THREE.CameraHelper.prototype.constructor = THREE.CameraHelper, THREE.CameraHelper.prototype.update = function () { var t, e, r = new THREE.Vector3, i = new THREE.Camera, n = function (n, a, o, s) { r.set(a, o, s).unproject(i); var h = e[n]; if (void 0 !== h) for (var l = 0, c = h.length; l < c; l++)t.vertices[h[l]].copy(r) }; return function () { t = this.geometry, e = this.pointMap; i.projectionMatrix.copy(this.camera.projectionMatrix), n("c", 0, 0, -1), n("t", 0, 0, 1), n("n1", -1, -1, -1), n("n2", 1, -1, -1), n("n3", -1, 1, -1), n("n4", 1, 1, -1), n("f1", -1, -1, 1), n("f2", 1, -1, 1), n("f3", -1, 1, 1), n("f4", 1, 1, 1), n("u1", .7, 1.1, -1), n("u2", -.7, 1.1, -1), n("u3", 0, 2, -1), n("cf1", -1, 0, 1), n("cf2", 1, 0, 1), n("cf3", 0, -1, 1), n("cf4", 0, 1, 1), n("cn1", -1, 0, -1), n("cn2", 1, 0, -1), n("cn3", 0, -1, -1), n("cn4", 0, 1, -1), t.verticesNeedUpdate = !0 } }(), THREE.DirectionalLightHelper = function (t, e) { THREE.Object3D.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, e = e || 1; var r = new THREE.Geometry; r.vertices.push(new THREE.Vector3(-e, e, 0), new THREE.Vector3(e, e, 0), new THREE.Vector3(e, -e, 0), new THREE.Vector3(-e, -e, 0), new THREE.Vector3(-e, e, 0)); var i = new THREE.LineBasicMaterial({ fog: !1 }); i.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Line(r, i), this.add(this.lightPlane), (r = new THREE.Geometry).vertices.push(new THREE.Vector3, new THREE.Vector3), (i = new THREE.LineBasicMaterial({ fog: !1 })).color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(r, i), this.add(this.targetLine), this.update() }, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper, THREE.DirectionalLightHelper.prototype.dispose = function () { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, THREE.DirectionalLightHelper.prototype.update = function () { var t = new THREE.Vector3, e = new THREE.Vector3, r = new THREE.Vector3; return function () { t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), r.subVectors(e, t), this.lightPlane.lookAt(r), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(r), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color) } }(), THREE.EdgesHelper = function (t, e, r) { var i = void 0 !== e ? e : 16777215; r = void 0 !== r ? r : 1; var n, a = Math.cos(THREE.Math.degToRad(r)), o = [0, 0], s = {}, h = function (t, e) { return t - e }, l = ["a", "b", "c"], c = new THREE.BufferGeometry; t.geometry instanceof THREE.BufferGeometry ? (n = new THREE.Geometry).fromBufferGeometry(t.geometry) : n = t.geometry.clone(), n.mergeVertices(), n.computeFaceNormals(); for (var u = n.vertices, E = n.faces, p = 0, f = 0, d = E.length; f < d; f++)for (var m = E[f], T = 0; T < 3; T++) { o[0] = m[l[T]], o[1] = m[l[(T + 1) % 3]], o.sort(h), void 0 === s[R = o.toString()] ? (s[R] = { vert1: o[0], vert2: o[1], face1: f, face2: void 0 }, p++) : s[R].face2 = f } var g = new Float32Array(2 * p * 3), v = 0; for (var R in s) { var y = s[R]; if (void 0 === y.face2 || E[y.face1].normal.dot(E[y.face2].normal) <= a) { var H = u[y.vert1]; g[v++] = H.x, g[v++] = H.y, g[v++] = H.z, H = u[y.vert2], g[v++] = H.x, g[v++] = H.y, g[v++] = H.z } } c.addAttribute("position", new THREE.BufferAttribute(g, 3)), THREE.Line.call(this, c, new THREE.LineBasicMaterial({ color: i }), THREE.LinePieces), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 }, THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype), THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper, THREE.FaceNormalsHelper = function (t, e, r, i) { this.object = t, this.size = void 0 !== e ? e : 1; for (var n = void 0 !== r ? r : 16776960, a = void 0 !== i ? i : 1, o = new THREE.Geometry, s = 0, h = this.object.geometry.faces.length; s < h; s++)o.vertices.push(new THREE.Vector3, new THREE.Vector3); THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: n, linewidth: a }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update() }, THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper, THREE.FaceNormalsHelper.prototype.update = function () { var t = this.geometry.vertices, e = this.object, r = e.geometry.vertices, i = e.geometry.faces, n = e.matrixWorld; e.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(n); for (var a = 0, o = 0, s = i.length; a < s; a++ , o += 2) { var h = i[a]; t[o].copy(r[h.a]).add(r[h.b]).add(r[h.c]).divideScalar(3).applyMatrix4(n), t[o + 1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(t[o]) } return this.geometry.verticesNeedUpdate = !0, this }, THREE.GridHelper = function (t, e) { var r = new THREE.Geometry, i = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors }); this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848); for (var n = -t; n <= t; n += e) { r.vertices.push(new THREE.Vector3(-t, 0, n), new THREE.Vector3(t, 0, n), new THREE.Vector3(n, 0, -t), new THREE.Vector3(n, 0, t)); var a = 0 === n ? this.color1 : this.color2; r.colors.push(a, a, a, a) } THREE.Line.call(this, r, i, THREE.LinePieces) }, THREE.GridHelper.prototype = Object.create(THREE.Line.prototype), THREE.GridHelper.prototype.constructor = THREE.GridHelper, THREE.GridHelper.prototype.setColors = function (t, e) { this.color1.set(t), this.color2.set(e), this.geometry.colorsNeedUpdate = !0 }, THREE.HemisphereLightHelper = function (t, e) { THREE.Object3D.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new THREE.Color, new THREE.Color]; var r = new THREE.SphereGeometry(e, 4, 2); r.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2)); for (var i = 0; i < 8; i++)r.faces[i].color = this.colors[i < 4 ? 0 : 1]; var n = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors, wireframe: !0 }); this.lightSphere = new THREE.Mesh(r, n), this.add(this.lightSphere), this.update() }, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper, THREE.HemisphereLightHelper.prototype.dispose = function () { this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose() }, THREE.HemisphereLightHelper.prototype.update = function () { var t = new THREE.Vector3; return function () { this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0 } }(), THREE.PointLightHelper = function (t, e) { this.light = t, this.light.updateMatrixWorld(); var r = new THREE.SphereGeometry(e, 4, 2), i = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 }); i.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, r, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1 }, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper, THREE.PointLightHelper.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, THREE.PointLightHelper.prototype.update = function () { this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity) }, THREE.SkeletonHelper = function (t) { this.bones = this.getBoneList(t); for (var e = new THREE.Geometry, r = 0; r < this.bones.length; r++) { this.bones[r].parent instanceof THREE.Bone && (e.vertices.push(new THREE.Vector3), e.vertices.push(new THREE.Vector3), e.colors.push(new THREE.Color(0, 0, 1)), e.colors.push(new THREE.Color(0, 1, 0))) } var i = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, depthTest: !1, depthWrite: !1, transparent: !0 }); THREE.Line.call(this, e, i, THREE.LinePieces), this.root = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.update() }, THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype), THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper, THREE.SkeletonHelper.prototype.getBoneList = function (t) { var e = []; t instanceof THREE.Bone && e.push(t); for (var r = 0; r < t.children.length; r++)e.push.apply(e, this.getBoneList(t.children[r])); return e }, THREE.SkeletonHelper.prototype.update = function () { for (var t = this.geometry, e = (new THREE.Matrix4).getInverse(this.root.matrixWorld), r = new THREE.Matrix4, i = 0, n = 0; n < this.bones.length; n++) { var a = this.bones[n]; a.parent instanceof THREE.Bone && (r.multiplyMatrices(e, a.matrixWorld), t.vertices[i].setFromMatrixPosition(r), r.multiplyMatrices(e, a.parent.matrixWorld), t.vertices[i + 1].setFromMatrixPosition(r), i += 2) } t.verticesNeedUpdate = !0, t.computeBoundingSphere() }, THREE.SpotLightHelper = function (t) { THREE.Object3D.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1; var e = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0); e.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2)); var r = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 }); this.cone = new THREE.Mesh(e, r), this.add(this.cone), this.update() }, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper, THREE.SpotLightHelper.prototype.dispose = function () { this.cone.geometry.dispose(), this.cone.material.dispose() }, THREE.SpotLightHelper.prototype.update = function () { var t = new THREE.Vector3, e = new THREE.Vector3; return function () { var r = this.light.distance ? this.light.distance : 1e4, i = r * Math.tan(this.light.angle); this.cone.scale.set(i, i, r), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity) } }(), THREE.VertexNormalsHelper = function (t, e, r, i) { this.object = t, this.size = void 0 !== e ? e : 1; for (var n = void 0 !== r ? r : 16711680, a = void 0 !== i ? i : 1, o = new THREE.Geometry, s = t.geometry.faces, h = 0, l = s.length; h < l; h++)for (var c = 0, u = s[h].vertexNormals.length; c < u; c++)o.vertices.push(new THREE.Vector3, new THREE.Vector3); THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: n, linewidth: a }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update() }, THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper, THREE.VertexNormalsHelper.prototype.update = function (t) { var e = new THREE.Vector3; return function (t) { var r = ["a", "b", "c", "d"]; this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld); for (var i = this.geometry.vertices, n = this.object.geometry.vertices, a = this.object.geometry.faces, o = this.object.matrixWorld, s = 0, h = 0, l = a.length; h < l; h++)for (var c = a[h], u = 0, E = c.vertexNormals.length; u < E; u++) { var p = n[c[r[u]]], f = c.vertexNormals[u]; i[s].copy(p).applyMatrix4(o), e.copy(f).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), e.add(i[s]), i[s += 1].copy(e), s += 1 } return this.geometry.verticesNeedUpdate = !0, this } }(), THREE.VertexTangentsHelper = function (t, e, r, i) { this.object = t, this.size = void 0 !== e ? e : 1; for (var n = void 0 !== r ? r : 255, a = void 0 !== i ? i : 1, o = new THREE.Geometry, s = t.geometry.faces, h = 0, l = s.length; h < l; h++)for (var c = 0, u = s[h].vertexTangents.length; c < u; c++)o.vertices.push(new THREE.Vector3), o.vertices.push(new THREE.Vector3); THREE.Line.call(this, o, new THREE.LineBasicMaterial({ color: n, linewidth: a }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.update() }, THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper, THREE.VertexTangentsHelper.prototype.update = function (t) { var e = new THREE.Vector3; return function (t) { var r = ["a", "b", "c", "d"]; this.object.updateMatrixWorld(!0); for (var i = this.geometry.vertices, n = this.object.geometry.vertices, a = this.object.geometry.faces, o = this.object.matrixWorld, s = 0, h = 0, l = a.length; h < l; h++)for (var c = a[h], u = 0, E = c.vertexTangents.length; u < E; u++) { var p = n[c[r[u]]], f = c.vertexTangents[u]; i[s].copy(p).applyMatrix4(o), e.copy(f).transformDirection(o).multiplyScalar(this.size), e.add(i[s]), i[s += 1].copy(e), s += 1 } return this.geometry.verticesNeedUpdate = !0, this } }(), THREE.WireframeHelper = function (t, e) { var r = void 0 !== e ? e : 16777215, i = [0, 0], n = {}, a = function (t, e) { return t - e }, o = ["a", "b", "c"], s = new THREE.BufferGeometry; if (t.geometry instanceof THREE.Geometry) { for (var h = t.geometry.vertices, l = t.geometry.faces, c = 0, u = new Uint32Array(6 * l.length), E = 0, p = l.length; E < p; E++)for (var f = l[E], d = 0; d < 3; d++) { i[0] = f[o[d]], i[1] = f[o[(d + 1) % 3]], i.sort(a), void 0 === n[w = i.toString()] && (u[2 * c] = i[0], u[2 * c + 1] = i[1], n[w] = !0, c++) } var m = new Float32Array(2 * c * 3); for (E = 0, p = c; E < p; E++)for (d = 0; d < 2; d++) { var T = h[u[2 * E + d]]; m[(b = 6 * E + 3 * d) + 0] = T.x, m[b + 1] = T.y, m[b + 2] = T.z } s.addAttribute("position", new THREE.BufferAttribute(m, 3)) } else if (t.geometry instanceof THREE.BufferGeometry) if (void 0 !== t.geometry.attributes.index) { h = t.geometry.attributes.position.array; var g = t.geometry.attributes.index.array, v = t.geometry.drawcalls; c = 0; 0 === v.length && (v = [{ count: g.length, index: 0, start: 0 }]); u = new Uint32Array(2 * g.length); for (var R = 0, y = v.length; R < y; ++R)for (var H = v[R].start, x = v[R].count, b = v[R].index, _ = (E = H, H + x); E < _; E += 3)for (d = 0; d < 3; d++) { var w; i[0] = b + g[E + d], i[1] = b + g[E + (d + 1) % 3], i.sort(a), void 0 === n[w = i.toString()] && (u[2 * c] = i[0], u[2 * c + 1] = i[1], n[w] = !0, c++) } for (m = new Float32Array(2 * c * 3), E = 0, p = c; E < p; E++)for (d = 0; d < 2; d++) { b = 6 * E + 3 * d; var M = 3 * u[2 * E + d]; m[b + 0] = h[M], m[b + 1] = h[M + 1], m[b + 2] = h[M + 2] } s.addAttribute("position", new THREE.BufferAttribute(m, 3)) } else { var S = (c = (h = t.geometry.attributes.position.array).length / 3) / 3; for (m = new Float32Array(2 * c * 3), E = 0, p = S; E < p; E++)for (d = 0; d < 3; d++) { var A = 9 * E + 3 * d; m[(b = 18 * E + 6 * d) + 0] = h[A], m[b + 1] = h[A + 1], m[b + 2] = h[A + 2]; M = 9 * E + (d + 1) % 3 * 3; m[b + 3] = h[M], m[b + 4] = h[M + 1], m[b + 5] = h[M + 2] } s.addAttribute("position", new THREE.BufferAttribute(m, 3)) } THREE.Line.call(this, s, new THREE.LineBasicMaterial({ color: r }), THREE.LinePieces), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 }, THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype), THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper, THREE.ImmediateRenderObject = function () { THREE.Object3D.call(this), this.render = function (t) { } }, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject, THREE.MorphBlendMesh = function (t, e) { THREE.Mesh.call(this, t, e), this.animationsMap = {}, this.animationsList = []; var r = this.geometry.morphTargets.length, i = r - 1, n = r / 1; this.createAnimation("__default", 0, i, n), this.setAnimationWeight("__default", 1) }, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh, THREE.MorphBlendMesh.prototype.createAnimation = function (t, e, r, i) { var n = { startFrame: e, endFrame: r, length: r - e + 1, fps: i, duration: (r - e) / i, lastFrame: 0, currentFrame: 0, active: !1, time: 0, direction: 1, weight: 1, directionBackwards: !1, mirroredLoop: !1 }; this.animationsMap[t] = n, this.animationsList.push(n) }, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (t) { for (var e, r = /([a-z]+)_?(\d+)/, i = {}, n = this.geometry, a = 0, o = n.morphTargets.length; a < o; a++) { var s = n.morphTargets[a].name.match(r); if (s && s.length > 1) i[h = s[1]] || (i[h] = { start: 1 / 0, end: -1 / 0 }), a < (l = i[h]).start && (l.start = a), a > l.end && (l.end = a), e || (e = h) } for (var h in i) { var l = i[h]; this.createAnimation(h, l.start, l.end, t) } this.firstAnimation = e }, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (t) { var e = this.animationsMap[t]; e && (e.direction = 1, e.directionBackwards = !1) }, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (t) { var e = this.animationsMap[t]; e && (e.direction = -1, e.directionBackwards = !0) }, THREE.MorphBlendMesh.prototype.setAnimationFPS = function (t, e) { var r = this.animationsMap[t]; r && (r.fps = e, r.duration = (r.end - r.start) / r.fps) }, THREE.MorphBlendMesh.prototype.setAnimationDuration = function (t, e) { var r = this.animationsMap[t]; r && (r.duration = e, r.fps = (r.end - r.start) / r.duration) }, THREE.MorphBlendMesh.prototype.setAnimationWeight = function (t, e) { var r = this.animationsMap[t]; r && (r.weight = e) }, THREE.MorphBlendMesh.prototype.setAnimationTime = function (t, e) { var r = this.animationsMap[t]; r && (r.time = e) }, THREE.MorphBlendMesh.prototype.getAnimationTime = function (t) { var e = 0, r = this.animationsMap[t]; return r && (e = r.time), e }, THREE.MorphBlendMesh.prototype.getAnimationDuration = function (t) { var e = -1, r = this.animationsMap[t]; return r && (e = r.duration), e }, THREE.MorphBlendMesh.prototype.playAnimation = function (t) { var e = this.animationsMap[t]; e ? (e.time = 0, e.active = !0) : THREE.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()") }, THREE.MorphBlendMesh.prototype.stopAnimation = function (t) { var e = this.animationsMap[t]; e && (e.active = !1) }, THREE.MorphBlendMesh.prototype.update = function (t) { for (var e = 0, r = this.animationsList.length; e < r; e++) { var i = this.animationsList[e]; if (i.active) { var n = i.duration / i.length; i.time += i.direction * t, i.mirroredLoop ? (i.time > i.duration || i.time < 0) && (i.direction *= -1, i.time > i.duration && (i.time = i.duration, i.directionBackwards = !0), i.time < 0 && (i.time = 0, i.directionBackwards = !1)) : (i.time = i.time % i.duration, i.time < 0 && (i.time += i.duration)); var a = i.startFrame + THREE.Math.clamp(Math.floor(i.time / n), 0, i.length - 1), o = i.weight; a !== i.currentFrame && (this.morphTargetInfluences[i.lastFrame] = 0, this.morphTargetInfluences[i.currentFrame] = 1 * o, this.morphTargetInfluences[a] = 0, i.lastFrame = i.currentFrame, i.currentFrame = a); var s = i.time % n / n; i.directionBackwards && (s = 1 - s), this.morphTargetInfluences[i.currentFrame] = s * o, this.morphTargetInfluences[i.lastFrame] = (1 - s) * o } } };